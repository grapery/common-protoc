// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Rankquantity_Voyager_Api_TokenSource: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// 用户自己的token
  case userSelf // = 0

  /// 故事存储的token
  case storyStore // = 1

  /// 三方赞助的token
  case thirdParty // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .userSelf
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .userSelf
    case 1: self = .storyStore
    case 2: self = .thirdParty
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .userSelf: return 0
    case .storyStore: return 1
    case .thirdParty: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Rankquantity_Voyager_Api_TokenSource] = [
    .userSelf,
    .storyStore,
    .thirdParty,
  ]

}

public struct Rankquantity_Voyager_Api_ActiveInfo: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var activeID: Int64 {
    get {return _storage._activeID}
    set {_uniqueStorage()._activeID = newValue}
  }

  public var user: Rankquantity_Voyager_Api_UserInfo {
    get {return _storage._user ?? Rankquantity_Voyager_Api_UserInfo()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  public var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  public mutating func clearUser() {_uniqueStorage()._user = nil}

  public var activeType: Rankquantity_Voyager_Api_ActiveType {
    get {return _storage._activeType}
    set {_uniqueStorage()._activeType = newValue}
  }

  public var groupInfo: Rankquantity_Voyager_Api_GroupInfo {
    get {return _storage._groupInfo ?? Rankquantity_Voyager_Api_GroupInfo()}
    set {_uniqueStorage()._groupInfo = newValue}
  }
  /// Returns true if `groupInfo` has been explicitly set.
  public var hasGroupInfo: Bool {return _storage._groupInfo != nil}
  /// Clears the value of `groupInfo`. Subsequent reads from it will return its default value.
  public mutating func clearGroupInfo() {_uniqueStorage()._groupInfo = nil}

  public var storyInfo: Rankquantity_Voyager_Api_Story {
    get {return _storage._storyInfo ?? Rankquantity_Voyager_Api_Story()}
    set {_uniqueStorage()._storyInfo = newValue}
  }
  /// Returns true if `storyInfo` has been explicitly set.
  public var hasStoryInfo: Bool {return _storage._storyInfo != nil}
  /// Clears the value of `storyInfo`. Subsequent reads from it will return its default value.
  public mutating func clearStoryInfo() {_uniqueStorage()._storyInfo = nil}

  public var roleInfo: Rankquantity_Voyager_Api_StoryRole {
    get {return _storage._roleInfo ?? Rankquantity_Voyager_Api_StoryRole()}
    set {_uniqueStorage()._roleInfo = newValue}
  }
  /// Returns true if `roleInfo` has been explicitly set.
  public var hasRoleInfo: Bool {return _storage._roleInfo != nil}
  /// Clears the value of `roleInfo`. Subsequent reads from it will return its default value.
  public mutating func clearRoleInfo() {_uniqueStorage()._roleInfo = nil}

  public var boardInfo: Rankquantity_Voyager_Api_StoryBoard {
    get {return _storage._boardInfo ?? Rankquantity_Voyager_Api_StoryBoard()}
    set {_uniqueStorage()._boardInfo = newValue}
  }
  /// Returns true if `boardInfo` has been explicitly set.
  public var hasBoardInfo: Bool {return _storage._boardInfo != nil}
  /// Clears the value of `boardInfo`. Subsequent reads from it will return its default value.
  public mutating func clearBoardInfo() {_uniqueStorage()._boardInfo = nil}

  public var content: String {
    get {return _storage._content}
    set {_uniqueStorage()._content = newValue}
  }

  public var ctime: Int64 {
    get {return _storage._ctime}
    set {_uniqueStorage()._ctime = newValue}
  }

  public var mtime: Int64 {
    get {return _storage._mtime}
    set {_uniqueStorage()._mtime = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Rankquantity_Voyager_Api_LoginRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var account: String = String()

  public var password: String = String()

  public var loginType: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_LoginResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var msg: String = String()

  public var data: Rankquantity_Voyager_Api_LoginResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_LoginResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var userID: Int64 = 0

    public var token: String = String()

    public var timestamp: Int64 = 0

    public var expireAt: Int64 = 0

    public var status: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_LoginResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_LogoutRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: String = String()

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_LogoutResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var msg: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_RefreshTokenRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_RefreshTokenResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: String = String()

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_RegisterRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var account: String = String()

  public var password: String = String()

  public var name: String = String()

  public var email: String = String()

  public var phone: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_RegisterResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var msg: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_ConfirmRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_ConfirmResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Int32 = 0

  public var timestamp: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_ResetPasswordRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var account: String = String()

  public var oldPwd: String = String()

  public var newPwd: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_ResetPasswordResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var account: String = String()

  public var status: Int64 = 0

  public var timestamp: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// user ,group .project.item
public struct Rankquantity_Voyager_Api_UserInfoRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var account: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UserInfoResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var msg: String = String()

  public var data: Rankquantity_Voyager_Api_UserInfoResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_UserInfoResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var info: Rankquantity_Voyager_Api_UserInfo {
      get {return _info ?? Rankquantity_Voyager_Api_UserInfo()}
      set {_info = newValue}
    }
    /// Returns true if `info` has been explicitly set.
    public var hasInfo: Bool {return self._info != nil}
    /// Clears the value of `info`. Subsequent reads from it will return its default value.
    public mutating func clearInfo() {self._info = nil}

    public var profile: Rankquantity_Voyager_Api_UserProfileInfo {
      get {return _profile ?? Rankquantity_Voyager_Api_UserProfileInfo()}
      set {_profile = newValue}
    }
    /// Returns true if `profile` has been explicitly set.
    public var hasProfile: Bool {return self._profile != nil}
    /// Clears the value of `profile`. Subsequent reads from it will return its default value.
    public mutating func clearProfile() {self._profile = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _info: Rankquantity_Voyager_Api_UserInfo? = nil
    fileprivate var _profile: Rankquantity_Voyager_Api_UserProfileInfo? = nil
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_UserInfoResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_UpdateUserAvatorRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var avatar: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UpdateUserAvatorResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var msg: String = String()

  public var data: Rankquantity_Voyager_Api_UpdateUserAvatorResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_UpdateUserAvatorResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var info: Rankquantity_Voyager_Api_UserInfo {
      get {return _info ?? Rankquantity_Voyager_Api_UserInfo()}
      set {_info = newValue}
    }
    /// Returns true if `info` has been explicitly set.
    public var hasInfo: Bool {return self._info != nil}
    /// Clears the value of `info`. Subsequent reads from it will return its default value.
    public mutating func clearInfo() {self._info = nil}

    public var status: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _info: Rankquantity_Voyager_Api_UserInfo? = nil
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_UpdateUserAvatorResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_UserWatchingRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var timeStamp: Int64 = 0

  public var offset: Int32 = 0

  public var pageSize: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UserWatchingResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var msg: String = String()

  public var data: Rankquantity_Voyager_Api_UserWatchingResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_UserWatchingResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var haveMore: Bool = false

    public var total: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_UserWatchingResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_UserGroupRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var gtype: Rankquantity_Voyager_Api_GroupType = .protect

  public var offset: Int32 = 0

  public var pageSize: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UserGroupResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var msg: String = String()

  public var data: Rankquantity_Voyager_Api_UserGroupResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_UserGroupResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var list: [Rankquantity_Voyager_Api_GroupInfo] = []

    public var offset: Int32 = 0

    public var pageSize: Int32 = 0

    public var total: Int32 = 0

    public var haveMore: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_UserGroupResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_UserFollowingGroupRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var offset: Int32 = 0

  public var pageSize: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UserFollowingGroupResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var msg: String = String()

  public var data: Rankquantity_Voyager_Api_UserFollowingGroupResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_UserFollowingGroupResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var userID: Int64 = 0

    public var list: [Rankquantity_Voyager_Api_GroupInfo] = []

    public var offset: Int64 = 0

    public var pageSize: Int64 = 0

    public var total: Int32 = 0

    public var haveMore: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_UserFollowingGroupResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_UserUpdateRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var nickname: String = String()

  public var avatar: String = String()

  public var desc: String = String()

  public var data: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UserUpdateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var data: Rankquantity_Voyager_Api_UserUpdateResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_UserUpdateResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_UserUpdateResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_FetchActivesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var groupID: Int64 = 0

  public var storyID: Int64 = 0

  public var boardID: Int64 = 0

  public var atype: Rankquantity_Voyager_Api_ActiveFlowType = .allFlowType

  public var timestamp: Int64 = 0

  public var offset: Int64 = 0

  public var pageSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_FetchActivesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var msg: String = String()

  public var data: Rankquantity_Voyager_Api_FetchActivesResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_FetchActivesResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var list: [Rankquantity_Voyager_Api_ActiveInfo] = []

    public var timestamp: Int64 = 0

    public var offset: Int64 = 0

    public var pageSize: Int64 = 0

    public var haveMore: Bool = false

    public var total: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_FetchActivesResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_SearchUserRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var groupID: Int64 = 0

  public var isFuzzy: Bool = false

  public var offset: Int64 = 0

  public var pageSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_SearchUserResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var msg: String = String()

  public var data: Rankquantity_Voyager_Api_SearchUserResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_SearchUserResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var list: [Rankquantity_Voyager_Api_UserInfo] = []

    public var offset: Int64 = 0

    public var pageSize: Int64 = 0

    public var total: Int32 = 0

    public var haveMore: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_SearchUserResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_UserInitRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var deafaultGroup: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UserInitResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var msg: String = String()

  public var data: Rankquantity_Voyager_Api_UserInitResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_UserInitResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var userID: Int64 = 0

    public var list: [Rankquantity_Voyager_Api_GroupInfo] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_UserInitResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_GetGroupItemsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var groupID: Int64 = 0

  public var userID: Int64 = 0

  public var offset: Int64 = 0

  public var pageSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetGroupItemsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var msg: String = String()

  public var data: Rankquantity_Voyager_Api_GetGroupItemsResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_GetGroupItemsResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var list: [Rankquantity_Voyager_Api_ItemInfo] = []

    public var groupID: Int64 = 0

    public var userID: Int64 = 0

    public var offset: Int64 = 0

    public var pageSize: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_GetGroupItemsResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_GetUserItemsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var offset: Int64 = 0

  public var pageSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetUserItemsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var msg: String = String()

  public var data: Rankquantity_Voyager_Api_GetUserItemsResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_GetUserItemsResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var list: [Rankquantity_Voyager_Api_ItemInfo] = []

    public var userID: Int64 = 0

    public var offset: Int64 = 0

    public var pageSize: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_GetUserItemsResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_GetItemRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var groupID: Int64 = 0

  public var projectID: Int64 = 0

  public var itemID: Int64 = 0

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetItemResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var msg: String = String()

  public var data: Rankquantity_Voyager_Api_GetItemResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_GetItemResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var info: Rankquantity_Voyager_Api_ItemInfo {
      get {return _info ?? Rankquantity_Voyager_Api_ItemInfo()}
      set {_info = newValue}
    }
    /// Returns true if `info` has been explicitly set.
    public var hasInfo: Bool {return self._info != nil}
    /// Clears the value of `info`. Subsequent reads from it will return its default value.
    public mutating func clearInfo() {self._info = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _info: Rankquantity_Voyager_Api_ItemInfo? = nil
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_GetItemResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_CreateItemRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var groupID: Int64 = 0

  public var projectID: Int64 = 0

  public var name: String = String()

  public var atype: Rankquantity_Voyager_Api_ActiveType = .noneActive

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_CreateItemResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var data: Rankquantity_Voyager_Api_CreateItemResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_CreateItemResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var info: Rankquantity_Voyager_Api_ItemInfo {
      get {return _info ?? Rankquantity_Voyager_Api_ItemInfo()}
      set {_info = newValue}
    }
    /// Returns true if `info` has been explicitly set.
    public var hasInfo: Bool {return self._info != nil}
    /// Clears the value of `info`. Subsequent reads from it will return its default value.
    public mutating func clearInfo() {self._info = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _info: Rankquantity_Voyager_Api_ItemInfo? = nil
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_CreateItemResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_UpdateItemRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var groupID: Int64 = 0

  public var projectID: Int64 = 0

  public var itemID: Int64 = 0

  public var info: Rankquantity_Voyager_Api_ItemInfo {
    get {return _info ?? Rankquantity_Voyager_Api_ItemInfo()}
    set {_info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  public var hasInfo: Bool {return self._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  public mutating func clearInfo() {self._info = nil}

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _info: Rankquantity_Voyager_Api_ItemInfo? = nil
}

public struct Rankquantity_Voyager_Api_UpdateItemResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var data: Rankquantity_Voyager_Api_UpdateItemResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_UpdateItemResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var info: Rankquantity_Voyager_Api_ItemInfo {
      get {return _info ?? Rankquantity_Voyager_Api_ItemInfo()}
      set {_info = newValue}
    }
    /// Returns true if `info` has been explicitly set.
    public var hasInfo: Bool {return self._info != nil}
    /// Clears the value of `info`. Subsequent reads from it will return its default value.
    public mutating func clearInfo() {self._info = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _info: Rankquantity_Voyager_Api_ItemInfo? = nil
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_UpdateItemResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_DeleteItemRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var groupID: Int64 = 0

  public var projectID: Int64 = 0

  public var itemID: Int64 = 0

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_DeleteItemResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var data: Rankquantity_Voyager_Api_DeleteItemResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_DeleteItemResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_DeleteItemResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_LikeItemRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var groupID: Int64 = 0

  public var projectID: Int64 = 0

  public var itemID: Int64 = 0

  public var userID: Int64 = 0

  public var islike: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_LikeItemResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var data: Rankquantity_Voyager_Api_LikeItemResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_LikeItemResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_LikeItemResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_CreateGroupRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var name: String = String()

  public var description_p: String = String()

  public var avatar: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_CreateGroupResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var data: Rankquantity_Voyager_Api_CreateGroupResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_CreateGroupResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var info: Rankquantity_Voyager_Api_GroupInfo {
      get {return _info ?? Rankquantity_Voyager_Api_GroupInfo()}
      set {_info = newValue}
    }
    /// Returns true if `info` has been explicitly set.
    public var hasInfo: Bool {return self._info != nil}
    /// Clears the value of `info`. Subsequent reads from it will return its default value.
    public mutating func clearInfo() {self._info = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _info: Rankquantity_Voyager_Api_GroupInfo? = nil
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_CreateGroupResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_GetGroupRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var groupID: Int64 = 0

  public var userID: Int64 = 0

  public var name: String = String()

  public var withProfile: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetGroupResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var data: Rankquantity_Voyager_Api_GetGroupResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_GetGroupResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var info: Rankquantity_Voyager_Api_GroupInfo {
      get {return _info ?? Rankquantity_Voyager_Api_GroupInfo()}
      set {_info = newValue}
    }
    /// Returns true if `info` has been explicitly set.
    public var hasInfo: Bool {return self._info != nil}
    /// Clears the value of `info`. Subsequent reads from it will return its default value.
    public mutating func clearInfo() {self._info = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _info: Rankquantity_Voyager_Api_GroupInfo? = nil
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_GetGroupResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_GetGroupActivesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var groupID: Int64 = 0

  public var atype: Rankquantity_Voyager_Api_ActiveType = .noneActive

  public var offset: Int64 = 0

  public var pageSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetGroupActivesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var data: Rankquantity_Voyager_Api_GetGroupActivesResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_GetGroupActivesResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var list: [Rankquantity_Voyager_Api_ActiveInfo] = []

    public var offset: Int64 = 0

    public var pageSize: Int64 = 0

    public var haveMore: Bool = false

    public var total: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_GetGroupActivesResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_UpdateGroupInfoRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var groupID: Int64 = 0

  public var info: Rankquantity_Voyager_Api_GroupInfo {
    get {return _info ?? Rankquantity_Voyager_Api_GroupInfo()}
    set {_info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  public var hasInfo: Bool {return self._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  public mutating func clearInfo() {self._info = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _info: Rankquantity_Voyager_Api_GroupInfo? = nil
}

public struct Rankquantity_Voyager_Api_UpdateGroupInfoResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var data: Rankquantity_Voyager_Api_UpdateGroupInfoResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_UpdateGroupInfoResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var info: Rankquantity_Voyager_Api_GroupInfo {
      get {return _info ?? Rankquantity_Voyager_Api_GroupInfo()}
      set {_info = newValue}
    }
    /// Returns true if `info` has been explicitly set.
    public var hasInfo: Bool {return self._info != nil}
    /// Clears the value of `info`. Subsequent reads from it will return its default value.
    public mutating func clearInfo() {self._info = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _info: Rankquantity_Voyager_Api_GroupInfo? = nil
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_UpdateGroupInfoResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_DeleteGroupRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var groupID: Int64 = 0

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_DeleteGroupResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var data: Rankquantity_Voyager_Api_DeleteGroupResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_DeleteGroupResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_DeleteGroupResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_FetchGroupMembersRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var groupID: Int64 = 0

  public var offset: Int64 = 0

  public var pageSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_FetchGroupMembersResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var data: Rankquantity_Voyager_Api_FetchGroupMembersResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_FetchGroupMembersResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var list: [Rankquantity_Voyager_Api_UserInfo] = []

    public var offset: Int64 = 0

    public var total: Int64 = 0

    public var haveMore: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_FetchGroupMembersResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_SearchGroupRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var userID: Int64 = 0

  public var offset: Int64 = 0

  public var pageSize: Int64 = 0

  public var scope: Rankquantity_Voyager_Api_ScopeType = .protectScope

  public var storyID: Int64 = 0

  public var groupID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_SearchGroupResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var data: Rankquantity_Voyager_Api_SearchGroupResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_SearchGroupResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var list: [Rankquantity_Voyager_Api_GroupInfo] = []

    public var offset: Int64 = 0

    public var pageSize: Int64 = 0

    public var haveMore: Bool = false

    public var total: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_SearchGroupResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_JoinGroupRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var groupID: Int64 = 0

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_JoinGroupResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var data: Rankquantity_Voyager_Api_JoinGroupResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_JoinGroupResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_JoinGroupResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_LeaveGroupRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var groupID: Int64 = 0

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_LeaveGroupResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var data: Rankquantity_Voyager_Api_LeaveGroupResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_LeaveGroupResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_LeaveGroupResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_DisscussParams: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_CreateDisscussReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_CreateDisscusResp: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var data: Rankquantity_Voyager_Api_CreateDisscusResp.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_CreateDisscusResp.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_CreateDisscusResp.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_GetDisscusReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetDisscusResp: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var data: Rankquantity_Voyager_Api_GetDisscusResp.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_GetDisscusResp.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_GetDisscusResp.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_VersionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_VersionResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var data: Rankquantity_Voyager_Api_VersionResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_VersionResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var version: String = String()

    public var buildTime: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_VersionResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_AboutRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_AboutResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var content: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_ExploreRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_ExploreResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var data: Rankquantity_Voyager_Api_ExploreResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_ExploreResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_ExploreResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_GetProjectMembersRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var projectID: Int32 = 0

  public var userID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetProjectMembersResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var data: Rankquantity_Voyager_Api_GetProjectMembersResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_GetProjectMembersResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var list: [Rankquantity_Voyager_Api_UserInfo] = []

    public var total: Int32 = 0

    public var role: Dictionary<String,Int64> = [:]

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_GetProjectMembersResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_GetProjectWatcherRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var projectID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetProjectWatcherResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var data: Rankquantity_Voyager_Api_GetProjectWatcherResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_GetProjectWatcherResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var list: [Rankquantity_Voyager_Api_UserInfo] = []

    public var total: Int32 = 0

    public var timestamp: Dictionary<Int64,Int64> = [:]

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_GetProjectWatcherResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_UploadImageRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var imageData: Data = Data()

  public var filename: String = String()

  public var contentType: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UploadImageResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var data: Rankquantity_Voyager_Api_UploadImageResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_UploadImageResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var fileID: String = String()

    public var url: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_UploadImageResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_GetStoryContributorsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var storyID: Int64 = 0

  public var userID: Int64 = 0

  public var offset: Int64 = 0

  public var pageSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_StoryContributor: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var username: String = String()

  public var avatar: String = String()

  public var viplevel: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetStoryContributorsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var data: Rankquantity_Voyager_Api_GetStoryContributorsResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_GetStoryContributorsResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var list: [Rankquantity_Voyager_Api_StoryContributor] = []

    public var total: Int64 = 0

    public var haveMore: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_GetStoryContributorsResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_GetGroupProfileRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var groupID: Int64 = 0

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetGroupProfileResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var data: Rankquantity_Voyager_Api_GetGroupProfileResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_GetGroupProfileResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var info: Rankquantity_Voyager_Api_GroupProfileInfo {
      get {return _info ?? Rankquantity_Voyager_Api_GroupProfileInfo()}
      set {_info = newValue}
    }
    /// Returns true if `info` has been explicitly set.
    public var hasInfo: Bool {return self._info != nil}
    /// Clears the value of `info`. Subsequent reads from it will return its default value.
    public mutating func clearInfo() {self._info = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _info: Rankquantity_Voyager_Api_GroupProfileInfo? = nil
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_GetGroupProfileResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_UpdateGroupProfileRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var groupID: Int64 = 0

  public var info: Rankquantity_Voyager_Api_GroupProfileInfo {
    get {return _info ?? Rankquantity_Voyager_Api_GroupProfileInfo()}
    set {_info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  public var hasInfo: Bool {return self._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  public mutating func clearInfo() {self._info = nil}

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _info: Rankquantity_Voyager_Api_GroupProfileInfo? = nil
}

public struct Rankquantity_Voyager_Api_UpdateGroupProfileResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetStoryRolePosterListRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var storyID: Int64 = 0

  public var roleID: Int64 = 0

  public var userID: Int64 = 0

  public var offset: Int64 = 0

  public var pageSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_RolePosterDetail: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var storyID: Int64 {
    get {return _storage._storyID}
    set {_uniqueStorage()._storyID = newValue}
  }

  public var roleID: Int64 {
    get {return _storage._roleID}
    set {_uniqueStorage()._roleID = newValue}
  }

  public var posterURL: String {
    get {return _storage._posterURL}
    set {_uniqueStorage()._posterURL = newValue}
  }

  public var prompt: String {
    get {return _storage._prompt}
    set {_uniqueStorage()._prompt = newValue}
  }

  public var likeCount: Int64 {
    get {return _storage._likeCount}
    set {_uniqueStorage()._likeCount = newValue}
  }

  public var isLikedByUser: Bool {
    get {return _storage._isLikedByUser}
    set {_uniqueStorage()._isLikedByUser = newValue}
  }

  public var creator: Rankquantity_Voyager_Api_UserInfo {
    get {return _storage._creator ?? Rankquantity_Voyager_Api_UserInfo()}
    set {_uniqueStorage()._creator = newValue}
  }
  /// Returns true if `creator` has been explicitly set.
  public var hasCreator: Bool {return _storage._creator != nil}
  /// Clears the value of `creator`. Subsequent reads from it will return its default value.
  public mutating func clearCreator() {_uniqueStorage()._creator = nil}

  public var createdAt: Int64 {
    get {return _storage._createdAt}
    set {_uniqueStorage()._createdAt = newValue}
  }

  public var updatedAt: Int64 {
    get {return _storage._updatedAt}
    set {_uniqueStorage()._updatedAt = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Rankquantity_Voyager_Api_GetStoryRolePosterListResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var posters: [Rankquantity_Voyager_Api_RolePosterDetail] = []

  public var total: Int64 = 0

  public var haveMore: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_LikeStoryRolePosterRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var storyID: Int64 = 0

  public var roleID: Int64 = 0

  public var userID: Int64 = 0

  public var posterID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_LikeStoryRolePosterResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var currentLikeCount: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UnLikeStoryRolePosterRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var storyID: Int64 = 0

  public var roleID: Int64 = 0

  public var userID: Int64 = 0

  public var posterID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UnLikeStoryRolePosterResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var currentLikeCount: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_FetchUserGenTaskStatusRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var taskID: String = String()

  public var timestamp: Int64 = 0

  public var pageNum: Int64 = 0

  public var pageSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_StoryGentaskDetail: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var storyID: Int64 = 0

  public var boardID: Int64 = 0

  public var storyboardDesc: String = String()

  public var senceID: Int64 = 0

  public var senceDesc: String = String()

  public var prompt: String = String()

  public var taskType: Int64 = 0

  public var taskStage: Int64 = 0

  public var startImageURL: String = String()

  public var endImageURL: String = String()

  public var videoURL: String = String()

  public var regImageURL: String = String()

  public var style: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UserGenTaskStatus: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var taskID: String {
    get {return _storage._taskID}
    set {_uniqueStorage()._taskID = newValue}
  }

  public var userID: Int64 {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  public var status: String {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  public var detail: Rankquantity_Voyager_Api_StoryGentaskDetail {
    get {return _storage._detail ?? Rankquantity_Voyager_Api_StoryGentaskDetail()}
    set {_uniqueStorage()._detail = newValue}
  }
  /// Returns true if `detail` has been explicitly set.
  public var hasDetail: Bool {return _storage._detail != nil}
  /// Clears the value of `detail`. Subsequent reads from it will return its default value.
  public mutating func clearDetail() {_uniqueStorage()._detail = nil}

  public var createTime: Int64 {
    get {return _storage._createTime}
    set {_uniqueStorage()._createTime = newValue}
  }

  public var updateTime: Int64 {
    get {return _storage._updateTime}
    set {_uniqueStorage()._updateTime = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Rankquantity_Voyager_Api_FetchUserGenTaskStatusResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var tasks: [Rankquantity_Voyager_Api_UserGenTaskStatus] = []

  public var total: Int64 = 0

  public var haveMore: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GenerateRoleAvatarRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var roleID: Int64 = 0

  public var userID: Int64 = 0

  public var refAvatarURL: String = String()

  public var description_p: String = String()

  public var style: String = String()

  public var imageRatios: Rankquantity_Voyager_Api_ImageRatios = .ratio11

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GenerateRoleAvatarResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var avatarURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GenerateStorySceneVideoRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var storyID: Int64 = 0

  public var boardID: Int64 = 0

  public var senceID: Int64 = 0

  public var userID: Int64 = 0

  public var tokenSource: Rankquantity_Voyager_Api_TokenSource = .userSelf

  public var prompt: String = String()

  public var negativePrompt: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GenerateStorySceneVideoTaskDetail: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var taskID: String = String()

  public var taskStatus: Rankquantity_Voyager_Api_StoryGenStatus = .unspecified

  public var videoURL: String = String()

  public var videoThumbnailURL: String = String()

  public var duration: Int64 = 0

  public var resolution: String = String()

  public var videoFormat: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GenerateStorySceneVideoResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var detail: Rankquantity_Voyager_Api_GenerateStorySceneVideoTaskDetail {
    get {return _detail ?? Rankquantity_Voyager_Api_GenerateStorySceneVideoTaskDetail()}
    set {_detail = newValue}
  }
  /// Returns true if `detail` has been explicitly set.
  public var hasDetail: Bool {return self._detail != nil}
  /// Clears the value of `detail`. Subsequent reads from it will return its default value.
  public mutating func clearDetail() {self._detail = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _detail: Rankquantity_Voyager_Api_GenerateStorySceneVideoTaskDetail? = nil
}

public struct Rankquantity_Voyager_Api_GenerateStoryRoleVideoRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var storyID: Int64 = 0

  public var roleID: Int64 = 0

  public var userID: Int64 = 0

  public var posterID: Int64 = 0

  public var refBackgroundURL: String = String()

  public var refAvatarURL: String = String()

  public var textPrompt: String = String()

  public var imageRatios: Rankquantity_Voyager_Api_ImageRatios = .ratio11

  public var style: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GenerateStoryRoleVideoTaskDetail: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var taskID: String = String()

  public var taskStatus: Rankquantity_Voyager_Api_StoryGenStatus = .unspecified

  public var videoURL: String = String()

  public var videoThumbnailURL: String = String()

  public var duration: Int64 = 0

  public var resolution: String = String()

  public var videoFormat: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GenerateStoryRoleVideoResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var detail: Rankquantity_Voyager_Api_GenerateStoryRoleVideoTaskDetail {
    get {return _detail ?? Rankquantity_Voyager_Api_GenerateStoryRoleVideoTaskDetail()}
    set {_detail = newValue}
  }
  /// Returns true if `detail` has been explicitly set.
  public var hasDetail: Bool {return self._detail != nil}
  /// Clears the value of `detail`. Subsequent reads from it will return its default value.
  public mutating func clearDetail() {self._detail = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _detail: Rankquantity_Voyager_Api_GenerateStoryRoleVideoTaskDetail? = nil
}

public struct Rankquantity_Voyager_Api_GetStoryParticipantsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var storyID: Int64 = 0

  public var offset: Int64 = 0

  public var pageSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetStoryParticipantsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var participants: [Rankquantity_Voyager_Api_UserInfo] = []

  public var total: Int64 = 0

  public var haveMore: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UpdateStoryAvatarRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var storyID: Int64 = 0

  public var userID: Int64 = 0

  public var avatarURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UpdateStoryAvatarResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UpdateStoryCoverRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var storyID: Int64 = 0

  public var userID: Int64 = 0

  public var coverURL: String = String()

  public var useAiCover: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UpdateStoryCoverResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetStoryImageStyleRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var storyID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_StoryStyleDesc: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 风格ID
  public var id: Int64 = 0

  /// 风格名称
  public var style: String = String()

  /// 风格描述
  public var description_p: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetStoryImageStyleResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var style: [Rankquantity_Voyager_Api_StoryStyleDesc] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UpdateStoryImageStyleRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var storyID: Int64 = 0

  /// 风格ID
  public var styleID: Int64 = 0

  /// 风格名称
  public var style: String = String()

  /// 用户ID
  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UpdateStoryImageStyleResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UpdateStorySenceMaxNumberRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var storyID: Int64 = 0

  /// 最大场景数
  public var maxNumber: Int64 = 0

  /// 用户ID
  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UpdateStorySenceMaxNumberResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UpdateStoryRolePromptRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var storyID: Int64 = 0

  public var roleID: Int64 = 0

  public var userID: Int64 = 0

  public var prompt: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UpdateStoryRolePromptResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UpdateStoryRoleDescriptionDetailRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var storyID: Int64 = 0

  public var roleID: Int64 = 0

  public var userID: Int64 = 0

  public var characterDetail: Rankquantity_Voyager_Api_CharacterDetail {
    get {return _characterDetail ?? Rankquantity_Voyager_Api_CharacterDetail()}
    set {_characterDetail = newValue}
  }
  /// Returns true if `characterDetail` has been explicitly set.
  public var hasCharacterDetail: Bool {return self._characterDetail != nil}
  /// Clears the value of `characterDetail`. Subsequent reads from it will return its default value.
  public mutating func clearCharacterDetail() {self._characterDetail = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _characterDetail: Rankquantity_Voyager_Api_CharacterDetail? = nil
}

public struct Rankquantity_Voyager_Api_UpdateStoryRoleDescriptionDetailResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GenerateStoryRoleParams: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var originImageURL: String = String()

  public var additionalImageUrls: [String] = []

  public var textPrompt: String = String()

  public var negativePrompt: String = String()

  public var style: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GenerateStoryRolePosterRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var storyID: Int64 = 0

  public var roleID: Int64 = 0

  public var userID: Int64 = 0

  public var params: Rankquantity_Voyager_Api_GenerateStoryRoleParams {
    get {return _params ?? Rankquantity_Voyager_Api_GenerateStoryRoleParams()}
    set {_params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  public var hasParams: Bool {return self._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  public mutating func clearParams() {self._params = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _params: Rankquantity_Voyager_Api_GenerateStoryRoleParams? = nil
}

public struct Rankquantity_Voyager_Api_GenerateStoryRolePosterResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var imageURL: String = String()

  public var posterID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UpdateStoryRolePosterRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var storyID: Int64 = 0

  public var roleID: Int64 = 0

  public var userID: Int64 = 0

  public var posterID: Int64 = 0

  public var imageURL: String = String()

  public var isPublic: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UpdateStoryRolePosterResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var posterID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetFollowListRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var offset: Int64 = 0

  public var pageSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetFollowListResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var followers: [Rankquantity_Voyager_Api_UserInfo] = []

  public var total: Int64 = 0

  public var haveMore: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetFollowerListRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var offset: Int64 = 0

  public var pageSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetFollowerListResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var followers: [Rankquantity_Voyager_Api_UserInfo] = []

  public var total: Int64 = 0

  public var haveMore: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_FollowUserRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var followerID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_FollowUserResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UnfollowUserRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var followerID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UnfollowUserResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_TrendingStoryRoleRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var start: Int64 = 0

  public var end: Int64 = 0

  public var pageSize: Int64 = 0

  public var pageNumber: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_TrendingStoryRoleResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var data: Rankquantity_Voyager_Api_TrendingStoryRoleResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_TrendingStoryRoleResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var list: [Rankquantity_Voyager_Api_StoryRole] = []

    public var pageSize: Int64 = 0

    public var pageNumber: Int64 = 0

    public var total: Int64 = 0

    public var haveMore: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_TrendingStoryRoleResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_TrendingStoryRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var start: Int64 = 0

  public var end: Int64 = 0

  public var pageSize: Int64 = 0

  public var pageNumber: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_TrendingStoryResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var data: Rankquantity_Voyager_Api_TrendingStoryResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_TrendingStoryResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var list: [Rankquantity_Voyager_Api_Story] = []

    public var pageSize: Int64 = 0

    public var pageNumber: Int64 = 0

    public var total: Int64 = 0

    public var haveMore: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_TrendingStoryResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_GetStoryRoleListRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var storyID: Int64 = 0

  public var userID: Int64 = 0

  public var boardID: Int64 = 0

  public var searchKey: String = String()

  public var offset: Int64 = 0

  public var pageSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetStoryRoleListResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var roles: [Rankquantity_Voyager_Api_StoryRole] = []

  public var total: Int64 = 0

  public var haveMore: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_ArchiveStoryRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var storyID: Int64 = 0

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_ArchiveStoryResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_CreateStoryCommentRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var storyID: Int64 = 0

  public var userID: Int64 = 0

  public var content: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_CreateStoryCommentResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var message: String {
    get {return _storage._message}
    set {_uniqueStorage()._message = newValue}
  }

  public var comment: Rankquantity_Voyager_Api_CommentInfo {
    get {return _storage._comment ?? Rankquantity_Voyager_Api_CommentInfo()}
    set {_uniqueStorage()._comment = newValue}
  }
  /// Returns true if `comment` has been explicitly set.
  public var hasComment: Bool {return _storage._comment != nil}
  /// Clears the value of `comment`. Subsequent reads from it will return its default value.
  public mutating func clearComment() {_uniqueStorage()._comment = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Rankquantity_Voyager_Api_GetStoryCommentsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var storyID: Int64 = 0

  public var userID: Int64 = 0

  public var offset: Int64 = 0

  public var pageSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_StoryComment: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var commentID: Int64 {
    get {return _storage._commentID}
    set {_uniqueStorage()._commentID = newValue}
  }

  public var storyID: Int64 {
    get {return _storage._storyID}
    set {_uniqueStorage()._storyID = newValue}
  }

  public var boardID: Int64 {
    get {return _storage._boardID}
    set {_uniqueStorage()._boardID = newValue}
  }

  public var roleID: Int64 {
    get {return _storage._roleID}
    set {_uniqueStorage()._roleID = newValue}
  }

  public var prevID: Int64 {
    get {return _storage._prevID}
    set {_uniqueStorage()._prevID = newValue}
  }

  public var rootCommentID: Int64 {
    get {return _storage._rootCommentID}
    set {_uniqueStorage()._rootCommentID = newValue}
  }

  public var userID: Int64 {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  public var content: String {
    get {return _storage._content}
    set {_uniqueStorage()._content = newValue}
  }

  public var createdAt: Int64 {
    get {return _storage._createdAt}
    set {_uniqueStorage()._createdAt = newValue}
  }

  public var updatedAt: Int64 {
    get {return _storage._updatedAt}
    set {_uniqueStorage()._updatedAt = newValue}
  }

  public var likeCount: Int64 {
    get {return _storage._likeCount}
    set {_uniqueStorage()._likeCount = newValue}
  }

  public var replyCount: Int64 {
    get {return _storage._replyCount}
    set {_uniqueStorage()._replyCount = newValue}
  }

  public var isLiked: Int64 {
    get {return _storage._isLiked}
    set {_uniqueStorage()._isLiked = newValue}
  }

  public var creator: Rankquantity_Voyager_Api_UserInfo {
    get {return _storage._creator ?? Rankquantity_Voyager_Api_UserInfo()}
    set {_uniqueStorage()._creator = newValue}
  }
  /// Returns true if `creator` has been explicitly set.
  public var hasCreator: Bool {return _storage._creator != nil}
  /// Clears the value of `creator`. Subsequent reads from it will return its default value.
  public mutating func clearCreator() {_uniqueStorage()._creator = nil}

  public var createdAtTimestamp: Int64 {
    get {return _storage._createdAtTimestamp}
    set {_uniqueStorage()._createdAtTimestamp = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Rankquantity_Voyager_Api_GetStoryCommentsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var comments: [Rankquantity_Voyager_Api_StoryComment] = []

  public var total: Int64 = 0

  public var offset: Int64 = 0

  public var pageSize: Int64 = 0

  public var haveMore: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_DeleteStoryCommentRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var commentID: Int64 = 0

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_DeleteStoryCommentResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetStoryCommentRepliesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var commentID: Int64 = 0

  public var userID: Int64 = 0

  public var offset: Int64 = 0

  public var pageSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetStoryCommentRepliesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var replies: [Rankquantity_Voyager_Api_StoryComment] = []

  public var total: Int64 = 0

  public var offset: Int64 = 0

  public var pageSize: Int64 = 0

  public var haveMore: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_CreateStoryCommentReplyRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var commentID: Int64 = 0

  public var userID: Int64 = 0

  public var content: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_CreateStoryCommentReplyResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var message: String {
    get {return _storage._message}
    set {_uniqueStorage()._message = newValue}
  }

  public var comment: Rankquantity_Voyager_Api_CommentInfo {
    get {return _storage._comment ?? Rankquantity_Voyager_Api_CommentInfo()}
    set {_uniqueStorage()._comment = newValue}
  }
  /// Returns true if `comment` has been explicitly set.
  public var hasComment: Bool {return _storage._comment != nil}
  /// Clears the value of `comment`. Subsequent reads from it will return its default value.
  public mutating func clearComment() {_uniqueStorage()._comment = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Rankquantity_Voyager_Api_DeleteStoryCommentReplyRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var replyID: Int64 = 0

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_DeleteStoryCommentReplyResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetStoryBoardCommentsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var boardID: Int64 = 0

  public var userID: Int64 = 0

  public var offset: Int64 = 0

  public var pageSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetStoryBoardCommentsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var comments: [Rankquantity_Voyager_Api_StoryComment] = []

  public var total: Int64 = 0

  public var offset: Int64 = 0

  public var pageSize: Int64 = 0

  public var haveMore: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_CreateStoryBoardCommentRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var boardID: Int64 = 0

  public var userID: Int64 = 0

  public var content: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_CreateStoryBoardCommentResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var message: String {
    get {return _storage._message}
    set {_uniqueStorage()._message = newValue}
  }

  public var comment: Rankquantity_Voyager_Api_CommentInfo {
    get {return _storage._comment ?? Rankquantity_Voyager_Api_CommentInfo()}
    set {_uniqueStorage()._comment = newValue}
  }
  /// Returns true if `comment` has been explicitly set.
  public var hasComment: Bool {return _storage._comment != nil}
  /// Clears the value of `comment`. Subsequent reads from it will return its default value.
  public mutating func clearComment() {_uniqueStorage()._comment = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Rankquantity_Voyager_Api_DeleteStoryBoardCommentRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var boardID: Int64 = 0

  public var commentID: Int64 = 0

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_DeleteStoryBoardCommentResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetStoryBoardCommentRepliesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var commentID: Int64 = 0

  public var userID: Int64 = 0

  public var offset: Int64 = 0

  public var pageSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetStoryBoardCommentRepliesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var replies: [Rankquantity_Voyager_Api_StoryComment] = []

  public var total: Int64 = 0

  public var offset: Int64 = 0

  public var pageSize: Int64 = 0

  public var haveMore: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_LikeCommentRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var commentID: Int64 = 0

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_LikeCommentResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_DislikeCommentRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var commentID: Int64 = 0

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_DislikeCommentResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UpdateRolePromptRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var roleID: Int64 = 0

  public var prompt: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UpdateRolePromptResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GenerateRolePromptRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var storyID: Int64 = 0

  public var userID: Int64 = 0

  public var roleID: Int64 = 0

  public var prompt: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GenerateRolePromptResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var prompt: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UpdateRoleDescriptionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var roleID: Int64 = 0

  public var description_p: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UpdateRoleDescriptionResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GenerateRoleDescriptionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var storyID: Int64 = 0

  public var userID: Int64 = 0

  public var roleID: Int64 = 0

  public var description_p: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GenerateRoleDescriptionResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var characterDetail: Rankquantity_Voyager_Api_CharacterDetail {
    get {return _characterDetail ?? Rankquantity_Voyager_Api_CharacterDetail()}
    set {_characterDetail = newValue}
  }
  /// Returns true if `characterDetail` has been explicitly set.
  public var hasCharacterDetail: Bool {return self._characterDetail != nil}
  /// Clears the value of `characterDetail`. Subsequent reads from it will return its default value.
  public mutating func clearCharacterDetail() {self._characterDetail = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _characterDetail: Rankquantity_Voyager_Api_CharacterDetail? = nil
}

public struct Rankquantity_Voyager_Api_GetUnPublishStoryboardRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var offset: Int64 = 0

  public var pageSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetUnPublishStoryboardResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var storyboardactives: [Rankquantity_Voyager_Api_StoryBoardActive] = []

  public var total: Int64 = 0

  public var offset: Int64 = 0

  public var pageSize: Int64 = 0

  public var haveMore: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetUserWatchRoleActiveStoryBoardsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var roleID: Int64 = 0

  public var offset: Int64 = 0

  public var pageSize: Int64 = 0

  public var filter: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetUserWatchRoleActiveStoryBoardsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var storyboards: [Rankquantity_Voyager_Api_StoryBoardActive] = []

  public var total: Int64 = 0

  public var offset: Int64 = 0

  public var pageSize: Int64 = 0

  public var haveMore: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetUserWatchStoryActiveStoryBoardsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var storyID: Int64 = 0

  public var offset: Int64 = 0

  public var pageSize: Int64 = 0

  public var filter: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetUserWatchStoryActiveStoryBoardsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var storyboards: [Rankquantity_Voyager_Api_StoryBoardActive] = []

  public var total: Int64 = 0

  public var offset: Int64 = 0

  public var pageSize: Int64 = 0

  public var haveMore: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_SaveStoryboardCraftRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var storyboardID: Int64 = 0

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_SaveStoryboardCraftResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_PublishStoryboardRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var storyboardID: Int64 = 0

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_PublishStoryboardResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_CancelStoryboardRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var storyboardID: Int64 = 0

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_CancelStoryboardResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_RenderStoryRoleContinuouslyRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var roleID: Int64 = 0

  public var userID: Int64 = 0

  public var storyID: Int64 = 0

  public var prompt: String = String()

  public var referenceImage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_RenderStoryRoleContinuouslyResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var detail: Rankquantity_Voyager_Api_RenderStoryRoleDetail {
    get {return _detail ?? Rankquantity_Voyager_Api_RenderStoryRoleDetail()}
    set {_detail = newValue}
  }
  /// Returns true if `detail` has been explicitly set.
  public var hasDetail: Bool {return self._detail != nil}
  /// Clears the value of `detail`. Subsequent reads from it will return its default value.
  public mutating func clearDetail() {self._detail = nil}

  public var haveMore: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _detail: Rankquantity_Voyager_Api_RenderStoryRoleDetail? = nil
}

public struct Rankquantity_Voyager_Api_GetNextStoryboardRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var storyboardID: Int64 = 0

  public var userID: Int64 = 0

  public var storyID: Int64 = 0

  public var isMultiBranch: Bool = false

  public var offset: Int64 = 0

  public var pageSize: Int64 = 0

  public var total: Int64 = 0

  public var orderBy: Rankquantity_Voyager_Api_MultiBranchOrderBy = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetNextStoryboardResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var storyboards: [Rankquantity_Voyager_Api_StoryBoardActive] = []

  public var isMultiBranch: Bool = false

  public var total: Int64 = 0

  public var offset: Int64 = 0

  public var pageSize: Int64 = 0

  public var haveMore: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetUserChatMessagesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var chatID: Int64 = 0

  public var roleID: Int64 = 0

  public var timestamp: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetUserChatMessagesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var messages: [Rankquantity_Voyager_Api_ChatMessage] = []

  public var timestamp: Int64 = 0

  public var total: Int64 = 0

  public var haveMore: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetUserChatWithRoleRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var roleID: Int64 = 0

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetUserChatWithRoleResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var messages: [Rankquantity_Voyager_Api_ChatMessage] = []

  public var chatContext: Rankquantity_Voyager_Api_ChatContext {
    get {return _chatContext ?? Rankquantity_Voyager_Api_ChatContext()}
    set {_chatContext = newValue}
  }
  /// Returns true if `chatContext` has been explicitly set.
  public var hasChatContext: Bool {return self._chatContext != nil}
  /// Clears the value of `chatContext`. Subsequent reads from it will return its default value.
  public mutating func clearChatContext() {self._chatContext = nil}

  public var total: Int64 = 0

  public var haveMore: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chatContext: Rankquantity_Voyager_Api_ChatContext? = nil
}

public struct Rankquantity_Voyager_Api_GetStoryRoleStoryboardsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var roleID: Int64 = 0

  public var userID: Int64 = 0

  public var storyID: Int64 = 0

  public var filter: String = String()

  public var offset: Int64 = 0

  public var pageSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetStoryRoleStoryboardsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var storyboardactives: [Rankquantity_Voyager_Api_StoryBoardActive] = []

  public var total: Int64 = 0

  public var offset: Int64 = 0

  public var pageSize: Int64 = 0

  public var haveMore: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetStoryRoleStoriesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var roleID: Int64 = 0

  public var userID: Int64 = 0

  public var filter: String = String()

  public var offset: Int64 = 0

  public var pageSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetStoryRoleStoriesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var stories: [Rankquantity_Voyager_Api_Story] = []

  public var total: Int64 = 0

  public var offset: Int64 = 0

  public var pageSize: Int64 = 0

  public var haveMore: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_CreateStoryRoleChatRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var roleID: Int64 = 0

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_ChatContext: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Int64 {
    get {return _storage._chatID}
    set {_uniqueStorage()._chatID = newValue}
  }

  public var roleID: Int64 {
    get {return _storage._roleID}
    set {_uniqueStorage()._roleID = newValue}
  }

  public var userID: Int64 {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  public var timestamp: Int64 {
    get {return _storage._timestamp}
    set {_uniqueStorage()._timestamp = newValue}
  }

  public var lastUpdateTime: Int64 {
    get {return _storage._lastUpdateTime}
    set {_uniqueStorage()._lastUpdateTime = newValue}
  }

  public var totalTokens: Int64 {
    get {return _storage._totalTokens}
    set {_uniqueStorage()._totalTokens = newValue}
  }

  public var totalMessages: Int64 {
    get {return _storage._totalMessages}
    set {_uniqueStorage()._totalMessages = newValue}
  }

  public var lastMessage: Rankquantity_Voyager_Api_ChatMessage {
    get {return _storage._lastMessage ?? Rankquantity_Voyager_Api_ChatMessage()}
    set {_uniqueStorage()._lastMessage = newValue}
  }
  /// Returns true if `lastMessage` has been explicitly set.
  public var hasLastMessage: Bool {return _storage._lastMessage != nil}
  /// Clears the value of `lastMessage`. Subsequent reads from it will return its default value.
  public mutating func clearLastMessage() {_uniqueStorage()._lastMessage = nil}

  public var user: Rankquantity_Voyager_Api_UserInfo {
    get {return _storage._user ?? Rankquantity_Voyager_Api_UserInfo()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  public var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  public mutating func clearUser() {_uniqueStorage()._user = nil}

  public var role: Rankquantity_Voyager_Api_StoryRole {
    get {return _storage._role ?? Rankquantity_Voyager_Api_StoryRole()}
    set {_uniqueStorage()._role = newValue}
  }
  /// Returns true if `role` has been explicitly set.
  public var hasRole: Bool {return _storage._role != nil}
  /// Clears the value of `role`. Subsequent reads from it will return its default value.
  public mutating func clearRole() {_uniqueStorage()._role = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Rankquantity_Voyager_Api_CreateStoryRoleChatResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var chatContext: Rankquantity_Voyager_Api_ChatContext {
    get {return _chatContext ?? Rankquantity_Voyager_Api_ChatContext()}
    set {_chatContext = newValue}
  }
  /// Returns true if `chatContext` has been explicitly set.
  public var hasChatContext: Bool {return self._chatContext != nil}
  /// Clears the value of `chatContext`. Subsequent reads from it will return its default value.
  public mutating func clearChatContext() {self._chatContext = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chatContext: Rankquantity_Voyager_Api_ChatContext? = nil
}

public struct Rankquantity_Voyager_Api_ChatWithStoryRoleRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var roleID: Int64 = 0

  public var userID: Int64 = 0

  public var messages: [Rankquantity_Voyager_Api_ChatMessage] = []

  public var total: Int64 = 0

  public var haveMore: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_ChatWithStoryRoleResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var replyMessages: [Rankquantity_Voyager_Api_ChatMessage] = []

  public var total: Int64 = 0

  public var haveMore: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UpdateStoryRoleDetailRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var roleID: Int64 = 0

  public var role: Rankquantity_Voyager_Api_StoryRole {
    get {return _role ?? Rankquantity_Voyager_Api_StoryRole()}
    set {_role = newValue}
  }
  /// Returns true if `role` has been explicitly set.
  public var hasRole: Bool {return self._role != nil}
  /// Clears the value of `role`. Subsequent reads from it will return its default value.
  public mutating func clearRole() {self._role = nil}

  public var userID: Int64 = 0

  public var needRegen: Bool = false

  public var backgroundImage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _role: Rankquantity_Voyager_Api_StoryRole? = nil
}

public struct Rankquantity_Voyager_Api_UpdateStoryRoleDetailResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UpdateStoryRoleAvatorRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var roleID: Int64 = 0

  public var avator: String = String()

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UpdateStoryRoleAvatorResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetUserWithRoleChatListRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var storyID: Int64 = 0

  public var offset: Int64 = 0

  public var pageSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetUserWithRoleChatListResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var chats: [Rankquantity_Voyager_Api_ChatContext] = []

  public var total: Int64 = 0

  public var offset: Int64 = 0

  public var pageSize: Int64 = 0

  public var haveMore: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetUserCreatedStoryboardsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var storyID: Int32 = 0

  public var stage: Int32 = 0

  public var offset: Int64 = 0

  public var pageSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetUserCreatedStoryboardsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var storyboards: [Rankquantity_Voyager_Api_StoryBoardActive] = []

  public var total: Int64 = 0

  public var haveMore: Bool = false

  public var offset: Int64 = 0

  public var pageSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetUserCreatedRolesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var storyID: Int32 = 0

  public var stage: Int32 = 0

  public var offset: Int64 = 0

  public var pageSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetUserCreatedRolesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var roles: [Rankquantity_Voyager_Api_StoryRole] = []

  public var total: Int64 = 0

  public var haveMore: Bool = false

  public var offset: Int64 = 0

  public var pageSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_LikeStoryRoleRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var roleID: Int64 = 0

  public var userID: Int64 = 0

  public var storyID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_LikeStoryRoleResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UnLikeStoryRoleRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var roleID: Int64 = 0

  public var userID: Int64 = 0

  public var storyID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UnLikeStoryRoleResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_FollowStoryRoleRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var roleID: Int64 = 0

  public var userID: Int64 = 0

  public var storyID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_FollowStoryRoleResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UnFollowStoryRoleRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var roleID: Int64 = 0

  public var userID: Int64 = 0

  public var storyID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UnFollowStoryRoleResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_SearchStoriesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var keyword: String = String()

  public var offset: Int64 = 0

  public var pageSize: Int64 = 0

  public var scope: Rankquantity_Voyager_Api_ScopeType = .protectScope

  public var groupID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_SearchStoriesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var stories: [Rankquantity_Voyager_Api_Story] = []

  public var total: Int64 = 0

  public var haveMore: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_SearchRolesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var keyword: String = String()

  public var offset: Int64 = 0

  public var pageSize: Int64 = 0

  public var scope: Rankquantity_Voyager_Api_ScopeType = .protectScope

  public var storyID: Int64 = 0

  public var groupID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_SearchRolesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var roles: [Rankquantity_Voyager_Api_StoryRole] = []

  public var total: Int64 = 0

  public var haveMore: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_RestoreStoryboardRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var storyboardID: Int64 = 0

  public var userID: Int64 = 0

  public var storyID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_RestoreStoryboardResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var store: Rankquantity_Voyager_Api_StoryboardStageStore {
    get {return _store ?? Rankquantity_Voyager_Api_StoryboardStageStore()}
    set {_store = newValue}
  }
  /// Returns true if `store` has been explicitly set.
  public var hasStore: Bool {return self._store != nil}
  /// Clears the value of `store`. Subsequent reads from it will return its default value.
  public mutating func clearStore() {self._store = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _store: Rankquantity_Voyager_Api_StoryboardStageStore? = nil
}

public struct Rankquantity_Voyager_Api_StoryboardStageStore: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var storyboard: Rankquantity_Voyager_Api_StoryBoard {
    get {return _storyboard ?? Rankquantity_Voyager_Api_StoryBoard()}
    set {_storyboard = newValue}
  }
  /// Returns true if `storyboard` has been explicitly set.
  public var hasStoryboard: Bool {return self._storyboard != nil}
  /// Clears the value of `storyboard`. Subsequent reads from it will return its default value.
  public mutating func clearStoryboard() {self._storyboard = nil}

  public var sences: Rankquantity_Voyager_Api_StoryBoardSences {
    get {return _sences ?? Rankquantity_Voyager_Api_StoryBoardSences()}
    set {_sences = newValue}
  }
  /// Returns true if `sences` has been explicitly set.
  public var hasSences: Bool {return self._sences != nil}
  /// Clears the value of `sences`. Subsequent reads from it will return its default value.
  public mutating func clearSences() {self._sences = nil}

  public var stage: Rankquantity_Voyager_Api_StoryboardStage = .unspecified

  public var lastUpdateTime: Int64 = 0

  public var version: Int64 = 0

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storyboard: Rankquantity_Voyager_Api_StoryBoard? = nil
  fileprivate var _sences: Rankquantity_Voyager_Api_StoryBoardSences? = nil
}

public struct Rankquantity_Voyager_Api_GetUserProfileRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetUserProfileResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var info: Rankquantity_Voyager_Api_UserProfileInfo {
    get {return _info ?? Rankquantity_Voyager_Api_UserProfileInfo()}
    set {_info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  public var hasInfo: Bool {return self._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  public mutating func clearInfo() {self._info = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _info: Rankquantity_Voyager_Api_UserProfileInfo? = nil
}

public struct Rankquantity_Voyager_Api_UpdateUserProfileRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var backgroundImage: String = String()

  public var avatar: String = String()

  public var name: String = String()

  public var description_p: String = String()

  public var location: String = String()

  public var email: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UpdateUserProfileResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UpdateUserBackgroundImageRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var backgroundImage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UpdateUserBackgroundImageResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_CreateStoryRoleRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var role: Rankquantity_Voyager_Api_StoryRole {
    get {return _role ?? Rankquantity_Voyager_Api_StoryRole()}
    set {_role = newValue}
  }
  /// Returns true if `role` has been explicitly set.
  public var hasRole: Bool {return self._role != nil}
  /// Clears the value of `role`. Subsequent reads from it will return its default value.
  public mutating func clearRole() {self._role = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _role: Rankquantity_Voyager_Api_StoryRole? = nil
}

public struct Rankquantity_Voyager_Api_CreateStoryRoleResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetStoryRoleDetailRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var roleID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetStoryRoleDetailResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var info: Rankquantity_Voyager_Api_StoryRole {
    get {return _info ?? Rankquantity_Voyager_Api_StoryRole()}
    set {_info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  public var hasInfo: Bool {return self._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  public mutating func clearInfo() {self._info = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _info: Rankquantity_Voyager_Api_StoryRole? = nil
}

public struct Rankquantity_Voyager_Api_RenderStoryRoleRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var roleID: Int64 = 0

  public var prompt: String = String()

  public var refImages: [String] = []

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_RenderStoryRoleDetail: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var roleID: Int64 = 0

  public var genID: Int64 = 0

  public var isFinished: Bool = false

  public var roleDescription: String = String()

  public var roleCharacter: String = String()

  public var roleBehavior: String = String()

  public var roleGoal: String = String()

  public var backgroundImage: String = String()

  public var avatarImage: String = String()

  public var background: String = String()

  public var appearance: String = String()

  public var personality: String = String()

  public var abilityFeatures: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_RenderStoryRoleResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var detail: Rankquantity_Voyager_Api_RenderStoryRoleDetail {
    get {return _detail ?? Rankquantity_Voyager_Api_RenderStoryRoleDetail()}
    set {_detail = newValue}
  }
  /// Returns true if `detail` has been explicitly set.
  public var hasDetail: Bool {return self._detail != nil}
  /// Clears the value of `detail`. Subsequent reads from it will return its default value.
  public mutating func clearDetail() {self._detail = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _detail: Rankquantity_Voyager_Api_RenderStoryRoleDetail? = nil
}

public struct Rankquantity_Voyager_Api_LikeStoryRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var storyID: Int64 = 0

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_LikeStoryResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UnLikeStoryRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var storyID: Int64 = 0

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UnLikeStoryResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rankquantity.voyager.api"

extension Rankquantity_Voyager_Api_TokenSource: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0TOKEN_SOURCE_USER_SELF\0\u{1}TOKEN_SOURCE_STORY_STORE\0\u{1}TOKEN_SOURCE_THIRD_PARTY\0")
}

extension Rankquantity_Voyager_Api_ActiveInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActiveInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}active_id\0\u{1}user\0\u{3}active_type\0\u{3}group_info\0\u{3}story_info\0\u{3}role_info\0\u{3}board_info\0\u{1}content\0\u{1}Ctime\0\u{1}Mtime\0")

  fileprivate class _StorageClass {
    var _activeID: Int64 = 0
    var _user: Rankquantity_Voyager_Api_UserInfo? = nil
    var _activeType: Rankquantity_Voyager_Api_ActiveType = .noneActive
    var _groupInfo: Rankquantity_Voyager_Api_GroupInfo? = nil
    var _storyInfo: Rankquantity_Voyager_Api_Story? = nil
    var _roleInfo: Rankquantity_Voyager_Api_StoryRole? = nil
    var _boardInfo: Rankquantity_Voyager_Api_StoryBoard? = nil
    var _content: String = String()
    var _ctime: Int64 = 0
    var _mtime: Int64 = 0

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _activeID = source._activeID
      _user = source._user
      _activeType = source._activeType
      _groupInfo = source._groupInfo
      _storyInfo = source._storyInfo
      _roleInfo = source._roleInfo
      _boardInfo = source._boardInfo
      _content = source._content
      _ctime = source._ctime
      _mtime = source._mtime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._activeID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._activeType) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._groupInfo) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._storyInfo) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._roleInfo) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._boardInfo) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._content) }()
        case 9: try { try decoder.decodeSingularInt64Field(value: &_storage._ctime) }()
        case 10: try { try decoder.decodeSingularInt64Field(value: &_storage._mtime) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._activeID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._activeID, fieldNumber: 1)
      }
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if _storage._activeType != .noneActive {
        try visitor.visitSingularEnumField(value: _storage._activeType, fieldNumber: 3)
      }
      try { if let v = _storage._groupInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._storyInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._roleInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._boardInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if !_storage._content.isEmpty {
        try visitor.visitSingularStringField(value: _storage._content, fieldNumber: 8)
      }
      if _storage._ctime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._ctime, fieldNumber: 9)
      }
      if _storage._mtime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._mtime, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_ActiveInfo, rhs: Rankquantity_Voyager_Api_ActiveInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._activeID != rhs_storage._activeID {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._activeType != rhs_storage._activeType {return false}
        if _storage._groupInfo != rhs_storage._groupInfo {return false}
        if _storage._storyInfo != rhs_storage._storyInfo {return false}
        if _storage._roleInfo != rhs_storage._roleInfo {return false}
        if _storage._boardInfo != rhs_storage._boardInfo {return false}
        if _storage._content != rhs_storage._content {return false}
        if _storage._ctime != rhs_storage._ctime {return false}
        if _storage._mtime != rhs_storage._mtime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_LoginRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoginRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}account\0\u{1}password\0\u{3}login_type\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.account) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.loginType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    if self.loginType != 0 {
      try visitor.visitSingularInt32Field(value: self.loginType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_LoginRequest, rhs: Rankquantity_Voyager_Api_LoginRequest) -> Bool {
    if lhs.account != rhs.account {return false}
    if lhs.password != rhs.password {return false}
    if lhs.loginType != rhs.loginType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_LoginResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoginResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}msg\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_LoginResponse, rhs: Rankquantity_Voyager_Api_LoginResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_LoginResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_LoginResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{1}token\0\u{1}timestamp\0\u{3}expire_at\0\u{1}status\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.expireAt) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 2)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 3)
    }
    if self.expireAt != 0 {
      try visitor.visitSingularInt64Field(value: self.expireAt, fieldNumber: 4)
    }
    if self.status != 0 {
      try visitor.visitSingularInt32Field(value: self.status, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_LoginResponse.DataMessage, rhs: Rankquantity_Voyager_Api_LoginResponse.DataMessage) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.token != rhs.token {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.expireAt != rhs.expireAt {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_LogoutRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LogoutRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}token\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_LogoutRequest, rhs: Rankquantity_Voyager_Api_LogoutRequest) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_LogoutResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LogoutResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}msg\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_LogoutResponse, rhs: Rankquantity_Voyager_Api_LogoutResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_RefreshTokenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RefreshTokenRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_RefreshTokenRequest, rhs: Rankquantity_Voyager_Api_RefreshTokenRequest) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_RefreshTokenResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RefreshTokenResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}token\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_RefreshTokenResponse, rhs: Rankquantity_Voyager_Api_RefreshTokenResponse) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_RegisterRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RegisterRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}account\0\u{1}password\0\u{1}name\0\u{1}email\0\u{1}phone\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.account) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.email) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.phone) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 4)
    }
    if !self.phone.isEmpty {
      try visitor.visitSingularStringField(value: self.phone, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_RegisterRequest, rhs: Rankquantity_Voyager_Api_RegisterRequest) -> Bool {
    if lhs.account != rhs.account {return false}
    if lhs.password != rhs.password {return false}
    if lhs.name != rhs.name {return false}
    if lhs.email != rhs.email {return false}
    if lhs.phone != rhs.phone {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_RegisterResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RegisterResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}msg\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_RegisterResponse, rhs: Rankquantity_Voyager_Api_RegisterResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_ConfirmRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConfirmRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_ConfirmRequest, rhs: Rankquantity_Voyager_Api_ConfirmRequest) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_ConfirmResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConfirmResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}status\0\u{1}timestamp\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.status) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != 0 {
      try visitor.visitSingularInt32Field(value: self.status, fieldNumber: 1)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_ConfirmResponse, rhs: Rankquantity_Voyager_Api_ConfirmResponse) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_ResetPasswordRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResetPasswordRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}account\0\u{1}oldPwd\0\u{1}newPwd\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.account) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.oldPwd) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.newPwd) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 1)
    }
    if !self.oldPwd.isEmpty {
      try visitor.visitSingularStringField(value: self.oldPwd, fieldNumber: 2)
    }
    if !self.newPwd.isEmpty {
      try visitor.visitSingularStringField(value: self.newPwd, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_ResetPasswordRequest, rhs: Rankquantity_Voyager_Api_ResetPasswordRequest) -> Bool {
    if lhs.account != rhs.account {return false}
    if lhs.oldPwd != rhs.oldPwd {return false}
    if lhs.newPwd != rhs.newPwd {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_ResetPasswordResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResetPasswordResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}account\0\u{1}status\0\u{1}timestamp\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.account) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.status) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 1)
    }
    if self.status != 0 {
      try visitor.visitSingularInt64Field(value: self.status, fieldNumber: 2)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_ResetPasswordResponse, rhs: Rankquantity_Voyager_Api_ResetPasswordResponse) -> Bool {
    if lhs.account != rhs.account {return false}
    if lhs.status != rhs.status {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UserInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserInfoRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{1}account\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.account) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UserInfoRequest, rhs: Rankquantity_Voyager_Api_UserInfoRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.account != rhs.account {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UserInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserInfoResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}msg\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UserInfoResponse, rhs: Rankquantity_Voyager_Api_UserInfoResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UserInfoResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_UserInfoResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}info\0\u{1}profile\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._profile) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._profile {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UserInfoResponse.DataMessage, rhs: Rankquantity_Voyager_Api_UserInfoResponse.DataMessage) -> Bool {
    if lhs._info != rhs._info {return false}
    if lhs._profile != rhs._profile {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateUserAvatorRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateUserAvatorRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{1}avatar\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.avatar) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if !self.avatar.isEmpty {
      try visitor.visitSingularStringField(value: self.avatar, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateUserAvatorRequest, rhs: Rankquantity_Voyager_Api_UpdateUserAvatorRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.avatar != rhs.avatar {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateUserAvatorResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateUserAvatorResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}msg\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateUserAvatorResponse, rhs: Rankquantity_Voyager_Api_UpdateUserAvatorResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateUserAvatorResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_UpdateUserAvatorResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}info\0\u{1}status\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.status != 0 {
      try visitor.visitSingularInt32Field(value: self.status, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateUserAvatorResponse.DataMessage, rhs: Rankquantity_Voyager_Api_UpdateUserAvatorResponse.DataMessage) -> Bool {
    if lhs._info != rhs._info {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UserWatchingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserWatchingRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{3}time_stamp\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.timeStamp) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.offset) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.timeStamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timeStamp, fieldNumber: 2)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt32Field(value: self.offset, fieldNumber: 3)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UserWatchingRequest, rhs: Rankquantity_Voyager_Api_UserWatchingRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.timeStamp != rhs.timeStamp {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UserWatchingResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserWatchingResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}msg\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UserWatchingResponse, rhs: Rankquantity_Voyager_Api_UserWatchingResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UserWatchingResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_UserWatchingResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}have_more\0\u{1}total\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 1)
    }
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UserWatchingResponse.DataMessage, rhs: Rankquantity_Voyager_Api_UserWatchingResponse.DataMessage) -> Bool {
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.total != rhs.total {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UserGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserGroupRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{1}gtype\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.gtype) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.offset) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.gtype != .protect {
      try visitor.visitSingularEnumField(value: self.gtype, fieldNumber: 2)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt32Field(value: self.offset, fieldNumber: 3)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UserGroupRequest, rhs: Rankquantity_Voyager_Api_UserGroupRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.gtype != rhs.gtype {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UserGroupResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserGroupResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}msg\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UserGroupResponse, rhs: Rankquantity_Voyager_Api_UserGroupResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UserGroupResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_UserGroupResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}list\0\u{1}offset\0\u{3}page_size\0\u{1}total\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.offset) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 1)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt32Field(value: self.offset, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 4)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UserGroupResponse.DataMessage, rhs: Rankquantity_Voyager_Api_UserGroupResponse.DataMessage) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.total != rhs.total {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UserFollowingGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserFollowingGroupRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.offset) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt32Field(value: self.offset, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UserFollowingGroupRequest, rhs: Rankquantity_Voyager_Api_UserFollowingGroupRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UserFollowingGroupResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserFollowingGroupResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}msg\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UserFollowingGroupResponse, rhs: Rankquantity_Voyager_Api_UserFollowingGroupResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UserFollowingGroupResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_UserFollowingGroupResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{1}list\0\u{1}offset\0\u{3}page_size\0\u{1}total\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 2)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 3)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 4)
    }
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 5)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UserFollowingGroupResponse.DataMessage, rhs: Rankquantity_Voyager_Api_UserFollowingGroupResponse.DataMessage) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.list != rhs.list {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.total != rhs.total {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UserUpdateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserUpdateRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{1}nickname\0\u{1}avatar\0\u{1}desc\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nickname) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.avatar) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.desc) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if !self.nickname.isEmpty {
      try visitor.visitSingularStringField(value: self.nickname, fieldNumber: 2)
    }
    if !self.avatar.isEmpty {
      try visitor.visitSingularStringField(value: self.avatar, fieldNumber: 3)
    }
    if !self.desc.isEmpty {
      try visitor.visitSingularStringField(value: self.desc, fieldNumber: 4)
    }
    if !self.data.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.data, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UserUpdateRequest, rhs: Rankquantity_Voyager_Api_UserUpdateRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.nickname != rhs.nickname {return false}
    if lhs.avatar != rhs.avatar {return false}
    if lhs.desc != rhs.desc {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UserUpdateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserUpdateResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UserUpdateResponse, rhs: Rankquantity_Voyager_Api_UserUpdateResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UserUpdateResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_UserUpdateResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UserUpdateResponse.DataMessage, rhs: Rankquantity_Voyager_Api_UserUpdateResponse.DataMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_FetchActivesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FetchActivesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{3}group_id\0\u{3}story_id\0\u{3}board_id\0\u{1}atype\0\u{1}timestamp\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.groupID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.boardID) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.atype) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.groupID != 0 {
      try visitor.visitSingularInt64Field(value: self.groupID, fieldNumber: 2)
    }
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 3)
    }
    if self.boardID != 0 {
      try visitor.visitSingularInt64Field(value: self.boardID, fieldNumber: 4)
    }
    if self.atype != .allFlowType {
      try visitor.visitSingularEnumField(value: self.atype, fieldNumber: 5)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 6)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 7)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_FetchActivesRequest, rhs: Rankquantity_Voyager_Api_FetchActivesRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs.storyID != rhs.storyID {return false}
    if lhs.boardID != rhs.boardID {return false}
    if lhs.atype != rhs.atype {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_FetchActivesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FetchActivesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}msg\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_FetchActivesResponse, rhs: Rankquantity_Voyager_Api_FetchActivesResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_FetchActivesResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_FetchActivesResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}list\0\u{1}timestamp\0\u{1}offset\0\u{3}page_size\0\u{3}have_more\0\u{1}total\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 1)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 2)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 3)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 4)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 5)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_FetchActivesResponse.DataMessage, rhs: Rankquantity_Voyager_Api_FetchActivesResponse.DataMessage) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.total != rhs.total {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_SearchUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchUserRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{3}group_id\0\u{3}is_fuzzy\0\u{2}\u{4}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.groupID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isFuzzy) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.groupID != 0 {
      try visitor.visitSingularInt64Field(value: self.groupID, fieldNumber: 2)
    }
    if self.isFuzzy != false {
      try visitor.visitSingularBoolField(value: self.isFuzzy, fieldNumber: 3)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 7)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_SearchUserRequest, rhs: Rankquantity_Voyager_Api_SearchUserRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs.isFuzzy != rhs.isFuzzy {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_SearchUserResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchUserResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}msg\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_SearchUserResponse, rhs: Rankquantity_Voyager_Api_SearchUserResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_SearchUserResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_SearchUserResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}list\0\u{1}offset\0\u{3}page_size\0\u{1}total\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 1)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 4)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_SearchUserResponse.DataMessage, rhs: Rankquantity_Voyager_Api_SearchUserResponse.DataMessage) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.total != rhs.total {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UserInitRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserInitRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{3}deafault_group\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.deafaultGroup) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if !self.deafaultGroup.isEmpty {
      try visitor.visitSingularStringField(value: self.deafaultGroup, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UserInitRequest, rhs: Rankquantity_Voyager_Api_UserInitRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.deafaultGroup != rhs.deafaultGroup {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UserInitResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserInitResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}msg\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UserInitResponse, rhs: Rankquantity_Voyager_Api_UserInitResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UserInitResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_UserInitResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{1}list\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UserInitResponse.DataMessage, rhs: Rankquantity_Voyager_Api_UserInitResponse.DataMessage) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.list != rhs.list {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetGroupItemsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetGroupItemsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_id\0\u{3}user_id\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.groupID != 0 {
      try visitor.visitSingularInt64Field(value: self.groupID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 3)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetGroupItemsRequest, rhs: Rankquantity_Voyager_Api_GetGroupItemsRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetGroupItemsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetGroupItemsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}msg\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetGroupItemsResponse, rhs: Rankquantity_Voyager_Api_GetGroupItemsResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetGroupItemsResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_GetGroupItemsResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}list\0\u{3}group_id\0\u{3}user_id\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.groupID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 1)
    }
    if self.groupID != 0 {
      try visitor.visitSingularInt64Field(value: self.groupID, fieldNumber: 2)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 3)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 4)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetGroupItemsResponse.DataMessage, rhs: Rankquantity_Voyager_Api_GetGroupItemsResponse.DataMessage) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetUserItemsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserItemsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetUserItemsRequest, rhs: Rankquantity_Voyager_Api_GetUserItemsRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetUserItemsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserItemsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}msg\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetUserItemsResponse, rhs: Rankquantity_Voyager_Api_GetUserItemsResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetUserItemsResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_GetUserItemsResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}list\0\u{3}user_id\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 3)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetUserItemsResponse.DataMessage, rhs: Rankquantity_Voyager_Api_GetUserItemsResponse.DataMessage) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetItemRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetItemRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_id\0\u{3}project_id\0\u{3}item_id\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.projectID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.itemID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.groupID != 0 {
      try visitor.visitSingularInt64Field(value: self.groupID, fieldNumber: 1)
    }
    if self.projectID != 0 {
      try visitor.visitSingularInt64Field(value: self.projectID, fieldNumber: 2)
    }
    if self.itemID != 0 {
      try visitor.visitSingularInt64Field(value: self.itemID, fieldNumber: 3)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetItemRequest, rhs: Rankquantity_Voyager_Api_GetItemRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.projectID != rhs.projectID {return false}
    if lhs.itemID != rhs.itemID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetItemResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetItemResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}msg\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetItemResponse, rhs: Rankquantity_Voyager_Api_GetItemResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetItemResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_GetItemResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}info\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetItemResponse.DataMessage, rhs: Rankquantity_Voyager_Api_GetItemResponse.DataMessage) -> Bool {
    if lhs._info != rhs._info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_CreateItemRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateItemRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_id\0\u{3}project_id\0\u{1}name\0\u{1}atype\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.projectID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.atype) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.groupID != 0 {
      try visitor.visitSingularInt64Field(value: self.groupID, fieldNumber: 1)
    }
    if self.projectID != 0 {
      try visitor.visitSingularInt64Field(value: self.projectID, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if self.atype != .noneActive {
      try visitor.visitSingularEnumField(value: self.atype, fieldNumber: 4)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_CreateItemRequest, rhs: Rankquantity_Voyager_Api_CreateItemRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.projectID != rhs.projectID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.atype != rhs.atype {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_CreateItemResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateItemResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_CreateItemResponse, rhs: Rankquantity_Voyager_Api_CreateItemResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_CreateItemResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_CreateItemResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}info\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_CreateItemResponse.DataMessage, rhs: Rankquantity_Voyager_Api_CreateItemResponse.DataMessage) -> Bool {
    if lhs._info != rhs._info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateItemRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateItemRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_id\0\u{3}project_id\0\u{3}item_id\0\u{1}info\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.projectID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.itemID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.groupID != 0 {
      try visitor.visitSingularInt64Field(value: self.groupID, fieldNumber: 1)
    }
    if self.projectID != 0 {
      try visitor.visitSingularInt64Field(value: self.projectID, fieldNumber: 2)
    }
    if self.itemID != 0 {
      try visitor.visitSingularInt64Field(value: self.itemID, fieldNumber: 3)
    }
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateItemRequest, rhs: Rankquantity_Voyager_Api_UpdateItemRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.projectID != rhs.projectID {return false}
    if lhs.itemID != rhs.itemID {return false}
    if lhs._info != rhs._info {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateItemResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateItemResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateItemResponse, rhs: Rankquantity_Voyager_Api_UpdateItemResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateItemResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_UpdateItemResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}info\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateItemResponse.DataMessage, rhs: Rankquantity_Voyager_Api_UpdateItemResponse.DataMessage) -> Bool {
    if lhs._info != rhs._info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_DeleteItemRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteItemRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_id\0\u{3}project_id\0\u{3}item_id\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.projectID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.itemID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.groupID != 0 {
      try visitor.visitSingularInt64Field(value: self.groupID, fieldNumber: 1)
    }
    if self.projectID != 0 {
      try visitor.visitSingularInt64Field(value: self.projectID, fieldNumber: 2)
    }
    if self.itemID != 0 {
      try visitor.visitSingularInt64Field(value: self.itemID, fieldNumber: 3)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_DeleteItemRequest, rhs: Rankquantity_Voyager_Api_DeleteItemRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.projectID != rhs.projectID {return false}
    if lhs.itemID != rhs.itemID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_DeleteItemResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteItemResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_DeleteItemResponse, rhs: Rankquantity_Voyager_Api_DeleteItemResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_DeleteItemResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_DeleteItemResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_DeleteItemResponse.DataMessage, rhs: Rankquantity_Voyager_Api_DeleteItemResponse.DataMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_LikeItemRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LikeItemRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_id\0\u{3}project_id\0\u{3}item_id\0\u{3}user_id\0\u{1}islike\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.projectID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.itemID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.islike) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.groupID != 0 {
      try visitor.visitSingularInt64Field(value: self.groupID, fieldNumber: 1)
    }
    if self.projectID != 0 {
      try visitor.visitSingularInt64Field(value: self.projectID, fieldNumber: 2)
    }
    if self.itemID != 0 {
      try visitor.visitSingularInt64Field(value: self.itemID, fieldNumber: 3)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 4)
    }
    if self.islike != false {
      try visitor.visitSingularBoolField(value: self.islike, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_LikeItemRequest, rhs: Rankquantity_Voyager_Api_LikeItemRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.projectID != rhs.projectID {return false}
    if lhs.itemID != rhs.itemID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.islike != rhs.islike {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_LikeItemResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LikeItemResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_LikeItemResponse, rhs: Rankquantity_Voyager_Api_LikeItemResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_LikeItemResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_LikeItemResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_LikeItemResponse.DataMessage, rhs: Rankquantity_Voyager_Api_LikeItemResponse.DataMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_CreateGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateGroupRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{1}name\0\u{1}description\0\u{1}avatar\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.avatar) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if !self.avatar.isEmpty {
      try visitor.visitSingularStringField(value: self.avatar, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_CreateGroupRequest, rhs: Rankquantity_Voyager_Api_CreateGroupRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.avatar != rhs.avatar {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_CreateGroupResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateGroupResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_CreateGroupResponse, rhs: Rankquantity_Voyager_Api_CreateGroupResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_CreateGroupResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_CreateGroupResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}info\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_CreateGroupResponse.DataMessage, rhs: Rankquantity_Voyager_Api_CreateGroupResponse.DataMessage) -> Bool {
    if lhs._info != rhs._info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetGroupRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_id\0\u{3}user_id\0\u{1}name\0\u{3}with_profile\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.withProfile) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.groupID != 0 {
      try visitor.visitSingularInt64Field(value: self.groupID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if self.withProfile != false {
      try visitor.visitSingularBoolField(value: self.withProfile, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetGroupRequest, rhs: Rankquantity_Voyager_Api_GetGroupRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.withProfile != rhs.withProfile {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetGroupResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetGroupResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetGroupResponse, rhs: Rankquantity_Voyager_Api_GetGroupResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetGroupResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_GetGroupResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}info\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetGroupResponse.DataMessage, rhs: Rankquantity_Voyager_Api_GetGroupResponse.DataMessage) -> Bool {
    if lhs._info != rhs._info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetGroupActivesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetGroupActivesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_id\0\u{1}atype\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.atype) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.groupID != 0 {
      try visitor.visitSingularInt64Field(value: self.groupID, fieldNumber: 1)
    }
    if self.atype != .noneActive {
      try visitor.visitSingularEnumField(value: self.atype, fieldNumber: 2)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 3)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetGroupActivesRequest, rhs: Rankquantity_Voyager_Api_GetGroupActivesRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.atype != rhs.atype {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetGroupActivesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetGroupActivesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetGroupActivesResponse, rhs: Rankquantity_Voyager_Api_GetGroupActivesResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetGroupActivesResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_GetGroupActivesResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}list\0\u{1}offset\0\u{3}page_size\0\u{3}have_more\0\u{1}total\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 1)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 3)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 4)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetGroupActivesResponse.DataMessage, rhs: Rankquantity_Voyager_Api_GetGroupActivesResponse.DataMessage) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.total != rhs.total {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateGroupInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateGroupInfoRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_id\0\u{1}info\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.groupID != 0 {
      try visitor.visitSingularInt64Field(value: self.groupID, fieldNumber: 1)
    }
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateGroupInfoRequest, rhs: Rankquantity_Voyager_Api_UpdateGroupInfoRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs._info != rhs._info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateGroupInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateGroupInfoResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateGroupInfoResponse, rhs: Rankquantity_Voyager_Api_UpdateGroupInfoResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateGroupInfoResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_UpdateGroupInfoResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}info\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateGroupInfoResponse.DataMessage, rhs: Rankquantity_Voyager_Api_UpdateGroupInfoResponse.DataMessage) -> Bool {
    if lhs._info != rhs._info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_DeleteGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteGroupRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_id\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.groupID != 0 {
      try visitor.visitSingularInt64Field(value: self.groupID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_DeleteGroupRequest, rhs: Rankquantity_Voyager_Api_DeleteGroupRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_DeleteGroupResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteGroupResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_DeleteGroupResponse, rhs: Rankquantity_Voyager_Api_DeleteGroupResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_DeleteGroupResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_DeleteGroupResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_DeleteGroupResponse.DataMessage, rhs: Rankquantity_Voyager_Api_DeleteGroupResponse.DataMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_FetchGroupMembersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FetchGroupMembersRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_id\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.groupID != 0 {
      try visitor.visitSingularInt64Field(value: self.groupID, fieldNumber: 1)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_FetchGroupMembersRequest, rhs: Rankquantity_Voyager_Api_FetchGroupMembersRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_FetchGroupMembersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FetchGroupMembersResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_FetchGroupMembersResponse, rhs: Rankquantity_Voyager_Api_FetchGroupMembersResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_FetchGroupMembersResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_FetchGroupMembersResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}list\0\u{1}offset\0\u{1}total\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 1)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 2)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 3)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_FetchGroupMembersResponse.DataMessage, rhs: Rankquantity_Voyager_Api_FetchGroupMembersResponse.DataMessage) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.total != rhs.total {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_SearchGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchGroupRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{3}user_id\0\u{1}offset\0\u{3}page_size\0\u{1}scope\0\u{3}story_id\0\u{3}group_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.scope) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.groupID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 3)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 4)
    }
    if self.scope != .protectScope {
      try visitor.visitSingularEnumField(value: self.scope, fieldNumber: 5)
    }
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 6)
    }
    if self.groupID != 0 {
      try visitor.visitSingularInt64Field(value: self.groupID, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_SearchGroupRequest, rhs: Rankquantity_Voyager_Api_SearchGroupRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.scope != rhs.scope {return false}
    if lhs.storyID != rhs.storyID {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_SearchGroupResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchGroupResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_SearchGroupResponse, rhs: Rankquantity_Voyager_Api_SearchGroupResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_SearchGroupResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_SearchGroupResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}list\0\u{1}offset\0\u{3}page_size\0\u{3}have_more\0\u{1}total\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 1)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 3)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 4)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_SearchGroupResponse.DataMessage, rhs: Rankquantity_Voyager_Api_SearchGroupResponse.DataMessage) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.total != rhs.total {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_JoinGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".JoinGroupRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_id\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.groupID != 0 {
      try visitor.visitSingularInt64Field(value: self.groupID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_JoinGroupRequest, rhs: Rankquantity_Voyager_Api_JoinGroupRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_JoinGroupResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".JoinGroupResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_JoinGroupResponse, rhs: Rankquantity_Voyager_Api_JoinGroupResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_JoinGroupResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_JoinGroupResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_JoinGroupResponse.DataMessage, rhs: Rankquantity_Voyager_Api_JoinGroupResponse.DataMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_LeaveGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LeaveGroupRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_id\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.groupID != 0 {
      try visitor.visitSingularInt64Field(value: self.groupID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_LeaveGroupRequest, rhs: Rankquantity_Voyager_Api_LeaveGroupRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_LeaveGroupResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LeaveGroupResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_LeaveGroupResponse, rhs: Rankquantity_Voyager_Api_LeaveGroupResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_LeaveGroupResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_LeaveGroupResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_LeaveGroupResponse.DataMessage, rhs: Rankquantity_Voyager_Api_LeaveGroupResponse.DataMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_DisscussParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DisscussParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_DisscussParams, rhs: Rankquantity_Voyager_Api_DisscussParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_CreateDisscussReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateDisscussReq"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_CreateDisscussReq, rhs: Rankquantity_Voyager_Api_CreateDisscussReq) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_CreateDisscusResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateDisscusResp"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_CreateDisscusResp, rhs: Rankquantity_Voyager_Api_CreateDisscusResp) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_CreateDisscusResp.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_CreateDisscusResp.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_CreateDisscusResp.DataMessage, rhs: Rankquantity_Voyager_Api_CreateDisscusResp.DataMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetDisscusReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDisscusReq"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetDisscusReq, rhs: Rankquantity_Voyager_Api_GetDisscusReq) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetDisscusResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDisscusResp"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetDisscusResp, rhs: Rankquantity_Voyager_Api_GetDisscusResp) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetDisscusResp.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_GetDisscusResp.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetDisscusResp.DataMessage, rhs: Rankquantity_Voyager_Api_GetDisscusResp.DataMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_VersionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VersionRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_VersionRequest, rhs: Rankquantity_Voyager_Api_VersionRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_VersionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VersionResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_VersionResponse, rhs: Rankquantity_Voyager_Api_VersionResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_VersionResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_VersionResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}version\0\u{3}build_time\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.buildTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 1)
    }
    if !self.buildTime.isEmpty {
      try visitor.visitSingularStringField(value: self.buildTime, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_VersionResponse.DataMessage, rhs: Rankquantity_Voyager_Api_VersionResponse.DataMessage) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.buildTime != rhs.buildTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_AboutRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AboutRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_AboutRequest, rhs: Rankquantity_Voyager_Api_AboutRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_AboutResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AboutResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}content\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.content) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_AboutResponse, rhs: Rankquantity_Voyager_Api_AboutResponse) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_ExploreRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExploreRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_ExploreRequest, rhs: Rankquantity_Voyager_Api_ExploreRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_ExploreResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExploreResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_ExploreResponse, rhs: Rankquantity_Voyager_Api_ExploreResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_ExploreResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_ExploreResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_ExploreResponse.DataMessage, rhs: Rankquantity_Voyager_Api_ExploreResponse.DataMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetProjectMembersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetProjectMembersRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}projectId\0\u{1}userId\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.projectID != 0 {
      try visitor.visitSingularInt32Field(value: self.projectID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt32Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetProjectMembersRequest, rhs: Rankquantity_Voyager_Api_GetProjectMembersRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetProjectMembersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetProjectMembersResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetProjectMembersResponse, rhs: Rankquantity_Voyager_Api_GetProjectMembersResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetProjectMembersResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_GetProjectMembersResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}list\0\u{1}total\0\u{1}role\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: &self.role) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 1)
    }
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 2)
    }
    if !self.role.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: self.role, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetProjectMembersResponse.DataMessage, rhs: Rankquantity_Voyager_Api_GetProjectMembersResponse.DataMessage) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.total != rhs.total {return false}
    if lhs.role != rhs.role {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetProjectWatcherRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetProjectWatcherRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}projectId\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.projectID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.projectID != 0 {
      try visitor.visitSingularInt32Field(value: self.projectID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetProjectWatcherRequest, rhs: Rankquantity_Voyager_Api_GetProjectWatcherRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetProjectWatcherResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetProjectWatcherResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetProjectWatcherResponse, rhs: Rankquantity_Voyager_Api_GetProjectWatcherResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetProjectWatcherResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_GetProjectWatcherResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}list\0\u{1}total\0\u{1}timestamp\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt64,SwiftProtobuf.ProtobufInt64>.self, value: &self.timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 1)
    }
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 2)
    }
    if !self.timestamp.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt64,SwiftProtobuf.ProtobufInt64>.self, value: self.timestamp, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetProjectWatcherResponse.DataMessage, rhs: Rankquantity_Voyager_Api_GetProjectWatcherResponse.DataMessage) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.total != rhs.total {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UploadImageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UploadImageRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}image_data\0\u{1}filename\0\u{3}content_type\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.imageData) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.filename) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.contentType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.imageData.isEmpty {
      try visitor.visitSingularBytesField(value: self.imageData, fieldNumber: 1)
    }
    if !self.filename.isEmpty {
      try visitor.visitSingularStringField(value: self.filename, fieldNumber: 2)
    }
    if !self.contentType.isEmpty {
      try visitor.visitSingularStringField(value: self.contentType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UploadImageRequest, rhs: Rankquantity_Voyager_Api_UploadImageRequest) -> Bool {
    if lhs.imageData != rhs.imageData {return false}
    if lhs.filename != rhs.filename {return false}
    if lhs.contentType != rhs.contentType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UploadImageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UploadImageResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UploadImageResponse, rhs: Rankquantity_Voyager_Api_UploadImageResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UploadImageResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_UploadImageResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}file_id\0\u{1}url\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fileID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fileID.isEmpty {
      try visitor.visitSingularStringField(value: self.fileID, fieldNumber: 1)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UploadImageResponse.DataMessage, rhs: Rankquantity_Voyager_Api_UploadImageResponse.DataMessage) -> Bool {
    if lhs.fileID != rhs.fileID {return false}
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryContributorsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryContributorsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0\u{3}user_id\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 3)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryContributorsRequest, rhs: Rankquantity_Voyager_Api_GetStoryContributorsRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_StoryContributor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StoryContributor"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{1}username\0\u{1}avatar\0\u{1}viplevel\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.avatar) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.viplevel) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 2)
    }
    if !self.avatar.isEmpty {
      try visitor.visitSingularStringField(value: self.avatar, fieldNumber: 3)
    }
    if self.viplevel != 0 {
      try visitor.visitSingularInt64Field(value: self.viplevel, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_StoryContributor, rhs: Rankquantity_Voyager_Api_StoryContributor) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.username != rhs.username {return false}
    if lhs.avatar != rhs.avatar {return false}
    if lhs.viplevel != rhs.viplevel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryContributorsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryContributorsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryContributorsResponse, rhs: Rankquantity_Voyager_Api_GetStoryContributorsResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryContributorsResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_GetStoryContributorsResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}list\0\u{1}total\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 1)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 2)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryContributorsResponse.DataMessage, rhs: Rankquantity_Voyager_Api_GetStoryContributorsResponse.DataMessage) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.total != rhs.total {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetGroupProfileRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetGroupProfileRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_id\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.groupID != 0 {
      try visitor.visitSingularInt64Field(value: self.groupID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetGroupProfileRequest, rhs: Rankquantity_Voyager_Api_GetGroupProfileRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetGroupProfileResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetGroupProfileResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetGroupProfileResponse, rhs: Rankquantity_Voyager_Api_GetGroupProfileResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetGroupProfileResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_GetGroupProfileResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}info\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetGroupProfileResponse.DataMessage, rhs: Rankquantity_Voyager_Api_GetGroupProfileResponse.DataMessage) -> Bool {
    if lhs._info != rhs._info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateGroupProfileRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateGroupProfileRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_id\0\u{1}info\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.groupID != 0 {
      try visitor.visitSingularInt64Field(value: self.groupID, fieldNumber: 1)
    }
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateGroupProfileRequest, rhs: Rankquantity_Voyager_Api_UpdateGroupProfileRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs._info != rhs._info {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateGroupProfileResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateGroupProfileResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateGroupProfileResponse, rhs: Rankquantity_Voyager_Api_UpdateGroupProfileResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryRolePosterListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryRolePosterListRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0\u{3}role_id\0\u{3}user_id\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 2)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 3)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 4)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryRolePosterListRequest, rhs: Rankquantity_Voyager_Api_GetStoryRolePosterListRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.roleID != rhs.roleID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_RolePosterDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RolePosterDetail"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{3}story_id\0\u{3}role_id\0\u{3}poster_url\0\u{1}prompt\0\u{3}like_count\0\u{3}is_liked_by_user\0\u{1}creator\0\u{3}created_at\0\u{3}updated_at\0")

  fileprivate class _StorageClass {
    var _id: Int64 = 0
    var _storyID: Int64 = 0
    var _roleID: Int64 = 0
    var _posterURL: String = String()
    var _prompt: String = String()
    var _likeCount: Int64 = 0
    var _isLikedByUser: Bool = false
    var _creator: Rankquantity_Voyager_Api_UserInfo? = nil
    var _createdAt: Int64 = 0
    var _updatedAt: Int64 = 0

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _storyID = source._storyID
      _roleID = source._roleID
      _posterURL = source._posterURL
      _prompt = source._prompt
      _likeCount = source._likeCount
      _isLikedByUser = source._isLikedByUser
      _creator = source._creator
      _createdAt = source._createdAt
      _updatedAt = source._updatedAt
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularInt64Field(value: &_storage._storyID) }()
        case 3: try { try decoder.decodeSingularInt64Field(value: &_storage._roleID) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._posterURL) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._prompt) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._likeCount) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._isLikedByUser) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._creator) }()
        case 9: try { try decoder.decodeSingularInt64Field(value: &_storage._createdAt) }()
        case 10: try { try decoder.decodeSingularInt64Field(value: &_storage._updatedAt) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._id != 0 {
        try visitor.visitSingularInt64Field(value: _storage._id, fieldNumber: 1)
      }
      if _storage._storyID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._storyID, fieldNumber: 2)
      }
      if _storage._roleID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._roleID, fieldNumber: 3)
      }
      if !_storage._posterURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._posterURL, fieldNumber: 4)
      }
      if !_storage._prompt.isEmpty {
        try visitor.visitSingularStringField(value: _storage._prompt, fieldNumber: 5)
      }
      if _storage._likeCount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._likeCount, fieldNumber: 6)
      }
      if _storage._isLikedByUser != false {
        try visitor.visitSingularBoolField(value: _storage._isLikedByUser, fieldNumber: 7)
      }
      try { if let v = _storage._creator {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if _storage._createdAt != 0 {
        try visitor.visitSingularInt64Field(value: _storage._createdAt, fieldNumber: 9)
      }
      if _storage._updatedAt != 0 {
        try visitor.visitSingularInt64Field(value: _storage._updatedAt, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_RolePosterDetail, rhs: Rankquantity_Voyager_Api_RolePosterDetail) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._storyID != rhs_storage._storyID {return false}
        if _storage._roleID != rhs_storage._roleID {return false}
        if _storage._posterURL != rhs_storage._posterURL {return false}
        if _storage._prompt != rhs_storage._prompt {return false}
        if _storage._likeCount != rhs_storage._likeCount {return false}
        if _storage._isLikedByUser != rhs_storage._isLikedByUser {return false}
        if _storage._creator != rhs_storage._creator {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._updatedAt != rhs_storage._updatedAt {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryRolePosterListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryRolePosterListResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}posters\0\u{1}total\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.posters) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.posters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.posters, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 4)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryRolePosterListResponse, rhs: Rankquantity_Voyager_Api_GetStoryRolePosterListResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.posters != rhs.posters {return false}
    if lhs.total != rhs.total {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_LikeStoryRolePosterRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LikeStoryRolePosterRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0\u{3}role_id\0\u{3}user_id\0\u{3}poster_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.posterID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 2)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 3)
    }
    if self.posterID != 0 {
      try visitor.visitSingularInt64Field(value: self.posterID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_LikeStoryRolePosterRequest, rhs: Rankquantity_Voyager_Api_LikeStoryRolePosterRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.roleID != rhs.roleID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.posterID != rhs.posterID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_LikeStoryRolePosterResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LikeStoryRolePosterResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{3}current_like_count\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.currentLikeCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if self.currentLikeCount != 0 {
      try visitor.visitSingularInt64Field(value: self.currentLikeCount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_LikeStoryRolePosterResponse, rhs: Rankquantity_Voyager_Api_LikeStoryRolePosterResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.currentLikeCount != rhs.currentLikeCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UnLikeStoryRolePosterRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnLikeStoryRolePosterRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0\u{3}role_id\0\u{3}user_id\0\u{3}poster_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.posterID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 2)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 3)
    }
    if self.posterID != 0 {
      try visitor.visitSingularInt64Field(value: self.posterID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UnLikeStoryRolePosterRequest, rhs: Rankquantity_Voyager_Api_UnLikeStoryRolePosterRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.roleID != rhs.roleID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.posterID != rhs.posterID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UnLikeStoryRolePosterResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnLikeStoryRolePosterResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{3}current_like_count\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.currentLikeCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if self.currentLikeCount != 0 {
      try visitor.visitSingularInt64Field(value: self.currentLikeCount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UnLikeStoryRolePosterResponse, rhs: Rankquantity_Voyager_Api_UnLikeStoryRolePosterResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.currentLikeCount != rhs.currentLikeCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_FetchUserGenTaskStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FetchUserGenTaskStatusRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{3}task_id\0\u{1}timestamp\0\u{3}page_num\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.taskID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.pageNum) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if !self.taskID.isEmpty {
      try visitor.visitSingularStringField(value: self.taskID, fieldNumber: 2)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 3)
    }
    if self.pageNum != 0 {
      try visitor.visitSingularInt64Field(value: self.pageNum, fieldNumber: 4)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_FetchUserGenTaskStatusRequest, rhs: Rankquantity_Voyager_Api_FetchUserGenTaskStatusRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.taskID != rhs.taskID {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.pageNum != rhs.pageNum {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_StoryGentaskDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StoryGentaskDetail"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0\u{3}board_id\0\u{3}storyboard_desc\0\u{3}sence_id\0\u{3}sence_desc\0\u{1}prompt\0\u{3}task_type\0\u{3}task_stage\0\u{3}start_image_url\0\u{3}end_image_url\0\u{3}video_url\0\u{3}reg_image_url\0\u{1}style\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.boardID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.storyboardDesc) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.senceID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.senceDesc) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.prompt) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.taskType) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.taskStage) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.startImageURL) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.endImageURL) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.videoURL) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.regImageURL) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.style) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.boardID != 0 {
      try visitor.visitSingularInt64Field(value: self.boardID, fieldNumber: 2)
    }
    if !self.storyboardDesc.isEmpty {
      try visitor.visitSingularStringField(value: self.storyboardDesc, fieldNumber: 3)
    }
    if self.senceID != 0 {
      try visitor.visitSingularInt64Field(value: self.senceID, fieldNumber: 4)
    }
    if !self.senceDesc.isEmpty {
      try visitor.visitSingularStringField(value: self.senceDesc, fieldNumber: 5)
    }
    if !self.prompt.isEmpty {
      try visitor.visitSingularStringField(value: self.prompt, fieldNumber: 6)
    }
    if self.taskType != 0 {
      try visitor.visitSingularInt64Field(value: self.taskType, fieldNumber: 7)
    }
    if self.taskStage != 0 {
      try visitor.visitSingularInt64Field(value: self.taskStage, fieldNumber: 8)
    }
    if !self.startImageURL.isEmpty {
      try visitor.visitSingularStringField(value: self.startImageURL, fieldNumber: 9)
    }
    if !self.endImageURL.isEmpty {
      try visitor.visitSingularStringField(value: self.endImageURL, fieldNumber: 10)
    }
    if !self.videoURL.isEmpty {
      try visitor.visitSingularStringField(value: self.videoURL, fieldNumber: 11)
    }
    if !self.regImageURL.isEmpty {
      try visitor.visitSingularStringField(value: self.regImageURL, fieldNumber: 12)
    }
    if !self.style.isEmpty {
      try visitor.visitSingularStringField(value: self.style, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_StoryGentaskDetail, rhs: Rankquantity_Voyager_Api_StoryGentaskDetail) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.boardID != rhs.boardID {return false}
    if lhs.storyboardDesc != rhs.storyboardDesc {return false}
    if lhs.senceID != rhs.senceID {return false}
    if lhs.senceDesc != rhs.senceDesc {return false}
    if lhs.prompt != rhs.prompt {return false}
    if lhs.taskType != rhs.taskType {return false}
    if lhs.taskStage != rhs.taskStage {return false}
    if lhs.startImageURL != rhs.startImageURL {return false}
    if lhs.endImageURL != rhs.endImageURL {return false}
    if lhs.videoURL != rhs.videoURL {return false}
    if lhs.regImageURL != rhs.regImageURL {return false}
    if lhs.style != rhs.style {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UserGenTaskStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserGenTaskStatus"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}task_id\0\u{3}user_id\0\u{1}status\0\u{1}detail\0\u{3}create_time\0\u{3}update_time\0")

  fileprivate class _StorageClass {
    var _taskID: String = String()
    var _userID: Int64 = 0
    var _status: String = String()
    var _detail: Rankquantity_Voyager_Api_StoryGentaskDetail? = nil
    var _createTime: Int64 = 0
    var _updateTime: Int64 = 0

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _taskID = source._taskID
      _userID = source._userID
      _status = source._status
      _detail = source._detail
      _createTime = source._createTime
      _updateTime = source._updateTime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._taskID) }()
        case 2: try { try decoder.decodeSingularInt64Field(value: &_storage._userID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._status) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._detail) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._createTime) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._updateTime) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._taskID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._taskID, fieldNumber: 1)
      }
      if _storage._userID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._userID, fieldNumber: 2)
      }
      if !_storage._status.isEmpty {
        try visitor.visitSingularStringField(value: _storage._status, fieldNumber: 3)
      }
      try { if let v = _storage._detail {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._createTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._createTime, fieldNumber: 5)
      }
      if _storage._updateTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._updateTime, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UserGenTaskStatus, rhs: Rankquantity_Voyager_Api_UserGenTaskStatus) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._taskID != rhs_storage._taskID {return false}
        if _storage._userID != rhs_storage._userID {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._detail != rhs_storage._detail {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._updateTime != rhs_storage._updateTime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_FetchUserGenTaskStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FetchUserGenTaskStatusResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}tasks\0\u{1}total\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.tasks) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.tasks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tasks, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 4)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_FetchUserGenTaskStatusResponse, rhs: Rankquantity_Voyager_Api_FetchUserGenTaskStatusResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.tasks != rhs.tasks {return false}
    if lhs.total != rhs.total {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GenerateRoleAvatarRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateRoleAvatarRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}role_id\0\u{3}user_id\0\u{3}ref_avatar_url\0\u{1}description\0\u{1}style\0\u{3}image_ratios\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.refAvatarURL) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.style) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.imageRatios) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if !self.refAvatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.refAvatarURL, fieldNumber: 3)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 4)
    }
    if !self.style.isEmpty {
      try visitor.visitSingularStringField(value: self.style, fieldNumber: 5)
    }
    if self.imageRatios != .ratio11 {
      try visitor.visitSingularEnumField(value: self.imageRatios, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GenerateRoleAvatarRequest, rhs: Rankquantity_Voyager_Api_GenerateRoleAvatarRequest) -> Bool {
    if lhs.roleID != rhs.roleID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.refAvatarURL != rhs.refAvatarURL {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.style != rhs.style {return false}
    if lhs.imageRatios != rhs.imageRatios {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GenerateRoleAvatarResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateRoleAvatarResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{3}avatar_url\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GenerateRoleAvatarResponse, rhs: Rankquantity_Voyager_Api_GenerateRoleAvatarResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GenerateStorySceneVideoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateStorySceneVideoRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0\u{3}board_id\0\u{3}sence_id\0\u{3}user_id\0\u{3}token_source\0\u{1}prompt\0\u{3}negative_prompt\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.boardID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.senceID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.tokenSource) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.prompt) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.negativePrompt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.boardID != 0 {
      try visitor.visitSingularInt64Field(value: self.boardID, fieldNumber: 2)
    }
    if self.senceID != 0 {
      try visitor.visitSingularInt64Field(value: self.senceID, fieldNumber: 3)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 4)
    }
    if self.tokenSource != .userSelf {
      try visitor.visitSingularEnumField(value: self.tokenSource, fieldNumber: 5)
    }
    if !self.prompt.isEmpty {
      try visitor.visitSingularStringField(value: self.prompt, fieldNumber: 6)
    }
    if !self.negativePrompt.isEmpty {
      try visitor.visitSingularStringField(value: self.negativePrompt, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GenerateStorySceneVideoRequest, rhs: Rankquantity_Voyager_Api_GenerateStorySceneVideoRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.boardID != rhs.boardID {return false}
    if lhs.senceID != rhs.senceID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.tokenSource != rhs.tokenSource {return false}
    if lhs.prompt != rhs.prompt {return false}
    if lhs.negativePrompt != rhs.negativePrompt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GenerateStorySceneVideoTaskDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateStorySceneVideoTaskDetail"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}task_id\0\u{3}task_status\0\u{3}video_url\0\u{3}video_thumbnail_url\0\u{1}duration\0\u{1}resolution\0\u{3}video_format\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.taskID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.taskStatus) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.videoURL) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.videoThumbnailURL) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.duration) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.resolution) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.videoFormat) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.taskID.isEmpty {
      try visitor.visitSingularStringField(value: self.taskID, fieldNumber: 1)
    }
    if self.taskStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.taskStatus, fieldNumber: 2)
    }
    if !self.videoURL.isEmpty {
      try visitor.visitSingularStringField(value: self.videoURL, fieldNumber: 3)
    }
    if !self.videoThumbnailURL.isEmpty {
      try visitor.visitSingularStringField(value: self.videoThumbnailURL, fieldNumber: 4)
    }
    if self.duration != 0 {
      try visitor.visitSingularInt64Field(value: self.duration, fieldNumber: 5)
    }
    if !self.resolution.isEmpty {
      try visitor.visitSingularStringField(value: self.resolution, fieldNumber: 6)
    }
    if !self.videoFormat.isEmpty {
      try visitor.visitSingularStringField(value: self.videoFormat, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GenerateStorySceneVideoTaskDetail, rhs: Rankquantity_Voyager_Api_GenerateStorySceneVideoTaskDetail) -> Bool {
    if lhs.taskID != rhs.taskID {return false}
    if lhs.taskStatus != rhs.taskStatus {return false}
    if lhs.videoURL != rhs.videoURL {return false}
    if lhs.videoThumbnailURL != rhs.videoThumbnailURL {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.resolution != rhs.resolution {return false}
    if lhs.videoFormat != rhs.videoFormat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GenerateStorySceneVideoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateStorySceneVideoResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}detail\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._detail) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._detail {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GenerateStorySceneVideoResponse, rhs: Rankquantity_Voyager_Api_GenerateStorySceneVideoResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._detail != rhs._detail {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GenerateStoryRoleVideoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateStoryRoleVideoRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0\u{3}role_id\0\u{3}user_id\0\u{3}poster_id\0\u{3}ref_background_url\0\u{3}ref_avatar_url\0\u{3}text_prompt\0\u{3}image_ratios\0\u{1}style\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.posterID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.refBackgroundURL) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.refAvatarURL) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.textPrompt) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.imageRatios) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.style) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 2)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 3)
    }
    if self.posterID != 0 {
      try visitor.visitSingularInt64Field(value: self.posterID, fieldNumber: 4)
    }
    if !self.refBackgroundURL.isEmpty {
      try visitor.visitSingularStringField(value: self.refBackgroundURL, fieldNumber: 5)
    }
    if !self.refAvatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.refAvatarURL, fieldNumber: 6)
    }
    if !self.textPrompt.isEmpty {
      try visitor.visitSingularStringField(value: self.textPrompt, fieldNumber: 7)
    }
    if self.imageRatios != .ratio11 {
      try visitor.visitSingularEnumField(value: self.imageRatios, fieldNumber: 8)
    }
    if !self.style.isEmpty {
      try visitor.visitSingularStringField(value: self.style, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GenerateStoryRoleVideoRequest, rhs: Rankquantity_Voyager_Api_GenerateStoryRoleVideoRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.roleID != rhs.roleID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.posterID != rhs.posterID {return false}
    if lhs.refBackgroundURL != rhs.refBackgroundURL {return false}
    if lhs.refAvatarURL != rhs.refAvatarURL {return false}
    if lhs.textPrompt != rhs.textPrompt {return false}
    if lhs.imageRatios != rhs.imageRatios {return false}
    if lhs.style != rhs.style {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GenerateStoryRoleVideoTaskDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateStoryRoleVideoTaskDetail"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}task_id\0\u{3}task_status\0\u{3}video_url\0\u{3}video_thumbnail_url\0\u{1}duration\0\u{1}resolution\0\u{3}video_format\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.taskID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.taskStatus) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.videoURL) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.videoThumbnailURL) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.duration) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.resolution) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.videoFormat) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.taskID.isEmpty {
      try visitor.visitSingularStringField(value: self.taskID, fieldNumber: 1)
    }
    if self.taskStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.taskStatus, fieldNumber: 2)
    }
    if !self.videoURL.isEmpty {
      try visitor.visitSingularStringField(value: self.videoURL, fieldNumber: 3)
    }
    if !self.videoThumbnailURL.isEmpty {
      try visitor.visitSingularStringField(value: self.videoThumbnailURL, fieldNumber: 4)
    }
    if self.duration != 0 {
      try visitor.visitSingularInt64Field(value: self.duration, fieldNumber: 5)
    }
    if !self.resolution.isEmpty {
      try visitor.visitSingularStringField(value: self.resolution, fieldNumber: 6)
    }
    if !self.videoFormat.isEmpty {
      try visitor.visitSingularStringField(value: self.videoFormat, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GenerateStoryRoleVideoTaskDetail, rhs: Rankquantity_Voyager_Api_GenerateStoryRoleVideoTaskDetail) -> Bool {
    if lhs.taskID != rhs.taskID {return false}
    if lhs.taskStatus != rhs.taskStatus {return false}
    if lhs.videoURL != rhs.videoURL {return false}
    if lhs.videoThumbnailURL != rhs.videoThumbnailURL {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.resolution != rhs.resolution {return false}
    if lhs.videoFormat != rhs.videoFormat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GenerateStoryRoleVideoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateStoryRoleVideoResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}detail\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._detail) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._detail {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GenerateStoryRoleVideoResponse, rhs: Rankquantity_Voyager_Api_GenerateStoryRoleVideoResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._detail != rhs._detail {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryParticipantsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryParticipantsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryParticipantsRequest, rhs: Rankquantity_Voyager_Api_GetStoryParticipantsRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryParticipantsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryParticipantsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}participants\0\u{1}total\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.participants) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.participants.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.participants, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 4)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryParticipantsResponse, rhs: Rankquantity_Voyager_Api_GetStoryParticipantsResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.participants != rhs.participants {return false}
    if lhs.total != rhs.total {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateStoryAvatarRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateStoryAvatarRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0\u{3}user_id\0\u{3}avatar_url\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateStoryAvatarRequest, rhs: Rankquantity_Voyager_Api_UpdateStoryAvatarRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateStoryAvatarResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateStoryAvatarResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateStoryAvatarResponse, rhs: Rankquantity_Voyager_Api_UpdateStoryAvatarResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateStoryCoverRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateStoryCoverRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0\u{3}user_id\0\u{3}cover_url\0\u{3}use_ai_cover\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.coverURL) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.useAiCover) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if !self.coverURL.isEmpty {
      try visitor.visitSingularStringField(value: self.coverURL, fieldNumber: 3)
    }
    if self.useAiCover != false {
      try visitor.visitSingularBoolField(value: self.useAiCover, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateStoryCoverRequest, rhs: Rankquantity_Voyager_Api_UpdateStoryCoverRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.coverURL != rhs.coverURL {return false}
    if lhs.useAiCover != rhs.useAiCover {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateStoryCoverResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateStoryCoverResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateStoryCoverResponse, rhs: Rankquantity_Voyager_Api_UpdateStoryCoverResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryImageStyleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryImageStyleRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryImageStyleRequest, rhs: Rankquantity_Voyager_Api_GetStoryImageStyleRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_StoryStyleDesc: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StoryStyleDesc"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}style\0\u{1}description\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.style) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.style.isEmpty {
      try visitor.visitSingularStringField(value: self.style, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_StoryStyleDesc, rhs: Rankquantity_Voyager_Api_StoryStyleDesc) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.style != rhs.style {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryImageStyleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryImageStyleResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}style\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.style) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.style.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.style, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryImageStyleResponse, rhs: Rankquantity_Voyager_Api_GetStoryImageStyleResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.style != rhs.style {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateStoryImageStyleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateStoryImageStyleRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0\u{3}style_id\0\u{1}style\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.styleID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.style) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.styleID != 0 {
      try visitor.visitSingularInt64Field(value: self.styleID, fieldNumber: 2)
    }
    if !self.style.isEmpty {
      try visitor.visitSingularStringField(value: self.style, fieldNumber: 3)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateStoryImageStyleRequest, rhs: Rankquantity_Voyager_Api_UpdateStoryImageStyleRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.styleID != rhs.styleID {return false}
    if lhs.style != rhs.style {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateStoryImageStyleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateStoryImageStyleResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateStoryImageStyleResponse, rhs: Rankquantity_Voyager_Api_UpdateStoryImageStyleResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateStorySenceMaxNumberRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateStorySenceMaxNumberRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0\u{3}max_number\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.maxNumber) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.maxNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.maxNumber, fieldNumber: 2)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateStorySenceMaxNumberRequest, rhs: Rankquantity_Voyager_Api_UpdateStorySenceMaxNumberRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.maxNumber != rhs.maxNumber {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateStorySenceMaxNumberResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateStorySenceMaxNumberResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateStorySenceMaxNumberResponse, rhs: Rankquantity_Voyager_Api_UpdateStorySenceMaxNumberResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateStoryRolePromptRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateStoryRolePromptRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0\u{3}role_id\0\u{3}user_id\0\u{1}prompt\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.prompt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 2)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 3)
    }
    if !self.prompt.isEmpty {
      try visitor.visitSingularStringField(value: self.prompt, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateStoryRolePromptRequest, rhs: Rankquantity_Voyager_Api_UpdateStoryRolePromptRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.roleID != rhs.roleID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.prompt != rhs.prompt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateStoryRolePromptResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateStoryRolePromptResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateStoryRolePromptResponse, rhs: Rankquantity_Voyager_Api_UpdateStoryRolePromptResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateStoryRoleDescriptionDetailRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateStoryRoleDescriptionDetailRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0\u{3}role_id\0\u{3}user_id\0\u{3}character_detail\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._characterDetail) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 2)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 3)
    }
    try { if let v = self._characterDetail {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateStoryRoleDescriptionDetailRequest, rhs: Rankquantity_Voyager_Api_UpdateStoryRoleDescriptionDetailRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.roleID != rhs.roleID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs._characterDetail != rhs._characterDetail {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateStoryRoleDescriptionDetailResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateStoryRoleDescriptionDetailResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateStoryRoleDescriptionDetailResponse, rhs: Rankquantity_Voyager_Api_UpdateStoryRoleDescriptionDetailResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GenerateStoryRoleParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateStoryRoleParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}origin_image_url\0\u{3}additional_image_urls\0\u{3}text_prompt\0\u{3}negative_prompt\0\u{1}style\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.originImageURL) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.additionalImageUrls) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.textPrompt) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.negativePrompt) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.style) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.originImageURL.isEmpty {
      try visitor.visitSingularStringField(value: self.originImageURL, fieldNumber: 1)
    }
    if !self.additionalImageUrls.isEmpty {
      try visitor.visitRepeatedStringField(value: self.additionalImageUrls, fieldNumber: 2)
    }
    if !self.textPrompt.isEmpty {
      try visitor.visitSingularStringField(value: self.textPrompt, fieldNumber: 3)
    }
    if !self.negativePrompt.isEmpty {
      try visitor.visitSingularStringField(value: self.negativePrompt, fieldNumber: 4)
    }
    if !self.style.isEmpty {
      try visitor.visitSingularStringField(value: self.style, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GenerateStoryRoleParams, rhs: Rankquantity_Voyager_Api_GenerateStoryRoleParams) -> Bool {
    if lhs.originImageURL != rhs.originImageURL {return false}
    if lhs.additionalImageUrls != rhs.additionalImageUrls {return false}
    if lhs.textPrompt != rhs.textPrompt {return false}
    if lhs.negativePrompt != rhs.negativePrompt {return false}
    if lhs.style != rhs.style {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GenerateStoryRolePosterRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateStoryRolePosterRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0\u{3}role_id\0\u{3}user_id\0\u{1}params\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._params) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 2)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 3)
    }
    try { if let v = self._params {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GenerateStoryRolePosterRequest, rhs: Rankquantity_Voyager_Api_GenerateStoryRolePosterRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.roleID != rhs.roleID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs._params != rhs._params {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GenerateStoryRolePosterResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateStoryRolePosterResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{3}image_url\0\u{3}poster_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.imageURL) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.posterID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.imageURL.isEmpty {
      try visitor.visitSingularStringField(value: self.imageURL, fieldNumber: 3)
    }
    if self.posterID != 0 {
      try visitor.visitSingularInt64Field(value: self.posterID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GenerateStoryRolePosterResponse, rhs: Rankquantity_Voyager_Api_GenerateStoryRolePosterResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.imageURL != rhs.imageURL {return false}
    if lhs.posterID != rhs.posterID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateStoryRolePosterRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateStoryRolePosterRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0\u{3}role_id\0\u{3}user_id\0\u{3}poster_id\0\u{3}image_url\0\u{3}is_public\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.posterID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.imageURL) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isPublic) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 2)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 3)
    }
    if self.posterID != 0 {
      try visitor.visitSingularInt64Field(value: self.posterID, fieldNumber: 4)
    }
    if !self.imageURL.isEmpty {
      try visitor.visitSingularStringField(value: self.imageURL, fieldNumber: 5)
    }
    if self.isPublic != false {
      try visitor.visitSingularBoolField(value: self.isPublic, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateStoryRolePosterRequest, rhs: Rankquantity_Voyager_Api_UpdateStoryRolePosterRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.roleID != rhs.roleID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.posterID != rhs.posterID {return false}
    if lhs.imageURL != rhs.imageURL {return false}
    if lhs.isPublic != rhs.isPublic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateStoryRolePosterResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateStoryRolePosterResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{3}poster_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.posterID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if self.posterID != 0 {
      try visitor.visitSingularInt64Field(value: self.posterID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateStoryRolePosterResponse, rhs: Rankquantity_Voyager_Api_UpdateStoryRolePosterResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.posterID != rhs.posterID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetFollowListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetFollowListRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetFollowListRequest, rhs: Rankquantity_Voyager_Api_GetFollowListRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetFollowListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetFollowListResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}followers\0\u{1}total\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.followers) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.followers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.followers, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 4)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetFollowListResponse, rhs: Rankquantity_Voyager_Api_GetFollowListResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.followers != rhs.followers {return false}
    if lhs.total != rhs.total {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetFollowerListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetFollowerListRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetFollowerListRequest, rhs: Rankquantity_Voyager_Api_GetFollowerListRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetFollowerListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetFollowerListResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}followers\0\u{1}total\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.followers) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.followers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.followers, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 4)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetFollowerListResponse, rhs: Rankquantity_Voyager_Api_GetFollowerListResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.followers != rhs.followers {return false}
    if lhs.total != rhs.total {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_FollowUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FollowUserRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{3}follower_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.followerID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.followerID != 0 {
      try visitor.visitSingularInt64Field(value: self.followerID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_FollowUserRequest, rhs: Rankquantity_Voyager_Api_FollowUserRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.followerID != rhs.followerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_FollowUserResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FollowUserResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_FollowUserResponse, rhs: Rankquantity_Voyager_Api_FollowUserResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UnfollowUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnfollowUserRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{3}follower_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.followerID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.followerID != 0 {
      try visitor.visitSingularInt64Field(value: self.followerID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UnfollowUserRequest, rhs: Rankquantity_Voyager_Api_UnfollowUserRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.followerID != rhs.followerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UnfollowUserResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnfollowUserResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UnfollowUserResponse, rhs: Rankquantity_Voyager_Api_UnfollowUserResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_TrendingStoryRoleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TrendingStoryRoleRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}start\0\u{1}end\0\u{3}page_size\0\u{3}page_number\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.start) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.end) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.pageNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.start != 0 {
      try visitor.visitSingularInt64Field(value: self.start, fieldNumber: 1)
    }
    if self.end != 0 {
      try visitor.visitSingularInt64Field(value: self.end, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 3)
    }
    if self.pageNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.pageNumber, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_TrendingStoryRoleRequest, rhs: Rankquantity_Voyager_Api_TrendingStoryRoleRequest) -> Bool {
    if lhs.start != rhs.start {return false}
    if lhs.end != rhs.end {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageNumber != rhs.pageNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_TrendingStoryRoleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TrendingStoryRoleResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_TrendingStoryRoleResponse, rhs: Rankquantity_Voyager_Api_TrendingStoryRoleResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_TrendingStoryRoleResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_TrendingStoryRoleResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}list\0\u{3}page_size\0\u{3}page_number\0\u{1}total\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.pageNumber) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 2)
    }
    if self.pageNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.pageNumber, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 4)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_TrendingStoryRoleResponse.DataMessage, rhs: Rankquantity_Voyager_Api_TrendingStoryRoleResponse.DataMessage) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageNumber != rhs.pageNumber {return false}
    if lhs.total != rhs.total {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_TrendingStoryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TrendingStoryRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}start\0\u{1}end\0\u{3}page_size\0\u{3}page_number\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.start) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.end) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.pageNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.start != 0 {
      try visitor.visitSingularInt64Field(value: self.start, fieldNumber: 1)
    }
    if self.end != 0 {
      try visitor.visitSingularInt64Field(value: self.end, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 3)
    }
    if self.pageNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.pageNumber, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_TrendingStoryRequest, rhs: Rankquantity_Voyager_Api_TrendingStoryRequest) -> Bool {
    if lhs.start != rhs.start {return false}
    if lhs.end != rhs.end {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageNumber != rhs.pageNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_TrendingStoryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TrendingStoryResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_TrendingStoryResponse, rhs: Rankquantity_Voyager_Api_TrendingStoryResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_TrendingStoryResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_TrendingStoryResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}list\0\u{3}page_size\0\u{3}page_number\0\u{1}total\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.pageNumber) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 2)
    }
    if self.pageNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.pageNumber, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 4)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_TrendingStoryResponse.DataMessage, rhs: Rankquantity_Voyager_Api_TrendingStoryResponse.DataMessage) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageNumber != rhs.pageNumber {return false}
    if lhs.total != rhs.total {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryRoleListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryRoleListRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0\u{3}user_id\0\u{3}board_id\0\u{3}search_key\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.boardID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.searchKey) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if self.boardID != 0 {
      try visitor.visitSingularInt64Field(value: self.boardID, fieldNumber: 3)
    }
    if !self.searchKey.isEmpty {
      try visitor.visitSingularStringField(value: self.searchKey, fieldNumber: 4)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 5)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryRoleListRequest, rhs: Rankquantity_Voyager_Api_GetStoryRoleListRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.boardID != rhs.boardID {return false}
    if lhs.searchKey != rhs.searchKey {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryRoleListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryRoleListResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}roles\0\u{1}total\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.roles) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.roles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.roles, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 4)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryRoleListResponse, rhs: Rankquantity_Voyager_Api_GetStoryRoleListResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.roles != rhs.roles {return false}
    if lhs.total != rhs.total {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_ArchiveStoryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ArchiveStoryRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_ArchiveStoryRequest, rhs: Rankquantity_Voyager_Api_ArchiveStoryRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_ArchiveStoryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ArchiveStoryResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_ArchiveStoryResponse, rhs: Rankquantity_Voyager_Api_ArchiveStoryResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_CreateStoryCommentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateStoryCommentRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0\u{3}user_id\0\u{1}content\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.content) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_CreateStoryCommentRequest, rhs: Rankquantity_Voyager_Api_CreateStoryCommentRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_CreateStoryCommentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateStoryCommentResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}comment\0")

  fileprivate class _StorageClass {
    var _code: Rankquantity_Voyager_Api_ResponseCode = .ok
    var _message: String = String()
    var _comment: Rankquantity_Voyager_Api_CommentInfo? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _message = source._message
      _comment = source._comment
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._code) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._message) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._comment) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if !_storage._message.isEmpty {
        try visitor.visitSingularStringField(value: _storage._message, fieldNumber: 2)
      }
      try { if let v = _storage._comment {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_CreateStoryCommentResponse, rhs: Rankquantity_Voyager_Api_CreateStoryCommentResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._message != rhs_storage._message {return false}
        if _storage._comment != rhs_storage._comment {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryCommentsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryCommentsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0\u{3}user_id\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 3)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryCommentsRequest, rhs: Rankquantity_Voyager_Api_GetStoryCommentsRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_StoryComment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StoryComment"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}comment_id\0\u{3}story_id\0\u{3}board_id\0\u{3}role_id\0\u{3}prev_id\0\u{3}root_comment_id\0\u{3}user_id\0\u{1}content\0\u{3}created_at\0\u{3}updated_at\0\u{3}like_count\0\u{3}reply_count\0\u{3}is_liked\0\u{1}creator\0\u{3}created_at_timestamp\0")

  fileprivate class _StorageClass {
    var _commentID: Int64 = 0
    var _storyID: Int64 = 0
    var _boardID: Int64 = 0
    var _roleID: Int64 = 0
    var _prevID: Int64 = 0
    var _rootCommentID: Int64 = 0
    var _userID: Int64 = 0
    var _content: String = String()
    var _createdAt: Int64 = 0
    var _updatedAt: Int64 = 0
    var _likeCount: Int64 = 0
    var _replyCount: Int64 = 0
    var _isLiked: Int64 = 0
    var _creator: Rankquantity_Voyager_Api_UserInfo? = nil
    var _createdAtTimestamp: Int64 = 0

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _commentID = source._commentID
      _storyID = source._storyID
      _boardID = source._boardID
      _roleID = source._roleID
      _prevID = source._prevID
      _rootCommentID = source._rootCommentID
      _userID = source._userID
      _content = source._content
      _createdAt = source._createdAt
      _updatedAt = source._updatedAt
      _likeCount = source._likeCount
      _replyCount = source._replyCount
      _isLiked = source._isLiked
      _creator = source._creator
      _createdAtTimestamp = source._createdAtTimestamp
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._commentID) }()
        case 2: try { try decoder.decodeSingularInt64Field(value: &_storage._storyID) }()
        case 3: try { try decoder.decodeSingularInt64Field(value: &_storage._boardID) }()
        case 4: try { try decoder.decodeSingularInt64Field(value: &_storage._roleID) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._prevID) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._rootCommentID) }()
        case 7: try { try decoder.decodeSingularInt64Field(value: &_storage._userID) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._content) }()
        case 9: try { try decoder.decodeSingularInt64Field(value: &_storage._createdAt) }()
        case 10: try { try decoder.decodeSingularInt64Field(value: &_storage._updatedAt) }()
        case 11: try { try decoder.decodeSingularInt64Field(value: &_storage._likeCount) }()
        case 12: try { try decoder.decodeSingularInt64Field(value: &_storage._replyCount) }()
        case 13: try { try decoder.decodeSingularInt64Field(value: &_storage._isLiked) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._creator) }()
        case 15: try { try decoder.decodeSingularInt64Field(value: &_storage._createdAtTimestamp) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._commentID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._commentID, fieldNumber: 1)
      }
      if _storage._storyID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._storyID, fieldNumber: 2)
      }
      if _storage._boardID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._boardID, fieldNumber: 3)
      }
      if _storage._roleID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._roleID, fieldNumber: 4)
      }
      if _storage._prevID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._prevID, fieldNumber: 5)
      }
      if _storage._rootCommentID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._rootCommentID, fieldNumber: 6)
      }
      if _storage._userID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._userID, fieldNumber: 7)
      }
      if !_storage._content.isEmpty {
        try visitor.visitSingularStringField(value: _storage._content, fieldNumber: 8)
      }
      if _storage._createdAt != 0 {
        try visitor.visitSingularInt64Field(value: _storage._createdAt, fieldNumber: 9)
      }
      if _storage._updatedAt != 0 {
        try visitor.visitSingularInt64Field(value: _storage._updatedAt, fieldNumber: 10)
      }
      if _storage._likeCount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._likeCount, fieldNumber: 11)
      }
      if _storage._replyCount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._replyCount, fieldNumber: 12)
      }
      if _storage._isLiked != 0 {
        try visitor.visitSingularInt64Field(value: _storage._isLiked, fieldNumber: 13)
      }
      try { if let v = _storage._creator {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      if _storage._createdAtTimestamp != 0 {
        try visitor.visitSingularInt64Field(value: _storage._createdAtTimestamp, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_StoryComment, rhs: Rankquantity_Voyager_Api_StoryComment) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._commentID != rhs_storage._commentID {return false}
        if _storage._storyID != rhs_storage._storyID {return false}
        if _storage._boardID != rhs_storage._boardID {return false}
        if _storage._roleID != rhs_storage._roleID {return false}
        if _storage._prevID != rhs_storage._prevID {return false}
        if _storage._rootCommentID != rhs_storage._rootCommentID {return false}
        if _storage._userID != rhs_storage._userID {return false}
        if _storage._content != rhs_storage._content {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._updatedAt != rhs_storage._updatedAt {return false}
        if _storage._likeCount != rhs_storage._likeCount {return false}
        if _storage._replyCount != rhs_storage._replyCount {return false}
        if _storage._isLiked != rhs_storage._isLiked {return false}
        if _storage._creator != rhs_storage._creator {return false}
        if _storage._createdAtTimestamp != rhs_storage._createdAtTimestamp {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryCommentsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryCommentsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}comments\0\u{1}total\0\u{1}offset\0\u{3}page_size\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.comments) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.comments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.comments, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 4)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 5)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 6)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryCommentsResponse, rhs: Rankquantity_Voyager_Api_GetStoryCommentsResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.comments != rhs.comments {return false}
    if lhs.total != rhs.total {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_DeleteStoryCommentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteStoryCommentRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}comment_id\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.commentID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.commentID != 0 {
      try visitor.visitSingularInt64Field(value: self.commentID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_DeleteStoryCommentRequest, rhs: Rankquantity_Voyager_Api_DeleteStoryCommentRequest) -> Bool {
    if lhs.commentID != rhs.commentID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_DeleteStoryCommentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteStoryCommentResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_DeleteStoryCommentResponse, rhs: Rankquantity_Voyager_Api_DeleteStoryCommentResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryCommentRepliesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryCommentRepliesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}comment_id\0\u{3}user_id\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.commentID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.commentID != 0 {
      try visitor.visitSingularInt64Field(value: self.commentID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 3)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryCommentRepliesRequest, rhs: Rankquantity_Voyager_Api_GetStoryCommentRepliesRequest) -> Bool {
    if lhs.commentID != rhs.commentID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryCommentRepliesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryCommentRepliesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}replies\0\u{1}total\0\u{1}offset\0\u{3}page_size\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.replies) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.replies.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.replies, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 4)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 5)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 6)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryCommentRepliesResponse, rhs: Rankquantity_Voyager_Api_GetStoryCommentRepliesResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.replies != rhs.replies {return false}
    if lhs.total != rhs.total {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_CreateStoryCommentReplyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateStoryCommentReplyRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}comment_id\0\u{3}user_id\0\u{1}content\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.commentID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.content) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.commentID != 0 {
      try visitor.visitSingularInt64Field(value: self.commentID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_CreateStoryCommentReplyRequest, rhs: Rankquantity_Voyager_Api_CreateStoryCommentReplyRequest) -> Bool {
    if lhs.commentID != rhs.commentID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_CreateStoryCommentReplyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateStoryCommentReplyResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}comment\0")

  fileprivate class _StorageClass {
    var _code: Rankquantity_Voyager_Api_ResponseCode = .ok
    var _message: String = String()
    var _comment: Rankquantity_Voyager_Api_CommentInfo? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _message = source._message
      _comment = source._comment
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._code) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._message) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._comment) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if !_storage._message.isEmpty {
        try visitor.visitSingularStringField(value: _storage._message, fieldNumber: 2)
      }
      try { if let v = _storage._comment {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_CreateStoryCommentReplyResponse, rhs: Rankquantity_Voyager_Api_CreateStoryCommentReplyResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._message != rhs_storage._message {return false}
        if _storage._comment != rhs_storage._comment {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_DeleteStoryCommentReplyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteStoryCommentReplyRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}reply_id\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.replyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.replyID != 0 {
      try visitor.visitSingularInt64Field(value: self.replyID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_DeleteStoryCommentReplyRequest, rhs: Rankquantity_Voyager_Api_DeleteStoryCommentReplyRequest) -> Bool {
    if lhs.replyID != rhs.replyID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_DeleteStoryCommentReplyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteStoryCommentReplyResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_DeleteStoryCommentReplyResponse, rhs: Rankquantity_Voyager_Api_DeleteStoryCommentReplyResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryBoardCommentsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryBoardCommentsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}board_id\0\u{3}user_id\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.boardID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.boardID != 0 {
      try visitor.visitSingularInt64Field(value: self.boardID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 3)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryBoardCommentsRequest, rhs: Rankquantity_Voyager_Api_GetStoryBoardCommentsRequest) -> Bool {
    if lhs.boardID != rhs.boardID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryBoardCommentsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryBoardCommentsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}comments\0\u{1}total\0\u{1}offset\0\u{3}page_size\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.comments) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.comments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.comments, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 4)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 5)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 6)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryBoardCommentsResponse, rhs: Rankquantity_Voyager_Api_GetStoryBoardCommentsResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.comments != rhs.comments {return false}
    if lhs.total != rhs.total {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_CreateStoryBoardCommentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateStoryBoardCommentRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}board_id\0\u{3}user_id\0\u{1}content\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.boardID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.content) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.boardID != 0 {
      try visitor.visitSingularInt64Field(value: self.boardID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_CreateStoryBoardCommentRequest, rhs: Rankquantity_Voyager_Api_CreateStoryBoardCommentRequest) -> Bool {
    if lhs.boardID != rhs.boardID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_CreateStoryBoardCommentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateStoryBoardCommentResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}comment\0")

  fileprivate class _StorageClass {
    var _code: Rankquantity_Voyager_Api_ResponseCode = .ok
    var _message: String = String()
    var _comment: Rankquantity_Voyager_Api_CommentInfo? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _message = source._message
      _comment = source._comment
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._code) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._message) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._comment) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if !_storage._message.isEmpty {
        try visitor.visitSingularStringField(value: _storage._message, fieldNumber: 2)
      }
      try { if let v = _storage._comment {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_CreateStoryBoardCommentResponse, rhs: Rankquantity_Voyager_Api_CreateStoryBoardCommentResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._message != rhs_storage._message {return false}
        if _storage._comment != rhs_storage._comment {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_DeleteStoryBoardCommentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteStoryBoardCommentRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}board_id\0\u{3}comment_id\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.boardID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.commentID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.boardID != 0 {
      try visitor.visitSingularInt64Field(value: self.boardID, fieldNumber: 1)
    }
    if self.commentID != 0 {
      try visitor.visitSingularInt64Field(value: self.commentID, fieldNumber: 2)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_DeleteStoryBoardCommentRequest, rhs: Rankquantity_Voyager_Api_DeleteStoryBoardCommentRequest) -> Bool {
    if lhs.boardID != rhs.boardID {return false}
    if lhs.commentID != rhs.commentID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_DeleteStoryBoardCommentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteStoryBoardCommentResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_DeleteStoryBoardCommentResponse, rhs: Rankquantity_Voyager_Api_DeleteStoryBoardCommentResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryBoardCommentRepliesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryBoardCommentRepliesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}comment_id\0\u{3}user_id\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.commentID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.commentID != 0 {
      try visitor.visitSingularInt64Field(value: self.commentID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 3)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryBoardCommentRepliesRequest, rhs: Rankquantity_Voyager_Api_GetStoryBoardCommentRepliesRequest) -> Bool {
    if lhs.commentID != rhs.commentID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryBoardCommentRepliesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryBoardCommentRepliesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}replies\0\u{1}total\0\u{1}offset\0\u{3}page_size\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.replies) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.replies.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.replies, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 4)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 5)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 6)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryBoardCommentRepliesResponse, rhs: Rankquantity_Voyager_Api_GetStoryBoardCommentRepliesResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.replies != rhs.replies {return false}
    if lhs.total != rhs.total {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_LikeCommentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LikeCommentRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}comment_id\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.commentID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.commentID != 0 {
      try visitor.visitSingularInt64Field(value: self.commentID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_LikeCommentRequest, rhs: Rankquantity_Voyager_Api_LikeCommentRequest) -> Bool {
    if lhs.commentID != rhs.commentID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_LikeCommentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LikeCommentResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_LikeCommentResponse, rhs: Rankquantity_Voyager_Api_LikeCommentResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_DislikeCommentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DislikeCommentRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}comment_id\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.commentID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.commentID != 0 {
      try visitor.visitSingularInt64Field(value: self.commentID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_DislikeCommentRequest, rhs: Rankquantity_Voyager_Api_DislikeCommentRequest) -> Bool {
    if lhs.commentID != rhs.commentID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_DislikeCommentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DislikeCommentResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_DislikeCommentResponse, rhs: Rankquantity_Voyager_Api_DislikeCommentResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateRolePromptRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateRolePromptRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{3}role_id\0\u{1}prompt\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.prompt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 2)
    }
    if !self.prompt.isEmpty {
      try visitor.visitSingularStringField(value: self.prompt, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateRolePromptRequest, rhs: Rankquantity_Voyager_Api_UpdateRolePromptRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.roleID != rhs.roleID {return false}
    if lhs.prompt != rhs.prompt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateRolePromptResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateRolePromptResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateRolePromptResponse, rhs: Rankquantity_Voyager_Api_UpdateRolePromptResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GenerateRolePromptRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateRolePromptRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0\u{3}user_id\0\u{3}role_id\0\u{1}prompt\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.prompt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 3)
    }
    if !self.prompt.isEmpty {
      try visitor.visitSingularStringField(value: self.prompt, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GenerateRolePromptRequest, rhs: Rankquantity_Voyager_Api_GenerateRolePromptRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.roleID != rhs.roleID {return false}
    if lhs.prompt != rhs.prompt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GenerateRolePromptResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateRolePromptResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}prompt\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.prompt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.prompt.isEmpty {
      try visitor.visitSingularStringField(value: self.prompt, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GenerateRolePromptResponse, rhs: Rankquantity_Voyager_Api_GenerateRolePromptResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.prompt != rhs.prompt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateRoleDescriptionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateRoleDescriptionRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{3}role_id\0\u{1}description\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateRoleDescriptionRequest, rhs: Rankquantity_Voyager_Api_UpdateRoleDescriptionRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.roleID != rhs.roleID {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateRoleDescriptionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateRoleDescriptionResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateRoleDescriptionResponse, rhs: Rankquantity_Voyager_Api_UpdateRoleDescriptionResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GenerateRoleDescriptionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateRoleDescriptionRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0\u{3}user_id\0\u{3}role_id\0\u{1}description\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 3)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GenerateRoleDescriptionRequest, rhs: Rankquantity_Voyager_Api_GenerateRoleDescriptionRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.roleID != rhs.roleID {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GenerateRoleDescriptionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateRoleDescriptionResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{3}character_detail\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._characterDetail) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._characterDetail {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GenerateRoleDescriptionResponse, rhs: Rankquantity_Voyager_Api_GenerateRoleDescriptionResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._characterDetail != rhs._characterDetail {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetUnPublishStoryboardRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUnPublishStoryboardRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetUnPublishStoryboardRequest, rhs: Rankquantity_Voyager_Api_GetUnPublishStoryboardRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetUnPublishStoryboardResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUnPublishStoryboardResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}storyboardactives\0\u{1}total\0\u{1}offset\0\u{3}page_size\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.storyboardactives) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.storyboardactives.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.storyboardactives, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 4)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 5)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 6)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetUnPublishStoryboardResponse, rhs: Rankquantity_Voyager_Api_GetUnPublishStoryboardResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.storyboardactives != rhs.storyboardactives {return false}
    if lhs.total != rhs.total {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetUserWatchRoleActiveStoryBoardsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserWatchRoleActiveStoryBoardsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{3}role_id\0\u{1}offset\0\u{3}page_size\0\u{1}filter\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 2)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 3)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 4)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetUserWatchRoleActiveStoryBoardsRequest, rhs: Rankquantity_Voyager_Api_GetUserWatchRoleActiveStoryBoardsRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.roleID != rhs.roleID {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetUserWatchRoleActiveStoryBoardsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserWatchRoleActiveStoryBoardsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}storyboards\0\u{1}total\0\u{1}offset\0\u{3}page_size\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.storyboards) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.storyboards.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.storyboards, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 4)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 5)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 6)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetUserWatchRoleActiveStoryBoardsResponse, rhs: Rankquantity_Voyager_Api_GetUserWatchRoleActiveStoryBoardsResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.storyboards != rhs.storyboards {return false}
    if lhs.total != rhs.total {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetUserWatchStoryActiveStoryBoardsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserWatchStoryActiveStoryBoardsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{3}story_id\0\u{1}offset\0\u{3}page_size\0\u{1}filter\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 2)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 3)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 4)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetUserWatchStoryActiveStoryBoardsRequest, rhs: Rankquantity_Voyager_Api_GetUserWatchStoryActiveStoryBoardsRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.storyID != rhs.storyID {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetUserWatchStoryActiveStoryBoardsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserWatchStoryActiveStoryBoardsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}storyboards\0\u{1}total\0\u{1}offset\0\u{3}page_size\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.storyboards) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.storyboards.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.storyboards, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 4)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 5)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 6)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetUserWatchStoryActiveStoryBoardsResponse, rhs: Rankquantity_Voyager_Api_GetUserWatchStoryActiveStoryBoardsResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.storyboards != rhs.storyboards {return false}
    if lhs.total != rhs.total {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_SaveStoryboardCraftRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SaveStoryboardCraftRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}storyboard_id\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyboardID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyboardID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyboardID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_SaveStoryboardCraftRequest, rhs: Rankquantity_Voyager_Api_SaveStoryboardCraftRequest) -> Bool {
    if lhs.storyboardID != rhs.storyboardID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_SaveStoryboardCraftResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SaveStoryboardCraftResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_SaveStoryboardCraftResponse, rhs: Rankquantity_Voyager_Api_SaveStoryboardCraftResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_PublishStoryboardRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PublishStoryboardRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}storyboard_id\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyboardID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyboardID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyboardID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_PublishStoryboardRequest, rhs: Rankquantity_Voyager_Api_PublishStoryboardRequest) -> Bool {
    if lhs.storyboardID != rhs.storyboardID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_PublishStoryboardResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PublishStoryboardResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_PublishStoryboardResponse, rhs: Rankquantity_Voyager_Api_PublishStoryboardResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_CancelStoryboardRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CancelStoryboardRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}storyboard_id\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyboardID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyboardID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyboardID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_CancelStoryboardRequest, rhs: Rankquantity_Voyager_Api_CancelStoryboardRequest) -> Bool {
    if lhs.storyboardID != rhs.storyboardID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_CancelStoryboardResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CancelStoryboardResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_CancelStoryboardResponse, rhs: Rankquantity_Voyager_Api_CancelStoryboardResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_RenderStoryRoleContinuouslyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RenderStoryRoleContinuouslyRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}role_id\0\u{3}user_id\0\u{3}story_id\0\u{1}prompt\0\u{3}reference_image\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.prompt) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.referenceImage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 3)
    }
    if !self.prompt.isEmpty {
      try visitor.visitSingularStringField(value: self.prompt, fieldNumber: 4)
    }
    if !self.referenceImage.isEmpty {
      try visitor.visitSingularStringField(value: self.referenceImage, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_RenderStoryRoleContinuouslyRequest, rhs: Rankquantity_Voyager_Api_RenderStoryRoleContinuouslyRequest) -> Bool {
    if lhs.roleID != rhs.roleID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.storyID != rhs.storyID {return false}
    if lhs.prompt != rhs.prompt {return false}
    if lhs.referenceImage != rhs.referenceImage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_RenderStoryRoleContinuouslyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RenderStoryRoleContinuouslyResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}detail\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._detail) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._detail {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_RenderStoryRoleContinuouslyResponse, rhs: Rankquantity_Voyager_Api_RenderStoryRoleContinuouslyResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._detail != rhs._detail {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetNextStoryboardRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetNextStoryboardRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}storyboard_id\0\u{3}user_id\0\u{3}story_id\0\u{3}is_multi_branch\0\u{1}offset\0\u{3}page_size\0\u{1}total\0\u{3}order_by\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyboardID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isMultiBranch) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.orderBy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyboardID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyboardID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 3)
    }
    if self.isMultiBranch != false {
      try visitor.visitSingularBoolField(value: self.isMultiBranch, fieldNumber: 4)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 5)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 6)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 7)
    }
    if self.orderBy != .unspecified {
      try visitor.visitSingularEnumField(value: self.orderBy, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetNextStoryboardRequest, rhs: Rankquantity_Voyager_Api_GetNextStoryboardRequest) -> Bool {
    if lhs.storyboardID != rhs.storyboardID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.storyID != rhs.storyID {return false}
    if lhs.isMultiBranch != rhs.isMultiBranch {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.total != rhs.total {return false}
    if lhs.orderBy != rhs.orderBy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetNextStoryboardResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetNextStoryboardResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}storyboards\0\u{3}is_multi_branch\0\u{1}total\0\u{1}offset\0\u{3}page_size\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.storyboards) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isMultiBranch) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.storyboards.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.storyboards, fieldNumber: 3)
    }
    if self.isMultiBranch != false {
      try visitor.visitSingularBoolField(value: self.isMultiBranch, fieldNumber: 4)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 5)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 6)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 7)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetNextStoryboardResponse, rhs: Rankquantity_Voyager_Api_GetNextStoryboardResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.storyboards != rhs.storyboards {return false}
    if lhs.isMultiBranch != rhs.isMultiBranch {return false}
    if lhs.total != rhs.total {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetUserChatMessagesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserChatMessagesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{3}chat_id\0\u{3}role_id\0\u{1}timestamp\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.chatID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.chatID != 0 {
      try visitor.visitSingularInt64Field(value: self.chatID, fieldNumber: 2)
    }
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 3)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetUserChatMessagesRequest, rhs: Rankquantity_Voyager_Api_GetUserChatMessagesRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.chatID != rhs.chatID {return false}
    if lhs.roleID != rhs.roleID {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetUserChatMessagesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserChatMessagesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}messages\0\u{1}timestamp\0\u{1}total\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 3)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 4)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 5)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetUserChatMessagesResponse, rhs: Rankquantity_Voyager_Api_GetUserChatMessagesResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.messages != rhs.messages {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.total != rhs.total {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetUserChatWithRoleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserChatWithRoleRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}role_id\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetUserChatWithRoleRequest, rhs: Rankquantity_Voyager_Api_GetUserChatWithRoleRequest) -> Bool {
    if lhs.roleID != rhs.roleID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetUserChatWithRoleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserChatWithRoleResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}messages\0\u{3}chat_context\0\u{1}total\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._chatContext) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 3)
    }
    try { if let v = self._chatContext {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 5)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetUserChatWithRoleResponse, rhs: Rankquantity_Voyager_Api_GetUserChatWithRoleResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.messages != rhs.messages {return false}
    if lhs._chatContext != rhs._chatContext {return false}
    if lhs.total != rhs.total {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryRoleStoryboardsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryRoleStoryboardsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}role_id\0\u{3}user_id\0\u{3}story_id\0\u{1}filter\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 3)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 4)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 5)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryRoleStoryboardsRequest, rhs: Rankquantity_Voyager_Api_GetStoryRoleStoryboardsRequest) -> Bool {
    if lhs.roleID != rhs.roleID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.storyID != rhs.storyID {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryRoleStoryboardsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryRoleStoryboardsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}storyboardactives\0\u{1}total\0\u{1}offset\0\u{3}page_size\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.storyboardactives) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.storyboardactives.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.storyboardactives, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 4)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 5)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 6)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryRoleStoryboardsResponse, rhs: Rankquantity_Voyager_Api_GetStoryRoleStoryboardsResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.storyboardactives != rhs.storyboardactives {return false}
    if lhs.total != rhs.total {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryRoleStoriesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryRoleStoriesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}role_id\0\u{3}user_id\0\u{1}filter\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 3)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 4)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryRoleStoriesRequest, rhs: Rankquantity_Voyager_Api_GetStoryRoleStoriesRequest) -> Bool {
    if lhs.roleID != rhs.roleID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryRoleStoriesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryRoleStoriesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}stories\0\u{1}total\0\u{1}offset\0\u{3}page_size\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.stories) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.stories.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.stories, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 4)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 5)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 6)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryRoleStoriesResponse, rhs: Rankquantity_Voyager_Api_GetStoryRoleStoriesResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.stories != rhs.stories {return false}
    if lhs.total != rhs.total {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_CreateStoryRoleChatRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateStoryRoleChatRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}role_id\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_CreateStoryRoleChatRequest, rhs: Rankquantity_Voyager_Api_CreateStoryRoleChatRequest) -> Bool {
    if lhs.roleID != rhs.roleID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_ChatContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatContext"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}chat_id\0\u{3}role_id\0\u{3}user_id\0\u{1}timestamp\0\u{3}last_update_time\0\u{3}total_tokens\0\u{3}total_messages\0\u{3}last_message\0\u{1}user\0\u{1}role\0")

  fileprivate class _StorageClass {
    var _chatID: Int64 = 0
    var _roleID: Int64 = 0
    var _userID: Int64 = 0
    var _timestamp: Int64 = 0
    var _lastUpdateTime: Int64 = 0
    var _totalTokens: Int64 = 0
    var _totalMessages: Int64 = 0
    var _lastMessage: Rankquantity_Voyager_Api_ChatMessage? = nil
    var _user: Rankquantity_Voyager_Api_UserInfo? = nil
    var _role: Rankquantity_Voyager_Api_StoryRole? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _chatID = source._chatID
      _roleID = source._roleID
      _userID = source._userID
      _timestamp = source._timestamp
      _lastUpdateTime = source._lastUpdateTime
      _totalTokens = source._totalTokens
      _totalMessages = source._totalMessages
      _lastMessage = source._lastMessage
      _user = source._user
      _role = source._role
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._chatID) }()
        case 2: try { try decoder.decodeSingularInt64Field(value: &_storage._roleID) }()
        case 3: try { try decoder.decodeSingularInt64Field(value: &_storage._userID) }()
        case 4: try { try decoder.decodeSingularInt64Field(value: &_storage._timestamp) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._lastUpdateTime) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._totalTokens) }()
        case 7: try { try decoder.decodeSingularInt64Field(value: &_storage._totalMessages) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._lastMessage) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._role) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._chatID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._chatID, fieldNumber: 1)
      }
      if _storage._roleID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._roleID, fieldNumber: 2)
      }
      if _storage._userID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._userID, fieldNumber: 3)
      }
      if _storage._timestamp != 0 {
        try visitor.visitSingularInt64Field(value: _storage._timestamp, fieldNumber: 4)
      }
      if _storage._lastUpdateTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._lastUpdateTime, fieldNumber: 5)
      }
      if _storage._totalTokens != 0 {
        try visitor.visitSingularInt64Field(value: _storage._totalTokens, fieldNumber: 6)
      }
      if _storage._totalMessages != 0 {
        try visitor.visitSingularInt64Field(value: _storage._totalMessages, fieldNumber: 7)
      }
      try { if let v = _storage._lastMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._role {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_ChatContext, rhs: Rankquantity_Voyager_Api_ChatContext) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._chatID != rhs_storage._chatID {return false}
        if _storage._roleID != rhs_storage._roleID {return false}
        if _storage._userID != rhs_storage._userID {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._lastUpdateTime != rhs_storage._lastUpdateTime {return false}
        if _storage._totalTokens != rhs_storage._totalTokens {return false}
        if _storage._totalMessages != rhs_storage._totalMessages {return false}
        if _storage._lastMessage != rhs_storage._lastMessage {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._role != rhs_storage._role {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_CreateStoryRoleChatResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateStoryRoleChatResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{3}chat_context\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._chatContext) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._chatContext {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_CreateStoryRoleChatResponse, rhs: Rankquantity_Voyager_Api_CreateStoryRoleChatResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._chatContext != rhs._chatContext {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_ChatWithStoryRoleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatWithStoryRoleRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}role_id\0\u{3}user_id\0\u{1}messages\0\u{1}total\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 4)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_ChatWithStoryRoleRequest, rhs: Rankquantity_Voyager_Api_ChatWithStoryRoleRequest) -> Bool {
    if lhs.roleID != rhs.roleID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.messages != rhs.messages {return false}
    if lhs.total != rhs.total {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_ChatWithStoryRoleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatWithStoryRoleResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{3}reply_messages\0\u{1}total\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.replyMessages) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.replyMessages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.replyMessages, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 4)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_ChatWithStoryRoleResponse, rhs: Rankquantity_Voyager_Api_ChatWithStoryRoleResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.replyMessages != rhs.replyMessages {return false}
    if lhs.total != rhs.total {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateStoryRoleDetailRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateStoryRoleDetailRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}role_id\0\u{1}role\0\u{3}user_id\0\u{3}need_regen\0\u{3}background_image\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._role) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.needRegen) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.backgroundImage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 1)
    }
    try { if let v = self._role {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 3)
    }
    if self.needRegen != false {
      try visitor.visitSingularBoolField(value: self.needRegen, fieldNumber: 4)
    }
    if !self.backgroundImage.isEmpty {
      try visitor.visitSingularStringField(value: self.backgroundImage, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateStoryRoleDetailRequest, rhs: Rankquantity_Voyager_Api_UpdateStoryRoleDetailRequest) -> Bool {
    if lhs.roleID != rhs.roleID {return false}
    if lhs._role != rhs._role {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.needRegen != rhs.needRegen {return false}
    if lhs.backgroundImage != rhs.backgroundImage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateStoryRoleDetailResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateStoryRoleDetailResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateStoryRoleDetailResponse, rhs: Rankquantity_Voyager_Api_UpdateStoryRoleDetailResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateStoryRoleAvatorRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateStoryRoleAvatorRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}role_id\0\u{1}avator\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.avator) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 1)
    }
    if !self.avator.isEmpty {
      try visitor.visitSingularStringField(value: self.avator, fieldNumber: 2)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateStoryRoleAvatorRequest, rhs: Rankquantity_Voyager_Api_UpdateStoryRoleAvatorRequest) -> Bool {
    if lhs.roleID != rhs.roleID {return false}
    if lhs.avator != rhs.avator {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateStoryRoleAvatorResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateStoryRoleAvatorResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateStoryRoleAvatorResponse, rhs: Rankquantity_Voyager_Api_UpdateStoryRoleAvatorResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetUserWithRoleChatListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserWithRoleChatListRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{3}story_id\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 2)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 3)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetUserWithRoleChatListRequest, rhs: Rankquantity_Voyager_Api_GetUserWithRoleChatListRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.storyID != rhs.storyID {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetUserWithRoleChatListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserWithRoleChatListResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}chats\0\u{1}total\0\u{1}offset\0\u{3}page_size\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.chats) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.chats.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.chats, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 4)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 5)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 6)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetUserWithRoleChatListResponse, rhs: Rankquantity_Voyager_Api_GetUserWithRoleChatListResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.chats != rhs.chats {return false}
    if lhs.total != rhs.total {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetUserCreatedStoryboardsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserCreatedStoryboardsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{3}story_id\0\u{1}stage\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.storyID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.stage) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.storyID != 0 {
      try visitor.visitSingularInt32Field(value: self.storyID, fieldNumber: 2)
    }
    if self.stage != 0 {
      try visitor.visitSingularInt32Field(value: self.stage, fieldNumber: 3)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 4)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetUserCreatedStoryboardsRequest, rhs: Rankquantity_Voyager_Api_GetUserCreatedStoryboardsRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.storyID != rhs.storyID {return false}
    if lhs.stage != rhs.stage {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetUserCreatedStoryboardsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserCreatedStoryboardsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}storyboards\0\u{1}total\0\u{3}have_more\0\u{1}offset\0\u{4}\u{2}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.storyboards) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.storyboards.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.storyboards, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 4)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 5)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 6)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetUserCreatedStoryboardsResponse, rhs: Rankquantity_Voyager_Api_GetUserCreatedStoryboardsResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.storyboards != rhs.storyboards {return false}
    if lhs.total != rhs.total {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetUserCreatedRolesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserCreatedRolesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{3}story_id\0\u{1}stage\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.storyID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.stage) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.storyID != 0 {
      try visitor.visitSingularInt32Field(value: self.storyID, fieldNumber: 2)
    }
    if self.stage != 0 {
      try visitor.visitSingularInt32Field(value: self.stage, fieldNumber: 3)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 4)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetUserCreatedRolesRequest, rhs: Rankquantity_Voyager_Api_GetUserCreatedRolesRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.storyID != rhs.storyID {return false}
    if lhs.stage != rhs.stage {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetUserCreatedRolesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserCreatedRolesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}roles\0\u{1}total\0\u{3}have_more\0\u{1}offset\0\u{4}\u{2}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.roles) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.roles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.roles, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 4)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 5)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 6)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetUserCreatedRolesResponse, rhs: Rankquantity_Voyager_Api_GetUserCreatedRolesResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.roles != rhs.roles {return false}
    if lhs.total != rhs.total {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_LikeStoryRoleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LikeStoryRoleRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}role_id\0\u{3}user_id\0\u{3}story_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_LikeStoryRoleRequest, rhs: Rankquantity_Voyager_Api_LikeStoryRoleRequest) -> Bool {
    if lhs.roleID != rhs.roleID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.storyID != rhs.storyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_LikeStoryRoleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LikeStoryRoleResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_LikeStoryRoleResponse, rhs: Rankquantity_Voyager_Api_LikeStoryRoleResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UnLikeStoryRoleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnLikeStoryRoleRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}role_id\0\u{3}user_id\0\u{3}story_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UnLikeStoryRoleRequest, rhs: Rankquantity_Voyager_Api_UnLikeStoryRoleRequest) -> Bool {
    if lhs.roleID != rhs.roleID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.storyID != rhs.storyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UnLikeStoryRoleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnLikeStoryRoleResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UnLikeStoryRoleResponse, rhs: Rankquantity_Voyager_Api_UnLikeStoryRoleResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_FollowStoryRoleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FollowStoryRoleRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}role_id\0\u{3}user_id\0\u{3}story_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_FollowStoryRoleRequest, rhs: Rankquantity_Voyager_Api_FollowStoryRoleRequest) -> Bool {
    if lhs.roleID != rhs.roleID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.storyID != rhs.storyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_FollowStoryRoleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FollowStoryRoleResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_FollowStoryRoleResponse, rhs: Rankquantity_Voyager_Api_FollowStoryRoleResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UnFollowStoryRoleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnFollowStoryRoleRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}role_id\0\u{3}user_id\0\u{3}story_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UnFollowStoryRoleRequest, rhs: Rankquantity_Voyager_Api_UnFollowStoryRoleRequest) -> Bool {
    if lhs.roleID != rhs.roleID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.storyID != rhs.storyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UnFollowStoryRoleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnFollowStoryRoleResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UnFollowStoryRoleResponse, rhs: Rankquantity_Voyager_Api_UnFollowStoryRoleResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_SearchStoriesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchStoriesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{1}keyword\0\u{1}offset\0\u{3}page_size\0\u{1}scope\0\u{4}\u{2}group_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.keyword) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.scope) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.groupID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if !self.keyword.isEmpty {
      try visitor.visitSingularStringField(value: self.keyword, fieldNumber: 2)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 3)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 4)
    }
    if self.scope != .protectScope {
      try visitor.visitSingularEnumField(value: self.scope, fieldNumber: 5)
    }
    if self.groupID != 0 {
      try visitor.visitSingularInt64Field(value: self.groupID, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_SearchStoriesRequest, rhs: Rankquantity_Voyager_Api_SearchStoriesRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.keyword != rhs.keyword {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.scope != rhs.scope {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_SearchStoriesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchStoriesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}stories\0\u{1}total\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.stories) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.stories.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.stories, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 4)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_SearchStoriesResponse, rhs: Rankquantity_Voyager_Api_SearchStoriesResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.stories != rhs.stories {return false}
    if lhs.total != rhs.total {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_SearchRolesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchRolesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{1}keyword\0\u{1}offset\0\u{3}page_size\0\u{1}scope\0\u{3}story_id\0\u{3}group_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.keyword) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.scope) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.groupID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if !self.keyword.isEmpty {
      try visitor.visitSingularStringField(value: self.keyword, fieldNumber: 2)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 3)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 4)
    }
    if self.scope != .protectScope {
      try visitor.visitSingularEnumField(value: self.scope, fieldNumber: 5)
    }
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 6)
    }
    if self.groupID != 0 {
      try visitor.visitSingularInt64Field(value: self.groupID, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_SearchRolesRequest, rhs: Rankquantity_Voyager_Api_SearchRolesRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.keyword != rhs.keyword {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.scope != rhs.scope {return false}
    if lhs.storyID != rhs.storyID {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_SearchRolesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchRolesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}roles\0\u{1}total\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.roles) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.roles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.roles, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 4)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_SearchRolesResponse, rhs: Rankquantity_Voyager_Api_SearchRolesResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.roles != rhs.roles {return false}
    if lhs.total != rhs.total {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_RestoreStoryboardRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RestoreStoryboardRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}storyboard_id\0\u{3}user_id\0\u{3}story_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyboardID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyboardID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyboardID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_RestoreStoryboardRequest, rhs: Rankquantity_Voyager_Api_RestoreStoryboardRequest) -> Bool {
    if lhs.storyboardID != rhs.storyboardID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.storyID != rhs.storyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_RestoreStoryboardResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RestoreStoryboardResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}store\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._store) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._store {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_RestoreStoryboardResponse, rhs: Rankquantity_Voyager_Api_RestoreStoryboardResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._store != rhs._store {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_StoryboardStageStore: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StoryboardStageStore"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}storyboard\0\u{1}sences\0\u{1}stage\0\u{3}last_update_time\0\u{1}version\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._storyboard) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._sences) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.stage) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.lastUpdateTime) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.version) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._storyboard {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._sences {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.stage != .unspecified {
      try visitor.visitSingularEnumField(value: self.stage, fieldNumber: 3)
    }
    if self.lastUpdateTime != 0 {
      try visitor.visitSingularInt64Field(value: self.lastUpdateTime, fieldNumber: 4)
    }
    if self.version != 0 {
      try visitor.visitSingularInt64Field(value: self.version, fieldNumber: 5)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_StoryboardStageStore, rhs: Rankquantity_Voyager_Api_StoryboardStageStore) -> Bool {
    if lhs._storyboard != rhs._storyboard {return false}
    if lhs._sences != rhs._sences {return false}
    if lhs.stage != rhs.stage {return false}
    if lhs.lastUpdateTime != rhs.lastUpdateTime {return false}
    if lhs.version != rhs.version {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetUserProfileRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserProfileRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetUserProfileRequest, rhs: Rankquantity_Voyager_Api_GetUserProfileRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetUserProfileResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserProfileResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}info\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetUserProfileResponse, rhs: Rankquantity_Voyager_Api_GetUserProfileResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._info != rhs._info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateUserProfileRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateUserProfileRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{3}background_image\0\u{1}avatar\0\u{1}name\0\u{1}description\0\u{1}location\0\u{1}email\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.backgroundImage) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.avatar) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.location) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.email) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if !self.backgroundImage.isEmpty {
      try visitor.visitSingularStringField(value: self.backgroundImage, fieldNumber: 2)
    }
    if !self.avatar.isEmpty {
      try visitor.visitSingularStringField(value: self.avatar, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 5)
    }
    if !self.location.isEmpty {
      try visitor.visitSingularStringField(value: self.location, fieldNumber: 6)
    }
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateUserProfileRequest, rhs: Rankquantity_Voyager_Api_UpdateUserProfileRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.backgroundImage != rhs.backgroundImage {return false}
    if lhs.avatar != rhs.avatar {return false}
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.location != rhs.location {return false}
    if lhs.email != rhs.email {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateUserProfileResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateUserProfileResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateUserProfileResponse, rhs: Rankquantity_Voyager_Api_UpdateUserProfileResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateUserBackgroundImageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateUserBackgroundImageRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{3}background_image\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.backgroundImage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if !self.backgroundImage.isEmpty {
      try visitor.visitSingularStringField(value: self.backgroundImage, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateUserBackgroundImageRequest, rhs: Rankquantity_Voyager_Api_UpdateUserBackgroundImageRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.backgroundImage != rhs.backgroundImage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateUserBackgroundImageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateUserBackgroundImageResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateUserBackgroundImageResponse, rhs: Rankquantity_Voyager_Api_UpdateUserBackgroundImageResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_CreateStoryRoleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateStoryRoleRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{1}role\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._role) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    try { if let v = self._role {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_CreateStoryRoleRequest, rhs: Rankquantity_Voyager_Api_CreateStoryRoleRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs._role != rhs._role {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_CreateStoryRoleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateStoryRoleResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_CreateStoryRoleResponse, rhs: Rankquantity_Voyager_Api_CreateStoryRoleResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryRoleDetailRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryRoleDetailRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}role_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryRoleDetailRequest, rhs: Rankquantity_Voyager_Api_GetStoryRoleDetailRequest) -> Bool {
    if lhs.roleID != rhs.roleID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryRoleDetailResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryRoleDetailResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}info\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryRoleDetailResponse, rhs: Rankquantity_Voyager_Api_GetStoryRoleDetailResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._info != rhs._info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_RenderStoryRoleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RenderStoryRoleRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}role_id\0\u{1}prompt\0\u{3}ref_images\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.prompt) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.refImages) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 1)
    }
    if !self.prompt.isEmpty {
      try visitor.visitSingularStringField(value: self.prompt, fieldNumber: 2)
    }
    if !self.refImages.isEmpty {
      try visitor.visitRepeatedStringField(value: self.refImages, fieldNumber: 3)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_RenderStoryRoleRequest, rhs: Rankquantity_Voyager_Api_RenderStoryRoleRequest) -> Bool {
    if lhs.roleID != rhs.roleID {return false}
    if lhs.prompt != rhs.prompt {return false}
    if lhs.refImages != rhs.refImages {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_RenderStoryRoleDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RenderStoryRoleDetail"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}role_id\0\u{3}gen_id\0\u{3}is_finished\0\u{3}role_description\0\u{3}role_character\0\u{3}role_behavior\0\u{3}role_goal\0\u{3}background_image\0\u{3}avatar_image\0\u{1}background\0\u{1}appearance\0\u{1}personality\0\u{3}ability_features\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.genID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isFinished) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.roleDescription) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.roleCharacter) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.roleBehavior) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.roleGoal) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.backgroundImage) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.avatarImage) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.background) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.appearance) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.personality) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.abilityFeatures) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 1)
    }
    if self.genID != 0 {
      try visitor.visitSingularInt64Field(value: self.genID, fieldNumber: 2)
    }
    if self.isFinished != false {
      try visitor.visitSingularBoolField(value: self.isFinished, fieldNumber: 3)
    }
    if !self.roleDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.roleDescription, fieldNumber: 4)
    }
    if !self.roleCharacter.isEmpty {
      try visitor.visitSingularStringField(value: self.roleCharacter, fieldNumber: 5)
    }
    if !self.roleBehavior.isEmpty {
      try visitor.visitSingularStringField(value: self.roleBehavior, fieldNumber: 6)
    }
    if !self.roleGoal.isEmpty {
      try visitor.visitSingularStringField(value: self.roleGoal, fieldNumber: 7)
    }
    if !self.backgroundImage.isEmpty {
      try visitor.visitSingularStringField(value: self.backgroundImage, fieldNumber: 8)
    }
    if !self.avatarImage.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarImage, fieldNumber: 9)
    }
    if !self.background.isEmpty {
      try visitor.visitSingularStringField(value: self.background, fieldNumber: 10)
    }
    if !self.appearance.isEmpty {
      try visitor.visitSingularStringField(value: self.appearance, fieldNumber: 11)
    }
    if !self.personality.isEmpty {
      try visitor.visitSingularStringField(value: self.personality, fieldNumber: 12)
    }
    if !self.abilityFeatures.isEmpty {
      try visitor.visitSingularStringField(value: self.abilityFeatures, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_RenderStoryRoleDetail, rhs: Rankquantity_Voyager_Api_RenderStoryRoleDetail) -> Bool {
    if lhs.roleID != rhs.roleID {return false}
    if lhs.genID != rhs.genID {return false}
    if lhs.isFinished != rhs.isFinished {return false}
    if lhs.roleDescription != rhs.roleDescription {return false}
    if lhs.roleCharacter != rhs.roleCharacter {return false}
    if lhs.roleBehavior != rhs.roleBehavior {return false}
    if lhs.roleGoal != rhs.roleGoal {return false}
    if lhs.backgroundImage != rhs.backgroundImage {return false}
    if lhs.avatarImage != rhs.avatarImage {return false}
    if lhs.background != rhs.background {return false}
    if lhs.appearance != rhs.appearance {return false}
    if lhs.personality != rhs.personality {return false}
    if lhs.abilityFeatures != rhs.abilityFeatures {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_RenderStoryRoleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RenderStoryRoleResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}detail\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._detail) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._detail {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_RenderStoryRoleResponse, rhs: Rankquantity_Voyager_Api_RenderStoryRoleResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._detail != rhs._detail {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_LikeStoryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LikeStoryRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_LikeStoryRequest, rhs: Rankquantity_Voyager_Api_LikeStoryRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_LikeStoryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LikeStoryResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_LikeStoryResponse, rhs: Rankquantity_Voyager_Api_LikeStoryResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UnLikeStoryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnLikeStoryRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UnLikeStoryRequest, rhs: Rankquantity_Voyager_Api_UnLikeStoryRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UnLikeStoryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnLikeStoryResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UnLikeStoryResponse, rhs: Rankquantity_Voyager_Api_UnLikeStoryResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
