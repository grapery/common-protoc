// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: story.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Common_StoryboardStage: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// 未指定
  case unspecified // = 0

  /// 创建
  case created // = 1

  /// 渲染完成
  case rendered // = 2

  /// 生成���片
  case genImage // = 3

  /// 生成视频
  case genVideo // = 4

  /// 生成音频
  case genAudio // = 5

  /// 生成文本
  case genText // = 6

  /// 完成
  case finished // = 7

  /// 失败
  case failed // = 8

  /// 发布
  case published // = 9
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .created
    case 2: self = .rendered
    case 3: self = .genImage
    case 4: self = .genVideo
    case 5: self = .genAudio
    case 6: self = .genText
    case 7: self = .finished
    case 8: self = .failed
    case 9: self = .published
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .created: return 1
    case .rendered: return 2
    case .genImage: return 3
    case .genVideo: return 4
    case .genAudio: return 5
    case .genText: return 6
    case .finished: return 7
    case .failed: return 8
    case .published: return 9
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Common_StoryboardStage] = [
    .unspecified,
    .created,
    .rendered,
    .genImage,
    .genVideo,
    .genAudio,
    .genText,
    .finished,
    .failed,
    .published,
  ]

}

public enum Common_RenderType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// 0: 原创
  case textUnspecified // = 0

  /// 1: 故事板
  case storyboard // = 1

  /// 2: 故事场景
  case storysence // = 2

  /// 3: 故事角色
  case storycharacters // = 3

  /// 4: 故事动作
  case storyaction // = 4

  /// 5: 故事设置
  case storysetting // = 5

  /// 6: 故事结局
  case storyending // = 6
  case UNRECOGNIZED(Int)

  public init() {
    self = .textUnspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .textUnspecified
    case 1: self = .storyboard
    case 2: self = .storysence
    case 3: self = .storycharacters
    case 4: self = .storyaction
    case 5: self = .storysetting
    case 6: self = .storyending
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .textUnspecified: return 0
    case .storyboard: return 1
    case .storysence: return 2
    case .storycharacters: return 3
    case .storyaction: return 4
    case .storysetting: return 5
    case .storyending: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Common_RenderType] = [
    .textUnspecified,
    .storyboard,
    .storysence,
    .storycharacters,
    .storyaction,
    .storysetting,
    .storyending,
  ]

}

public enum Common_StoryBoardGeneratingStage: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// 0: 未开始
  case unspecified // = 0

  /// 1: 生成中
  case generating // = 101

  /// 2: 生成完成
  case completed // = 102

  /// 3: 生成失败
  case failed // = 103

  /// 4: 生成图片
  case generatingImages // = 201

  /// 5: 图片生成完成
  case imagesCompleted // = 202

  /// 6: 图片生成失败
  case imagesFailed // = 203

  /// 7: 生成音频
  case generatingAudio // = 301

  /// 8: 音频生成完成
  case audioCompleted // = 302

  /// 9: 音频生成失败
  case audioFailed // = 303

  /// 10: 生成视频
  case generatingVideo // = 401

  /// 11: 视频生成完成
  case videoCompleted // = 402

  /// 12: 视频生成失败
  case videoFailed // = 403
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 101: self = .generating
    case 102: self = .completed
    case 103: self = .failed
    case 201: self = .generatingImages
    case 202: self = .imagesCompleted
    case 203: self = .imagesFailed
    case 301: self = .generatingAudio
    case 302: self = .audioCompleted
    case 303: self = .audioFailed
    case 401: self = .generatingVideo
    case 402: self = .videoCompleted
    case 403: self = .videoFailed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .generating: return 101
    case .completed: return 102
    case .failed: return 103
    case .generatingImages: return 201
    case .imagesCompleted: return 202
    case .imagesFailed: return 203
    case .generatingAudio: return 301
    case .audioCompleted: return 302
    case .audioFailed: return 303
    case .generatingVideo: return 401
    case .videoCompleted: return 402
    case .videoFailed: return 403
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Common_StoryBoardGeneratingStage] = [
    .unspecified,
    .generating,
    .completed,
    .failed,
    .generatingImages,
    .imagesCompleted,
    .imagesFailed,
    .generatingAudio,
    .audioCompleted,
    .audioFailed,
    .generatingVideo,
    .videoCompleted,
    .videoFailed,
  ]

}

public struct Common_Story: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var groupID: Int64 {
    get {return _storage._groupID}
    set {_uniqueStorage()._groupID = newValue}
  }

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var avatar: String {
    get {return _storage._avatar}
    set {_uniqueStorage()._avatar = newValue}
  }

  public var creatorID: Int64 {
    get {return _storage._creatorID}
    set {_uniqueStorage()._creatorID = newValue}
  }

  public var ownerID: Int64 {
    get {return _storage._ownerID}
    set {_uniqueStorage()._ownerID = newValue}
  }

  public var tags: [Common_Tags] {
    get {return _storage._tags}
    set {_uniqueStorage()._tags = newValue}
  }

  public var visable: Common_ScopeType {
    get {return _storage._visable}
    set {_uniqueStorage()._visable = newValue}
  }

  public var isAchieve: Bool {
    get {return _storage._isAchieve}
    set {_uniqueStorage()._isAchieve = newValue}
  }

  public var isClose: Bool {
    get {return _storage._isClose}
    set {_uniqueStorage()._isClose = newValue}
  }

  public var isAiGen: Bool {
    get {return _storage._isAiGen}
    set {_uniqueStorage()._isAiGen = newValue}
  }

  public var origin: String {
    get {return _storage._origin}
    set {_uniqueStorage()._origin = newValue}
  }

  public var rootBoardID: Int64 {
    get {return _storage._rootBoardID}
    set {_uniqueStorage()._rootBoardID = newValue}
  }

  public var desc: String {
    get {return _storage._desc}
    set {_uniqueStorage()._desc = newValue}
  }

  public var params: Common_StoryParams {
    get {return _storage._params ?? Common_StoryParams()}
    set {_uniqueStorage()._params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  public var hasParams: Bool {return _storage._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  public mutating func clearParams() {_uniqueStorage()._params = nil}

  public var status: Int32 {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  public var title: String {
    get {return _storage._title}
    set {_uniqueStorage()._title = newValue}
  }

  public var totalBoards: Int64 {
    get {return _storage._totalBoards}
    set {_uniqueStorage()._totalBoards = newValue}
  }

  public var isliked: Bool {
    get {return _storage._isliked}
    set {_uniqueStorage()._isliked = newValue}
  }

  public var iswatched: Bool {
    get {return _storage._iswatched}
    set {_uniqueStorage()._iswatched = newValue}
  }

  public var currentUserStatus: Common_WhatCurrentUserStatus {
    get {return _storage._currentUserStatus ?? Common_WhatCurrentUserStatus()}
    set {_uniqueStorage()._currentUserStatus = newValue}
  }
  /// Returns true if `currentUserStatus` has been explicitly set.
  public var hasCurrentUserStatus: Bool {return _storage._currentUserStatus != nil}
  /// Clears the value of `currentUserStatus`. Subsequent reads from it will return its default value.
  public mutating func clearCurrentUserStatus() {_uniqueStorage()._currentUserStatus = nil}

  public var ctime: Int64 {
    get {return _storage._ctime}
    set {_uniqueStorage()._ctime = newValue}
  }

  public var mtime: Int64 {
    get {return _storage._mtime}
    set {_uniqueStorage()._mtime = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Common_StoryParams: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var storyDescription: String = String()

  public var refImage: String = String()

  public var negativePrompt: String = String()

  public var prompt: String = String()

  public var comicLayoutStyle: String = String()

  public var comicStyle: String = String()

  public var background: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_StoryBoard: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var storyID: Int64 {
    get {return _storage._storyID}
    set {_uniqueStorage()._storyID = newValue}
  }

  public var num: Int64 {
    get {return _storage._num}
    set {_uniqueStorage()._num = newValue}
  }

  public var prevBoardID: Int64 {
    get {return _storage._prevBoardID}
    set {_uniqueStorage()._prevBoardID = newValue}
  }

  public var nextBoardID: [Int64] {
    get {return _storage._nextBoardID}
    set {_uniqueStorage()._nextBoardID = newValue}
  }

  public var creator: Int64 {
    get {return _storage._creator}
    set {_uniqueStorage()._creator = newValue}
  }

  public var storyBoardID: Int64 {
    get {return _storage._storyBoardID}
    set {_uniqueStorage()._storyBoardID = newValue}
  }

  public var title: String {
    get {return _storage._title}
    set {_uniqueStorage()._title = newValue}
  }

  public var content: String {
    get {return _storage._content}
    set {_uniqueStorage()._content = newValue}
  }

  public var isAiGen: Bool {
    get {return _storage._isAiGen}
    set {_uniqueStorage()._isAiGen = newValue}
  }

  public var roles: [Common_StoryRole] {
    get {return _storage._roles}
    set {_uniqueStorage()._roles = newValue}
  }

  public var backgroud: String {
    get {return _storage._backgroud}
    set {_uniqueStorage()._backgroud = newValue}
  }

  public var params: Common_StoryBoardParams {
    get {return _storage._params ?? Common_StoryBoardParams()}
    set {_uniqueStorage()._params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  public var hasParams: Bool {return _storage._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  public mutating func clearParams() {_uniqueStorage()._params = nil}

  public var sences: Common_StoryBoardSences {
    get {return _storage._sences ?? Common_StoryBoardSences()}
    set {_uniqueStorage()._sences = newValue}
  }
  /// Returns true if `sences` has been explicitly set.
  public var hasSences: Bool {return _storage._sences != nil}
  /// Clears the value of `sences`. Subsequent reads from it will return its default value.
  public mutating func clearSences() {_uniqueStorage()._sences = nil}

  public var isMultiBranch: Bool {
    get {return _storage._isMultiBranch}
    set {_uniqueStorage()._isMultiBranch = newValue}
  }

  public var ctime: Int64 {
    get {return _storage._ctime}
    set {_uniqueStorage()._ctime = newValue}
  }

  public var mtime: Int64 {
    get {return _storage._mtime}
    set {_uniqueStorage()._mtime = newValue}
  }

  public var currentUserStatus: Common_WhatCurrentUserStatus {
    get {return _storage._currentUserStatus ?? Common_WhatCurrentUserStatus()}
    set {_uniqueStorage()._currentUserStatus = newValue}
  }
  /// Returns true if `currentUserStatus` has been explicitly set.
  public var hasCurrentUserStatus: Bool {return _storage._currentUserStatus != nil}
  /// Clears the value of `currentUserStatus`. Subsequent reads from it will return its default value.
  public mutating func clearCurrentUserStatus() {_uniqueStorage()._currentUserStatus = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Common_StoryBoardSences: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var total: Int64 = 0

  public var list: [Common_StoryBoardSence] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_StoryRole: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var roleID: Int64 {
    get {return _storage._roleID}
    set {_uniqueStorage()._roleID = newValue}
  }

  public var storyID: Int64 {
    get {return _storage._storyID}
    set {_uniqueStorage()._storyID = newValue}
  }

  public var characterDescription: String {
    get {return _storage._characterDescription}
    set {_uniqueStorage()._characterDescription = newValue}
  }

  public var characterName: String {
    get {return _storage._characterName}
    set {_uniqueStorage()._characterName = newValue}
  }

  public var characterAvatar: String {
    get {return _storage._characterAvatar}
    set {_uniqueStorage()._characterAvatar = newValue}
  }

  public var characterID: String {
    get {return _storage._characterID}
    set {_uniqueStorage()._characterID = newValue}
  }

  public var characterType: String {
    get {return _storage._characterType}
    set {_uniqueStorage()._characterType = newValue}
  }

  public var characterPrompt: String {
    get {return _storage._characterPrompt}
    set {_uniqueStorage()._characterPrompt = newValue}
  }

  public var characterRefImages: [String] {
    get {return _storage._characterRefImages}
    set {_uniqueStorage()._characterRefImages = newValue}
  }

  public var creatorID: Int64 {
    get {return _storage._creatorID}
    set {_uniqueStorage()._creatorID = newValue}
  }

  public var status: Int32 {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  public var likeCount: Int64 {
    get {return _storage._likeCount}
    set {_uniqueStorage()._likeCount = newValue}
  }

  public var followCount: Int64 {
    get {return _storage._followCount}
    set {_uniqueStorage()._followCount = newValue}
  }

  public var storyboardNum: Int64 {
    get {return _storage._storyboardNum}
    set {_uniqueStorage()._storyboardNum = newValue}
  }

  public var version: Int64 {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  public var isliked: Bool {
    get {return _storage._isliked}
    set {_uniqueStorage()._isliked = newValue}
  }

  public var isfolllowed: Bool {
    get {return _storage._isfolllowed}
    set {_uniqueStorage()._isfolllowed = newValue}
  }

  public var ctime: Int64 {
    get {return _storage._ctime}
    set {_uniqueStorage()._ctime = newValue}
  }

  public var mtime: Int64 {
    get {return _storage._mtime}
    set {_uniqueStorage()._mtime = newValue}
  }

  public var currentUserStatus: Common_WhatCurrentUserStatus {
    get {return _storage._currentUserStatus ?? Common_WhatCurrentUserStatus()}
    set {_uniqueStorage()._currentUserStatus = newValue}
  }
  /// Returns true if `currentUserStatus` has been explicitly set.
  public var hasCurrentUserStatus: Bool {return _storage._currentUserStatus != nil}
  /// Clears the value of `currentUserStatus`. Subsequent reads from it will return its default value.
  public mutating func clearCurrentUserStatus() {_uniqueStorage()._currentUserStatus = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Common_StoryBoardParams: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var boardID: Int64 {
    get {return _storage._boardID}
    set {_uniqueStorage()._boardID = newValue}
  }

  public var storyDescription: String {
    get {return _storage._storyDescription}
    set {_uniqueStorage()._storyDescription = newValue}
  }

  public var numIds: Int32 {
    get {return _storage._numIds}
    set {_uniqueStorage()._numIds = newValue}
  }

  public var numSteps: Int32 {
    get {return _storage._numSteps}
    set {_uniqueStorage()._numSteps = newValue}
  }

  public var sdModel: String {
    get {return _storage._sdModel}
    set {_uniqueStorage()._sdModel = newValue}
  }

  public var refImage: String {
    get {return _storage._refImage}
    set {_uniqueStorage()._refImage = newValue}
  }

  public var comicLayoutStyle: String {
    get {return _storage._comicLayoutStyle}
    set {_uniqueStorage()._comicLayoutStyle = newValue}
  }

  public var comicStyle: String {
    get {return _storage._comicStyle}
    set {_uniqueStorage()._comicStyle = newValue}
  }

  public var negativePrompt: String {
    get {return _storage._negativePrompt}
    set {_uniqueStorage()._negativePrompt = newValue}
  }

  public var outputQuality: Int32 {
    get {return _storage._outputQuality}
    set {_uniqueStorage()._outputQuality = newValue}
  }

  public var guidanceScale: Float {
    get {return _storage._guidanceScale}
    set {_uniqueStorage()._guidanceScale = newValue}
  }

  public var outputFormat: Int32 {
    get {return _storage._outputFormat}
    set {_uniqueStorage()._outputFormat = newValue}
  }

  public var imageWidth: Int32 {
    get {return _storage._imageWidth}
    set {_uniqueStorage()._imageWidth = newValue}
  }

  public var imageHeight: Int32 {
    get {return _storage._imageHeight}
    set {_uniqueStorage()._imageHeight = newValue}
  }

  public var self32AttentionLayers: Int32 {
    get {return _storage._self32AttentionLayers}
    set {_uniqueStorage()._self32AttentionLayers = newValue}
  }

  public var self64AttentionLayers: Int32 {
    get {return _storage._self64AttentionLayers}
    set {_uniqueStorage()._self64AttentionLayers = newValue}
  }

  public var self128AttentionLayers: Int32 {
    get {return _storage._self128AttentionLayers}
    set {_uniqueStorage()._self128AttentionLayers = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Common_TimeLine: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rootID: Int64 = 0

  public var groupID: Int64 = 0

  public var projectID: Int64 = 0

  public var creatorID: Int64 = 0

  public var title: String = String()

  public var itemID: Int64 = 0

  public var ctime: Int64 = 0

  public var mtime: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_CreateStoryRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var title: String {
    get {return _storage._title}
    set {_uniqueStorage()._title = newValue}
  }

  public var shortDesc: String {
    get {return _storage._shortDesc}
    set {_uniqueStorage()._shortDesc = newValue}
  }

  public var creatorID: Int64 {
    get {return _storage._creatorID}
    set {_uniqueStorage()._creatorID = newValue}
  }

  public var ownerID: Int64 {
    get {return _storage._ownerID}
    set {_uniqueStorage()._ownerID = newValue}
  }

  public var groupID: Int64 {
    get {return _storage._groupID}
    set {_uniqueStorage()._groupID = newValue}
  }

  public var origin: String {
    get {return _storage._origin}
    set {_uniqueStorage()._origin = newValue}
  }

  public var status: Int32 {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  public var isAchieve: Bool {
    get {return _storage._isAchieve}
    set {_uniqueStorage()._isAchieve = newValue}
  }

  public var isClose: Bool {
    get {return _storage._isClose}
    set {_uniqueStorage()._isClose = newValue}
  }

  public var isAiGen: Bool {
    get {return _storage._isAiGen}
    set {_uniqueStorage()._isAiGen = newValue}
  }

  public var params: Common_StoryParams {
    get {return _storage._params ?? Common_StoryParams()}
    set {_uniqueStorage()._params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  public var hasParams: Bool {return _storage._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  public mutating func clearParams() {_uniqueStorage()._params = nil}

  public var roles: [Common_StoryRole] {
    get {return _storage._roles}
    set {_uniqueStorage()._roles = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Common_CreateStoryResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Int32 = 0

  public var message: String = String()

  public var data: Common_CreateStoryResponse.DataMessage {
    get {return _data ?? Common_CreateStoryResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var storyID: Int32 = 0

    public var boardID: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Common_CreateStoryResponse.DataMessage? = nil
}

public struct Common_UpdateStoryRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var shortDesc: String = String()

  public var origin: String = String()

  public var status: Int32 = 0

  public var isAchieve: Bool = false

  public var isClose: Bool = false

  public var isAiGen: Bool = false

  public var params: Common_StoryParams {
    get {return _params ?? Common_StoryParams()}
    set {_params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  public var hasParams: Bool {return self._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  public mutating func clearParams() {self._params = nil}

  public var storyID: Int64 = 0

  public var roles: [Common_StoryRole] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _params: Common_StoryParams? = nil
}

public struct Common_UpdateStoryResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Int32 = 0

  public var message: String = String()

  public var data: Common_UpdateStoryResponse.DataMessage {
    get {return _data ?? Common_UpdateStoryResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var storyID: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Common_UpdateStoryResponse.DataMessage? = nil
}

public struct Common_GetStoryInfoRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var storyID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_GetStoryInfoResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Int32 = 0

  public var message: String = String()

  public var data: Common_GetStoryInfoResponse.DataMessage {
    get {return _data ?? Common_GetStoryInfoResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var info: Common_Story {
      get {return _info ?? Common_Story()}
      set {_info = newValue}
    }
    /// Returns true if `info` has been explicitly set.
    public var hasInfo: Bool {return self._info != nil}
    /// Clears the value of `info`. Subsequent reads from it will return its default value.
    public mutating func clearInfo() {self._info = nil}

    public var creator: Common_UserInfo {
      get {return _creator ?? Common_UserInfo()}
      set {_creator = newValue}
    }
    /// Returns true if `creator` has been explicitly set.
    public var hasCreator: Bool {return self._creator != nil}
    /// Clears the value of `creator`. Subsequent reads from it will return its default value.
    public mutating func clearCreator() {self._creator = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _info: Common_Story? = nil
    fileprivate var _creator: Common_UserInfo? = nil
  }

  public init() {}

  fileprivate var _data: Common_GetStoryInfoResponse.DataMessage? = nil
}

public struct Common_CreateStoryboardRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var board: Common_StoryBoard {
    get {return _board ?? Common_StoryBoard()}
    set {_board = newValue}
  }
  /// Returns true if `board` has been explicitly set.
  public var hasBoard: Bool {return self._board != nil}
  /// Clears the value of `board`. Subsequent reads from it will return its default value.
  public mutating func clearBoard() {self._board = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _board: Common_StoryBoard? = nil
}

public struct Common_CreateStoryboardResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Int32 = 0

  public var message: String = String()

  public var data: Common_CreateStoryboardResponse.DataMessage {
    get {return _data ?? Common_CreateStoryboardResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var boardID: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Common_CreateStoryboardResponse.DataMessage? = nil
}

public struct Common_GetStoryboardRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var boardID: Int64 = 0

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_GetStoryboardResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Int32 = 0

  public var message: String = String()

  public var data: Common_GetStoryboardResponse.DataMessage {
    get {return _data ?? Common_GetStoryboardResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var info: Common_StoryBoard {
      get {return _info ?? Common_StoryBoard()}
      set {_info = newValue}
    }
    /// Returns true if `info` has been explicitly set.
    public var hasInfo: Bool {return self._info != nil}
    /// Clears the value of `info`. Subsequent reads from it will return its default value.
    public mutating func clearInfo() {self._info = nil}

    public var creator: Common_UserInfo {
      get {return _creator ?? Common_UserInfo()}
      set {_creator = newValue}
    }
    /// Returns true if `creator` has been explicitly set.
    public var hasCreator: Bool {return self._creator != nil}
    /// Clears the value of `creator`. Subsequent reads from it will return its default value.
    public mutating func clearCreator() {self._creator = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _info: Common_StoryBoard? = nil
    fileprivate var _creator: Common_UserInfo? = nil
  }

  public init() {}

  fileprivate var _data: Common_GetStoryboardResponse.DataMessage? = nil
}

public struct Common_GetStoryboardsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var storyID: Int64 = 0

  public var timelineID: Int64 = 0

  public var startTime: Int64 = 0

  public var endTime: Int64 = 0

  public var userID: Int64 = 0

  public var isMultiBranch: Bool = false

  public var page: Int32 = 0

  public var pageSize: Int32 = 0

  public var orderBy: Common_MultiBranchOrderBy = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_StoryBoardActiveRole: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var roleID: Int64 = 0

  public var roleName: String = String()

  public var roleAvatar: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_StoryBoardActiveUser: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var userName: String = String()

  public var userAvatar: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_StoryBoardActive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var storyboard: Common_StoryBoard {
    get {return _storage._storyboard ?? Common_StoryBoard()}
    set {_uniqueStorage()._storyboard = newValue}
  }
  /// Returns true if `storyboard` has been explicitly set.
  public var hasStoryboard: Bool {return _storage._storyboard != nil}
  /// Clears the value of `storyboard`. Subsequent reads from it will return its default value.
  public mutating func clearStoryboard() {_uniqueStorage()._storyboard = nil}

  public var totalLikeCount: Int64 {
    get {return _storage._totalLikeCount}
    set {_uniqueStorage()._totalLikeCount = newValue}
  }

  public var totalCommentCount: Int64 {
    get {return _storage._totalCommentCount}
    set {_uniqueStorage()._totalCommentCount = newValue}
  }

  public var totalShareCount: Int64 {
    get {return _storage._totalShareCount}
    set {_uniqueStorage()._totalShareCount = newValue}
  }

  public var totalRenderCount: Int64 {
    get {return _storage._totalRenderCount}
    set {_uniqueStorage()._totalRenderCount = newValue}
  }

  public var totalForkCount: Int64 {
    get {return _storage._totalForkCount}
    set {_uniqueStorage()._totalForkCount = newValue}
  }

  public var users: [Common_StoryBoardActiveUser] {
    get {return _storage._users}
    set {_uniqueStorage()._users = newValue}
  }

  public var roles: [Common_StoryBoardActiveRole] {
    get {return _storage._roles}
    set {_uniqueStorage()._roles = newValue}
  }

  public var creator: Common_StoryBoardActiveUser {
    get {return _storage._creator ?? Common_StoryBoardActiveUser()}
    set {_uniqueStorage()._creator = newValue}
  }
  /// Returns true if `creator` has been explicitly set.
  public var hasCreator: Bool {return _storage._creator != nil}
  /// Clears the value of `creator`. Subsequent reads from it will return its default value.
  public mutating func clearCreator() {_uniqueStorage()._creator = nil}

  public var summary: Common_StorySummaryInfo {
    get {return _storage._summary ?? Common_StorySummaryInfo()}
    set {_uniqueStorage()._summary = newValue}
  }
  /// Returns true if `summary` has been explicitly set.
  public var hasSummary: Bool {return _storage._summary != nil}
  /// Clears the value of `summary`. Subsequent reads from it will return its default value.
  public mutating func clearSummary() {_uniqueStorage()._summary = nil}

  public var isliked: Bool {
    get {return _storage._isliked}
    set {_uniqueStorage()._isliked = newValue}
  }

  public var mtime: Int64 {
    get {return _storage._mtime}
    set {_uniqueStorage()._mtime = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Common_StorySummaryInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var storyID: Int64 = 0

  public var storyTitle: String = String()

  public var storyAvatar: String = String()

  public var storyDescription: String = String()

  public var storyCover: String = String()

  public var storyTags: String = String()

  public var createTime: Int64 = 0

  public var createUserID: Int64 = 0

  public var totalBoardCount: Int64 = 0

  public var totalLikeCount: Int64 = 0

  public var totalCommentCount: Int64 = 0

  public var totalShareCount: Int64 = 0

  public var totalRenderCount: Int64 = 0

  public var totalForkCount: Int64 = 0

  public var totalViewCount: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_GetStoryboardsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Int32 = 0

  public var message: String = String()

  public var data: Common_GetStoryboardsResponse.DataMessage {
    get {return _data ?? Common_GetStoryboardsResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var list: [Common_StoryBoardActive] = []

    public var isMultiBranch: Bool = false

    public var total: Int64 = 0

    public var offset: Int64 = 0

    public var pageSize: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Common_GetStoryboardsResponse.DataMessage? = nil
}

public struct Common_DelStoryboardRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var boardID: Int64 = 0

  public var storyID: Int64 = 0

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_DelStoryboardResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Int32 = 0

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_ForkStoryboardRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var prevBoardID: Int64 = 0

  public var storyID: Int64 = 0

  public var userID: Int64 = 0

  public var board: Common_StoryBoard {
    get {return _board ?? Common_StoryBoard()}
    set {_board = newValue}
  }
  /// Returns true if `board` has been explicitly set.
  public var hasBoard: Bool {return self._board != nil}
  /// Clears the value of `board`. Subsequent reads from it will return its default value.
  public mutating func clearBoard() {self._board = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _board: Common_StoryBoard? = nil
}

public struct Common_ForkStoryboardResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Int32 = 0

  public var message: String = String()

  public var data: Common_ForkStoryboardResponse.DataMessage {
    get {return _data ?? Common_ForkStoryboardResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var boardID: Int64 = 0

    public var storyID: Int64 = 0

    public var timelineID: Int64 = 0

    public var prevBoardID: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Common_ForkStoryboardResponse.DataMessage? = nil
}

public struct Common_UpdateStoryboardRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var boardID: Int64 = 0

  public var storyID: Int64 = 0

  public var userID: Int64 = 0

  public var params: Common_StoryBoardParams {
    get {return _params ?? Common_StoryBoardParams()}
    set {_params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  public var hasParams: Bool {return self._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  public mutating func clearParams() {self._params = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _params: Common_StoryBoardParams? = nil
}

public struct Common_UpdateStoryboardResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Int32 = 0

  public var message: String = String()

  public var data: Common_UpdateStoryboardResponse.DataMessage {
    get {return _data ?? Common_UpdateStoryboardResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var storyID: Int64 = 0

    public var boardID: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Common_UpdateStoryboardResponse.DataMessage? = nil
}

public struct Common_WatchStoryRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var storyID: Int64 = 0

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_WatchStoryResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Int32 = 0

  public var message: String = String()

  public var data: Common_WatchStoryResponse.DataMessage {
    get {return _data ?? Common_WatchStoryResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var storyID: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Common_WatchStoryResponse.DataMessage? = nil
}

public struct Common_LikeStoryboardRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var boardID: Int64 = 0

  public var userID: Int64 = 0

  public var storyID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_LikeStoryboardResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Int32 = 0

  public var message: String = String()

  public var data: Common_LikeStoryboardResponse.DataMessage {
    get {return _data ?? Common_LikeStoryboardResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var storyID: Int64 = 0

    public var boardID: Int64 = 0

    public var userID: Int64 = 0

    public var likeNum: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Common_LikeStoryboardResponse.DataMessage? = nil
}

public struct Common_UnLikeStoryboardRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var boardID: Int64 = 0

  public var userID: Int64 = 0

  public var storyID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_UnLikeStoryboardResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Int32 = 0

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_ShareStoryboardRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var boardID: Int64 = 0

  public var userID: Int64 = 0

  public var storyID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_ShareStoryboardResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Int32 = 0

  public var message: String = String()

  public var data: Common_ShareStoryboardResponse.DataMessage {
    get {return _data ?? Common_ShareStoryboardResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var storyID: Int64 = 0

    public var boardID: Int64 = 0

    public var userID: Int64 = 0

    public var shareNum: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Common_ShareStoryboardResponse.DataMessage? = nil
}

public struct Common_RenderStoryRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var storyID: Int64 = 0

  public var userID: Int64 = 0

  public var isRegenerate: Bool = false

  public var boardID: Int64 = 0

  public var renderType: Common_RenderType = .textUnspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_RenderStoryStructureValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var text: String = String()

  public var urls: [String] = []

  public var value: Int32 = 0

  public var nums: Int32 = 0

  public var extra: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_RenderStoryStructure: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 原始内容
  public var text: String = String()

  /// 解析结果
  public var data: Dictionary<String,Common_RenderStoryStructureValue> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_RenderStoryDetail: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var text: String = String()

  public var status: Int32 = 0

  public var urls: [String] = []

  public var storyID: Int64 = 0

  public var boardID: Int64 = 0

  public var userID: Int64 = 0

  public var renderType: Common_RenderType = .textUnspecified

  public var result: Dictionary<String,Common_RenderStoryStructure> = [:]

  public var timecost: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_RenderStoryResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Int32 = 0

  public var message: String = String()

  public var data: Common_RenderStoryDetail {
    get {return _data ?? Common_RenderStoryDetail()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _data: Common_RenderStoryDetail? = nil
}

public struct Common_RenderStoryboardRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var boardID: Int64 = 0

  public var storyID: Int64 = 0

  public var userID: Int64 = 0

  public var isRegenerate: Bool = false

  public var renderType: Common_RenderType = .textUnspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_RenderStoryboardDetail: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var text: String = String()

  public var status: Int32 = 0

  public var urls: [String] = []

  public var storyID: Int64 = 0

  public var boardID: Int64 = 0

  public var userID: Int64 = 0

  public var renderType: Common_RenderType = .textUnspecified

  public var result: Dictionary<String,Common_RenderStoryStructure> = [:]

  public var timecost: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_RenderStoryboardResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Int32 = 0

  public var message: String = String()

  public var data: Common_RenderStoryboardDetail {
    get {return _data ?? Common_RenderStoryboardDetail()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _data: Common_RenderStoryboardDetail? = nil
}

public struct Common_GenStoryboardTextRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var boardID: Int64 = 0

  public var storyID: Int64 = 0

  public var userID: Int64 = 0

  public var renderType: Common_RenderType = .textUnspecified

  public var prompt: String = String()

  public var title: String = String()

  public var description_p: String = String()

  public var senceNum: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_GenStoryboardTextResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Int32 = 0

  public var message: String = String()

  public var data: Common_RenderStoryboardDetail {
    get {return _data ?? Common_RenderStoryboardDetail()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _data: Common_RenderStoryboardDetail? = nil
}

public struct Common_GenStoryboardImagesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var boardID: Int64 = 0

  public var storyID: Int64 = 0

  public var userID: Int64 = 0

  public var isRegenerate: Bool = false

  public var renderType: Common_RenderType = .textUnspecified

  public var senceID: Int32 = 0

  public var senceNameKey: String = String()

  public var prompt: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_GenStoryboardImagesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Int32 = 0

  public var message: String = String()

  public var data: Common_RenderStoryboardDetail {
    get {return _data ?? Common_RenderStoryboardDetail()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _data: Common_RenderStoryboardDetail? = nil
}

public struct Common_FetchGroupStorysRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var groupID: Int64 = 0

  public var userID: Int64 = 0

  public var page: Int32 = 0

  public var pageSize: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_FetchGroupStorysResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Int32 = 0

  public var message: String = String()

  public var data: Common_FetchGroupStorysResponse.DataMessage {
    get {return _data ?? Common_FetchGroupStorysResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var list: [Common_Story] = []

    public var creator: [Common_UserInfo] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Common_FetchGroupStorysResponse.DataMessage? = nil
}

public struct Common_GetStoryRenderRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var storyID: Int64 = 0

  public var renderStatus: Int32 = 0

  public var renderType: Int32 = 0

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_GetStoryRenderResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Int32 = 0

  public var message: String = String()

  public var data: Common_GetStoryRenderResponse.DataMessage {
    get {return _data ?? Common_GetStoryRenderResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var list: [Common_RenderStoryDetail] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Common_GetStoryRenderResponse.DataMessage? = nil
}

public struct Common_GetStoryBoardRenderRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var boardID: Int64 = 0

  public var renderStatus: Int32 = 0

  public var renderType: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_GetStoryBoardRenderResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Int32 = 0

  public var message: String = String()

  public var data: Common_GetStoryBoardRenderResponse.DataMessage {
    get {return _data ?? Common_GetStoryBoardRenderResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var list: [Common_RenderStoryboardDetail] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Common_GetStoryBoardRenderResponse.DataMessage? = nil
}

public struct Common_ContinueRenderStoryRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var storyID: Int64 = 0

  public var prevBoardID: Int64 = 0

  public var userID: Int64 = 0

  public var renderType: Common_RenderType = .textUnspecified

  public var prompt: String = String()

  public var title: String = String()

  public var description_p: String = String()

  public var background: String = String()

  public var roles: [Common_StoryRole] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_ContinueRenderStoryResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Int32 = 0

  public var message: String = String()

  public var data: Common_RenderStoryDetail {
    get {return _data ?? Common_RenderStoryDetail()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _data: Common_RenderStoryDetail? = nil
}

public struct Common_RenderStoryRolesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var storyID: Int64 = 0

  public var boardID: Int64 = 0

  public var userID: Int64 = 0

  public var prompt: String = String()

  public var background: String = String()

  public var params: Common_StoryRole {
    get {return _params ?? Common_StoryRole()}
    set {_params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  public var hasParams: Bool {return self._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  public mutating func clearParams() {self._params = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _params: Common_StoryRole? = nil
}

public struct Common_RenderStoryRolesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Int32 = 0

  public var message: String = String()

  public var list: [Common_StoryRole] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_RenderStoryRoleDetailRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var roleID: Int64 = 0

  public var role: Common_StoryRole {
    get {return _role ?? Common_StoryRole()}
    set {_role = newValue}
  }
  /// Returns true if `role` has been explicitly set.
  public var hasRole: Bool {return self._role != nil}
  /// Clears the value of `role`. Subsequent reads from it will return its default value.
  public mutating func clearRole() {self._role = nil}

  public var prompt: String = String()

  public var background: String = String()

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _role: Common_StoryRole? = nil
}

public struct Common_RenderStoryRoleDetailResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Int32 = 0

  public var message: String = String()

  public var role: Common_StoryRole {
    get {return _role ?? Common_StoryRole()}
    set {_role = newValue}
  }
  /// Returns true if `role` has been explicitly set.
  public var hasRole: Bool {return self._role != nil}
  /// Clears the value of `role`. Subsequent reads from it will return its default value.
  public mutating func clearRole() {self._role = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _role: Common_StoryRole? = nil
}

public struct Common_UpdateStoryRoleRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var role: Common_StoryRole {
    get {return _role ?? Common_StoryRole()}
    set {_role = newValue}
  }
  /// Returns true if `role` has been explicitly set.
  public var hasRole: Bool {return self._role != nil}
  /// Clears the value of `role`. Subsequent reads from it will return its default value.
  public mutating func clearRole() {self._role = nil}

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _role: Common_StoryRole? = nil
}

public struct Common_UpdateStoryRoleResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Int32 = 0

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_GetStoryRolesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var storyID: Int64 = 0

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_GetStoryRolesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Int32 = 0

  public var message: String = String()

  public var data: Common_GetStoryRolesResponse.DataMessage {
    get {return _data ?? Common_GetStoryRolesResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var list: [Common_StoryRole] = []

    public var creator: [Common_UserInfo] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Common_GetStoryRolesResponse.DataMessage? = nil
}

public struct Common_GetStoryBoardRolesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var boardID: Int64 = 0

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_GetStoryBoardRolesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Int32 = 0

  public var message: String = String()

  public var data: Common_GetStoryBoardRolesResponse.DataMessage {
    get {return _data ?? Common_GetStoryBoardRolesResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var list: [Common_StoryRole] = []

    public var creator: [Common_UserInfo] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Common_GetStoryBoardRolesResponse.DataMessage? = nil
}

public struct Common_StoryBoardSence: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var senceID: Int64 {
    get {return _storage._senceID}
    set {_uniqueStorage()._senceID = newValue}
  }

  public var content: String {
    get {return _storage._content}
    set {_uniqueStorage()._content = newValue}
  }

  public var characterIds: [String] {
    get {return _storage._characterIds}
    set {_uniqueStorage()._characterIds = newValue}
  }

  public var creatorID: Int64 {
    get {return _storage._creatorID}
    set {_uniqueStorage()._creatorID = newValue}
  }

  public var storyID: Int64 {
    get {return _storage._storyID}
    set {_uniqueStorage()._storyID = newValue}
  }

  public var boardID: Int64 {
    get {return _storage._boardID}
    set {_uniqueStorage()._boardID = newValue}
  }

  public var imagePrompts: String {
    get {return _storage._imagePrompts}
    set {_uniqueStorage()._imagePrompts = newValue}
  }

  public var audioPrompts: String {
    get {return _storage._audioPrompts}
    set {_uniqueStorage()._audioPrompts = newValue}
  }

  public var videoPrompts: String {
    get {return _storage._videoPrompts}
    set {_uniqueStorage()._videoPrompts = newValue}
  }

  public var isGenerating: Int32 {
    get {return _storage._isGenerating}
    set {_uniqueStorage()._isGenerating = newValue}
  }

  public var genResult: String {
    get {return _storage._genResult}
    set {_uniqueStorage()._genResult = newValue}
  }

  public var images: [String] {
    get {return _storage._images}
    set {_uniqueStorage()._images = newValue}
  }

  public var audioURL: String {
    get {return _storage._audioURL}
    set {_uniqueStorage()._audioURL = newValue}
  }

  public var videoURL: String {
    get {return _storage._videoURL}
    set {_uniqueStorage()._videoURL = newValue}
  }

  public var status: Int32 {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  public var ctime: Int64 {
    get {return _storage._ctime}
    set {_uniqueStorage()._ctime = newValue}
  }

  public var mtime: Int64 {
    get {return _storage._mtime}
    set {_uniqueStorage()._mtime = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Common_GetStoryBoardSencesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var boardID: Int64 = 0

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_GetStoryBoardSencesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Int32 = 0

  public var message: String = String()

  public var data: Common_GetStoryBoardSencesResponse.DataMessage {
    get {return _data ?? Common_GetStoryBoardSencesResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var list: [Common_StoryBoardSence] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Common_GetStoryBoardSencesResponse.DataMessage? = nil
}

public struct Common_CreateStoryBoardSenceRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sence: Common_StoryBoardSence {
    get {return _sence ?? Common_StoryBoardSence()}
    set {_sence = newValue}
  }
  /// Returns true if `sence` has been explicitly set.
  public var hasSence: Bool {return self._sence != nil}
  /// Clears the value of `sence`. Subsequent reads from it will return its default value.
  public mutating func clearSence() {self._sence = nil}

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sence: Common_StoryBoardSence? = nil
}

public struct Common_CreateStoryBoardSenceResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Int32 = 0

  public var message: String = String()

  public var data: Common_CreateStoryBoardSenceResponse.DataMessage {
    get {return _data ?? Common_CreateStoryBoardSenceResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var senceID: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Common_CreateStoryBoardSenceResponse.DataMessage? = nil
}

public struct Common_UpdateStoryBoardSenceRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sence: Common_StoryBoardSence {
    get {return _sence ?? Common_StoryBoardSence()}
    set {_sence = newValue}
  }
  /// Returns true if `sence` has been explicitly set.
  public var hasSence: Bool {return self._sence != nil}
  /// Clears the value of `sence`. Subsequent reads from it will return its default value.
  public mutating func clearSence() {self._sence = nil}

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sence: Common_StoryBoardSence? = nil
}

public struct Common_UpdateStoryBoardSenceResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Int32 = 0

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_DeleteStoryBoardSenceRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var senceID: Int64 = 0

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_DeleteStoryBoardSenceResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Int32 = 0

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_RenderStoryBoardSenceRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var senceID: Int64 = 0

  public var userID: Int64 = 0

  public var boardID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_RenderStoryBoardSenceResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Int32 = 0

  public var message: String = String()

  public var generatingStage: Int32 = 0

  public var data: Common_StoryBoardSence {
    get {return _data ?? Common_StoryBoardSence()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _data: Common_StoryBoardSence? = nil
}

public struct Common_RenderStoryBoardSencesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var boardID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_RenderStoryBoardSencesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Int32 = 0

  public var message: String = String()

  public var generatingStage: Int32 = 0

  public var list: [Common_StoryBoardSence] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_GetStoryBoardSenceGenerateRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var senceID: Int64 = 0

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_GetStoryBoardSenceGenerateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Int32 = 0

  public var message: String = String()

  public var generatingStage: Int32 = 0

  public var data: Common_StoryBoardSence {
    get {return _data ?? Common_StoryBoardSence()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _data: Common_StoryBoardSence? = nil
}

public struct Common_GetStoryBoardGenerateRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var boardID: Int64 = 0

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_GetStoryBoardGenerateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Int32 = 0

  public var message: String = String()

  public var generatingStage: Int32 = 0

  public var list: [Common_StoryBoardSence] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "common"

extension Common_StoryboardStage: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STORYBOARD_STAGE_UNSPECIFIED"),
    1: .same(proto: "STORYBOARD_STAGE_CREATED"),
    2: .same(proto: "STORYBOARD_STAGE_RENDERED"),
    3: .same(proto: "STORYBOARD_STAGE_GEN_IMAGE"),
    4: .same(proto: "STORYBOARD_STAGE_GEN_VIDEO"),
    5: .same(proto: "STORYBOARD_STAGE_GEN_AUDIO"),
    6: .same(proto: "STORYBOARD_STAGE_GEN_TEXT"),
    7: .same(proto: "STORYBOARD_STAGE_FINISHED"),
    8: .same(proto: "STORYBOARD_STAGE_FAILED"),
    9: .same(proto: "STORYBOARD_STAGE_PUBLISHED"),
  ]
}

extension Common_RenderType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RENDER_TYPE_TEXT_UNSPECIFIED"),
    1: .same(proto: "RENDER_TYPE_STORYBOARD"),
    2: .same(proto: "RENDER_TYPE_STORYSENCE"),
    3: .same(proto: "RENDER_TYPE_STORYCHARACTERS"),
    4: .same(proto: "RENDER_TYPE_STORYACTION"),
    5: .same(proto: "RENDER_TYPE_STORYSETTING"),
    6: .same(proto: "RENDER_TYPE_STORYENDING"),
  ]
}

extension Common_StoryBoardGeneratingStage: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STORY_BOARD_GENERATING_STAGE_UNSPECIFIED"),
    101: .same(proto: "STORY_BOARD_GENERATING_STAGE_GENERATING"),
    102: .same(proto: "STORY_BOARD_GENERATING_STAGE_COMPLETED"),
    103: .same(proto: "STORY_BOARD_GENERATING_STAGE_FAILED"),
    201: .same(proto: "STORY_BOARD_GENERATING_STAGE_GENERATING_IMAGES"),
    202: .same(proto: "STORY_BOARD_GENERATING_STAGE_IMAGES_COMPLETED"),
    203: .same(proto: "STORY_BOARD_GENERATING_STAGE_IMAGES_FAILED"),
    301: .same(proto: "STORY_BOARD_GENERATING_STAGE_GENERATING_AUDIO"),
    302: .same(proto: "STORY_BOARD_GENERATING_STAGE_AUDIO_COMPLETED"),
    303: .same(proto: "STORY_BOARD_GENERATING_STAGE_AUDIO_FAILED"),
    401: .same(proto: "STORY_BOARD_GENERATING_STAGE_GENERATING_VIDEO"),
    402: .same(proto: "STORY_BOARD_GENERATING_STAGE_VIDEO_COMPLETED"),
    403: .same(proto: "STORY_BOARD_GENERATING_STAGE_VIDEO_FAILED"),
  ]
}

extension Common_Story: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Story"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "group_id"),
    3: .same(proto: "name"),
    4: .same(proto: "avatar"),
    5: .standard(proto: "creator_id"),
    6: .standard(proto: "owner_id"),
    7: .same(proto: "tags"),
    8: .same(proto: "visable"),
    9: .standard(proto: "is_achieve"),
    10: .standard(proto: "is_close"),
    11: .standard(proto: "is_ai_gen"),
    12: .same(proto: "origin"),
    13: .standard(proto: "root_board_id"),
    14: .same(proto: "desc"),
    15: .same(proto: "params"),
    16: .same(proto: "status"),
    17: .same(proto: "title"),
    18: .standard(proto: "total_boards"),
    19: .same(proto: "isliked"),
    20: .same(proto: "iswatched"),
    21: .standard(proto: "current_user_status"),
    25: .same(proto: "Ctime"),
    26: .same(proto: "Mtime"),
  ]

  fileprivate class _StorageClass {
    var _id: Int64 = 0
    var _groupID: Int64 = 0
    var _name: String = String()
    var _avatar: String = String()
    var _creatorID: Int64 = 0
    var _ownerID: Int64 = 0
    var _tags: [Common_Tags] = []
    var _visable: Common_ScopeType = .allPublic
    var _isAchieve: Bool = false
    var _isClose: Bool = false
    var _isAiGen: Bool = false
    var _origin: String = String()
    var _rootBoardID: Int64 = 0
    var _desc: String = String()
    var _params: Common_StoryParams? = nil
    var _status: Int32 = 0
    var _title: String = String()
    var _totalBoards: Int64 = 0
    var _isliked: Bool = false
    var _iswatched: Bool = false
    var _currentUserStatus: Common_WhatCurrentUserStatus? = nil
    var _ctime: Int64 = 0
    var _mtime: Int64 = 0

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _groupID = source._groupID
      _name = source._name
      _avatar = source._avatar
      _creatorID = source._creatorID
      _ownerID = source._ownerID
      _tags = source._tags
      _visable = source._visable
      _isAchieve = source._isAchieve
      _isClose = source._isClose
      _isAiGen = source._isAiGen
      _origin = source._origin
      _rootBoardID = source._rootBoardID
      _desc = source._desc
      _params = source._params
      _status = source._status
      _title = source._title
      _totalBoards = source._totalBoards
      _isliked = source._isliked
      _iswatched = source._iswatched
      _currentUserStatus = source._currentUserStatus
      _ctime = source._ctime
      _mtime = source._mtime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularInt64Field(value: &_storage._groupID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._avatar) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._creatorID) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._ownerID) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._tags) }()
        case 8: try { try decoder.decodeSingularEnumField(value: &_storage._visable) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._isAchieve) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._isClose) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._isAiGen) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._origin) }()
        case 13: try { try decoder.decodeSingularInt64Field(value: &_storage._rootBoardID) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._desc) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._params) }()
        case 16: try { try decoder.decodeSingularInt32Field(value: &_storage._status) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._title) }()
        case 18: try { try decoder.decodeSingularInt64Field(value: &_storage._totalBoards) }()
        case 19: try { try decoder.decodeSingularBoolField(value: &_storage._isliked) }()
        case 20: try { try decoder.decodeSingularBoolField(value: &_storage._iswatched) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._currentUserStatus) }()
        case 25: try { try decoder.decodeSingularInt64Field(value: &_storage._ctime) }()
        case 26: try { try decoder.decodeSingularInt64Field(value: &_storage._mtime) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._id != 0 {
        try visitor.visitSingularInt64Field(value: _storage._id, fieldNumber: 1)
      }
      if _storage._groupID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._groupID, fieldNumber: 2)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 3)
      }
      if !_storage._avatar.isEmpty {
        try visitor.visitSingularStringField(value: _storage._avatar, fieldNumber: 4)
      }
      if _storage._creatorID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._creatorID, fieldNumber: 5)
      }
      if _storage._ownerID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._ownerID, fieldNumber: 6)
      }
      if !_storage._tags.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tags, fieldNumber: 7)
      }
      if _storage._visable != .allPublic {
        try visitor.visitSingularEnumField(value: _storage._visable, fieldNumber: 8)
      }
      if _storage._isAchieve != false {
        try visitor.visitSingularBoolField(value: _storage._isAchieve, fieldNumber: 9)
      }
      if _storage._isClose != false {
        try visitor.visitSingularBoolField(value: _storage._isClose, fieldNumber: 10)
      }
      if _storage._isAiGen != false {
        try visitor.visitSingularBoolField(value: _storage._isAiGen, fieldNumber: 11)
      }
      if !_storage._origin.isEmpty {
        try visitor.visitSingularStringField(value: _storage._origin, fieldNumber: 12)
      }
      if _storage._rootBoardID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._rootBoardID, fieldNumber: 13)
      }
      if !_storage._desc.isEmpty {
        try visitor.visitSingularStringField(value: _storage._desc, fieldNumber: 14)
      }
      try { if let v = _storage._params {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      if _storage._status != 0 {
        try visitor.visitSingularInt32Field(value: _storage._status, fieldNumber: 16)
      }
      if !_storage._title.isEmpty {
        try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 17)
      }
      if _storage._totalBoards != 0 {
        try visitor.visitSingularInt64Field(value: _storage._totalBoards, fieldNumber: 18)
      }
      if _storage._isliked != false {
        try visitor.visitSingularBoolField(value: _storage._isliked, fieldNumber: 19)
      }
      if _storage._iswatched != false {
        try visitor.visitSingularBoolField(value: _storage._iswatched, fieldNumber: 20)
      }
      try { if let v = _storage._currentUserStatus {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      if _storage._ctime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._ctime, fieldNumber: 25)
      }
      if _storage._mtime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._mtime, fieldNumber: 26)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_Story, rhs: Common_Story) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._groupID != rhs_storage._groupID {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._avatar != rhs_storage._avatar {return false}
        if _storage._creatorID != rhs_storage._creatorID {return false}
        if _storage._ownerID != rhs_storage._ownerID {return false}
        if _storage._tags != rhs_storage._tags {return false}
        if _storage._visable != rhs_storage._visable {return false}
        if _storage._isAchieve != rhs_storage._isAchieve {return false}
        if _storage._isClose != rhs_storage._isClose {return false}
        if _storage._isAiGen != rhs_storage._isAiGen {return false}
        if _storage._origin != rhs_storage._origin {return false}
        if _storage._rootBoardID != rhs_storage._rootBoardID {return false}
        if _storage._desc != rhs_storage._desc {return false}
        if _storage._params != rhs_storage._params {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._totalBoards != rhs_storage._totalBoards {return false}
        if _storage._isliked != rhs_storage._isliked {return false}
        if _storage._iswatched != rhs_storage._iswatched {return false}
        if _storage._currentUserStatus != rhs_storage._currentUserStatus {return false}
        if _storage._ctime != rhs_storage._ctime {return false}
        if _storage._mtime != rhs_storage._mtime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_StoryParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StoryParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "StoryDescription"),
    2: .same(proto: "RefImage"),
    3: .same(proto: "NegativePrompt"),
    4: .same(proto: "prompt"),
    5: .same(proto: "ComicLayoutStyle"),
    6: .same(proto: "ComicStyle"),
    7: .same(proto: "background"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.storyDescription) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.refImage) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.negativePrompt) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.prompt) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.comicLayoutStyle) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.comicStyle) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.background) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.storyDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.storyDescription, fieldNumber: 1)
    }
    if !self.refImage.isEmpty {
      try visitor.visitSingularStringField(value: self.refImage, fieldNumber: 2)
    }
    if !self.negativePrompt.isEmpty {
      try visitor.visitSingularStringField(value: self.negativePrompt, fieldNumber: 3)
    }
    if !self.prompt.isEmpty {
      try visitor.visitSingularStringField(value: self.prompt, fieldNumber: 4)
    }
    if !self.comicLayoutStyle.isEmpty {
      try visitor.visitSingularStringField(value: self.comicLayoutStyle, fieldNumber: 5)
    }
    if !self.comicStyle.isEmpty {
      try visitor.visitSingularStringField(value: self.comicStyle, fieldNumber: 6)
    }
    if !self.background.isEmpty {
      try visitor.visitSingularStringField(value: self.background, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_StoryParams, rhs: Common_StoryParams) -> Bool {
    if lhs.storyDescription != rhs.storyDescription {return false}
    if lhs.refImage != rhs.refImage {return false}
    if lhs.negativePrompt != rhs.negativePrompt {return false}
    if lhs.prompt != rhs.prompt {return false}
    if lhs.comicLayoutStyle != rhs.comicLayoutStyle {return false}
    if lhs.comicStyle != rhs.comicStyle {return false}
    if lhs.background != rhs.background {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_StoryBoard: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StoryBoard"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "story_id"),
    2: .same(proto: "num"),
    3: .standard(proto: "prev_board_id"),
    4: .standard(proto: "next_board_id"),
    5: .same(proto: "creator"),
    6: .standard(proto: "story_board_id"),
    8: .same(proto: "title"),
    9: .same(proto: "content"),
    11: .standard(proto: "is_ai_gen"),
    12: .same(proto: "roles"),
    13: .same(proto: "backgroud"),
    15: .same(proto: "params"),
    16: .same(proto: "sences"),
    17: .standard(proto: "is_multi_branch"),
    19: .same(proto: "Ctime"),
    20: .same(proto: "Mtime"),
    21: .standard(proto: "current_user_status"),
  ]

  fileprivate class _StorageClass {
    var _storyID: Int64 = 0
    var _num: Int64 = 0
    var _prevBoardID: Int64 = 0
    var _nextBoardID: [Int64] = []
    var _creator: Int64 = 0
    var _storyBoardID: Int64 = 0
    var _title: String = String()
    var _content: String = String()
    var _isAiGen: Bool = false
    var _roles: [Common_StoryRole] = []
    var _backgroud: String = String()
    var _params: Common_StoryBoardParams? = nil
    var _sences: Common_StoryBoardSences? = nil
    var _isMultiBranch: Bool = false
    var _ctime: Int64 = 0
    var _mtime: Int64 = 0
    var _currentUserStatus: Common_WhatCurrentUserStatus? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _storyID = source._storyID
      _num = source._num
      _prevBoardID = source._prevBoardID
      _nextBoardID = source._nextBoardID
      _creator = source._creator
      _storyBoardID = source._storyBoardID
      _title = source._title
      _content = source._content
      _isAiGen = source._isAiGen
      _roles = source._roles
      _backgroud = source._backgroud
      _params = source._params
      _sences = source._sences
      _isMultiBranch = source._isMultiBranch
      _ctime = source._ctime
      _mtime = source._mtime
      _currentUserStatus = source._currentUserStatus
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._storyID) }()
        case 2: try { try decoder.decodeSingularInt64Field(value: &_storage._num) }()
        case 3: try { try decoder.decodeSingularInt64Field(value: &_storage._prevBoardID) }()
        case 4: try { try decoder.decodeRepeatedInt64Field(value: &_storage._nextBoardID) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._creator) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._storyBoardID) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._title) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._content) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._isAiGen) }()
        case 12: try { try decoder.decodeRepeatedMessageField(value: &_storage._roles) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._backgroud) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._params) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._sences) }()
        case 17: try { try decoder.decodeSingularBoolField(value: &_storage._isMultiBranch) }()
        case 19: try { try decoder.decodeSingularInt64Field(value: &_storage._ctime) }()
        case 20: try { try decoder.decodeSingularInt64Field(value: &_storage._mtime) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._currentUserStatus) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._storyID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._storyID, fieldNumber: 1)
      }
      if _storage._num != 0 {
        try visitor.visitSingularInt64Field(value: _storage._num, fieldNumber: 2)
      }
      if _storage._prevBoardID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._prevBoardID, fieldNumber: 3)
      }
      if !_storage._nextBoardID.isEmpty {
        try visitor.visitPackedInt64Field(value: _storage._nextBoardID, fieldNumber: 4)
      }
      if _storage._creator != 0 {
        try visitor.visitSingularInt64Field(value: _storage._creator, fieldNumber: 5)
      }
      if _storage._storyBoardID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._storyBoardID, fieldNumber: 6)
      }
      if !_storage._title.isEmpty {
        try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 8)
      }
      if !_storage._content.isEmpty {
        try visitor.visitSingularStringField(value: _storage._content, fieldNumber: 9)
      }
      if _storage._isAiGen != false {
        try visitor.visitSingularBoolField(value: _storage._isAiGen, fieldNumber: 11)
      }
      if !_storage._roles.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._roles, fieldNumber: 12)
      }
      if !_storage._backgroud.isEmpty {
        try visitor.visitSingularStringField(value: _storage._backgroud, fieldNumber: 13)
      }
      try { if let v = _storage._params {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._sences {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      if _storage._isMultiBranch != false {
        try visitor.visitSingularBoolField(value: _storage._isMultiBranch, fieldNumber: 17)
      }
      if _storage._ctime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._ctime, fieldNumber: 19)
      }
      if _storage._mtime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._mtime, fieldNumber: 20)
      }
      try { if let v = _storage._currentUserStatus {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_StoryBoard, rhs: Common_StoryBoard) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._storyID != rhs_storage._storyID {return false}
        if _storage._num != rhs_storage._num {return false}
        if _storage._prevBoardID != rhs_storage._prevBoardID {return false}
        if _storage._nextBoardID != rhs_storage._nextBoardID {return false}
        if _storage._creator != rhs_storage._creator {return false}
        if _storage._storyBoardID != rhs_storage._storyBoardID {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._content != rhs_storage._content {return false}
        if _storage._isAiGen != rhs_storage._isAiGen {return false}
        if _storage._roles != rhs_storage._roles {return false}
        if _storage._backgroud != rhs_storage._backgroud {return false}
        if _storage._params != rhs_storage._params {return false}
        if _storage._sences != rhs_storage._sences {return false}
        if _storage._isMultiBranch != rhs_storage._isMultiBranch {return false}
        if _storage._ctime != rhs_storage._ctime {return false}
        if _storage._mtime != rhs_storage._mtime {return false}
        if _storage._currentUserStatus != rhs_storage._currentUserStatus {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_StoryBoardSences: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StoryBoardSences"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "total"),
    2: .same(proto: "list"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 1)
    }
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_StoryBoardSences, rhs: Common_StoryBoardSences) -> Bool {
    if lhs.total != rhs.total {return false}
    if lhs.list != rhs.list {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_StoryRole: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StoryRole"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "role_id"),
    2: .standard(proto: "story_id"),
    5: .standard(proto: "character_description"),
    6: .standard(proto: "character_name"),
    7: .standard(proto: "character_avatar"),
    8: .standard(proto: "character_id"),
    9: .standard(proto: "character_type"),
    10: .standard(proto: "character_prompt"),
    11: .standard(proto: "character_ref_images"),
    12: .standard(proto: "creator_id"),
    13: .same(proto: "status"),
    14: .standard(proto: "like_count"),
    15: .standard(proto: "follow_count"),
    16: .standard(proto: "storyboard_num"),
    17: .same(proto: "version"),
    18: .same(proto: "isliked"),
    19: .same(proto: "isfolllowed"),
    20: .same(proto: "Ctime"),
    21: .same(proto: "Mtime"),
    22: .standard(proto: "current_user_status"),
  ]

  fileprivate class _StorageClass {
    var _roleID: Int64 = 0
    var _storyID: Int64 = 0
    var _characterDescription: String = String()
    var _characterName: String = String()
    var _characterAvatar: String = String()
    var _characterID: String = String()
    var _characterType: String = String()
    var _characterPrompt: String = String()
    var _characterRefImages: [String] = []
    var _creatorID: Int64 = 0
    var _status: Int32 = 0
    var _likeCount: Int64 = 0
    var _followCount: Int64 = 0
    var _storyboardNum: Int64 = 0
    var _version: Int64 = 0
    var _isliked: Bool = false
    var _isfolllowed: Bool = false
    var _ctime: Int64 = 0
    var _mtime: Int64 = 0
    var _currentUserStatus: Common_WhatCurrentUserStatus? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _roleID = source._roleID
      _storyID = source._storyID
      _characterDescription = source._characterDescription
      _characterName = source._characterName
      _characterAvatar = source._characterAvatar
      _characterID = source._characterID
      _characterType = source._characterType
      _characterPrompt = source._characterPrompt
      _characterRefImages = source._characterRefImages
      _creatorID = source._creatorID
      _status = source._status
      _likeCount = source._likeCount
      _followCount = source._followCount
      _storyboardNum = source._storyboardNum
      _version = source._version
      _isliked = source._isliked
      _isfolllowed = source._isfolllowed
      _ctime = source._ctime
      _mtime = source._mtime
      _currentUserStatus = source._currentUserStatus
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._roleID) }()
        case 2: try { try decoder.decodeSingularInt64Field(value: &_storage._storyID) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._characterDescription) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._characterName) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._characterAvatar) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._characterID) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._characterType) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._characterPrompt) }()
        case 11: try { try decoder.decodeRepeatedStringField(value: &_storage._characterRefImages) }()
        case 12: try { try decoder.decodeSingularInt64Field(value: &_storage._creatorID) }()
        case 13: try { try decoder.decodeSingularInt32Field(value: &_storage._status) }()
        case 14: try { try decoder.decodeSingularInt64Field(value: &_storage._likeCount) }()
        case 15: try { try decoder.decodeSingularInt64Field(value: &_storage._followCount) }()
        case 16: try { try decoder.decodeSingularInt64Field(value: &_storage._storyboardNum) }()
        case 17: try { try decoder.decodeSingularInt64Field(value: &_storage._version) }()
        case 18: try { try decoder.decodeSingularBoolField(value: &_storage._isliked) }()
        case 19: try { try decoder.decodeSingularBoolField(value: &_storage._isfolllowed) }()
        case 20: try { try decoder.decodeSingularInt64Field(value: &_storage._ctime) }()
        case 21: try { try decoder.decodeSingularInt64Field(value: &_storage._mtime) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._currentUserStatus) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._roleID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._roleID, fieldNumber: 1)
      }
      if _storage._storyID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._storyID, fieldNumber: 2)
      }
      if !_storage._characterDescription.isEmpty {
        try visitor.visitSingularStringField(value: _storage._characterDescription, fieldNumber: 5)
      }
      if !_storage._characterName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._characterName, fieldNumber: 6)
      }
      if !_storage._characterAvatar.isEmpty {
        try visitor.visitSingularStringField(value: _storage._characterAvatar, fieldNumber: 7)
      }
      if !_storage._characterID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._characterID, fieldNumber: 8)
      }
      if !_storage._characterType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._characterType, fieldNumber: 9)
      }
      if !_storage._characterPrompt.isEmpty {
        try visitor.visitSingularStringField(value: _storage._characterPrompt, fieldNumber: 10)
      }
      if !_storage._characterRefImages.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._characterRefImages, fieldNumber: 11)
      }
      if _storage._creatorID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._creatorID, fieldNumber: 12)
      }
      if _storage._status != 0 {
        try visitor.visitSingularInt32Field(value: _storage._status, fieldNumber: 13)
      }
      if _storage._likeCount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._likeCount, fieldNumber: 14)
      }
      if _storage._followCount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._followCount, fieldNumber: 15)
      }
      if _storage._storyboardNum != 0 {
        try visitor.visitSingularInt64Field(value: _storage._storyboardNum, fieldNumber: 16)
      }
      if _storage._version != 0 {
        try visitor.visitSingularInt64Field(value: _storage._version, fieldNumber: 17)
      }
      if _storage._isliked != false {
        try visitor.visitSingularBoolField(value: _storage._isliked, fieldNumber: 18)
      }
      if _storage._isfolllowed != false {
        try visitor.visitSingularBoolField(value: _storage._isfolllowed, fieldNumber: 19)
      }
      if _storage._ctime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._ctime, fieldNumber: 20)
      }
      if _storage._mtime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._mtime, fieldNumber: 21)
      }
      try { if let v = _storage._currentUserStatus {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_StoryRole, rhs: Common_StoryRole) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._roleID != rhs_storage._roleID {return false}
        if _storage._storyID != rhs_storage._storyID {return false}
        if _storage._characterDescription != rhs_storage._characterDescription {return false}
        if _storage._characterName != rhs_storage._characterName {return false}
        if _storage._characterAvatar != rhs_storage._characterAvatar {return false}
        if _storage._characterID != rhs_storage._characterID {return false}
        if _storage._characterType != rhs_storage._characterType {return false}
        if _storage._characterPrompt != rhs_storage._characterPrompt {return false}
        if _storage._characterRefImages != rhs_storage._characterRefImages {return false}
        if _storage._creatorID != rhs_storage._creatorID {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._likeCount != rhs_storage._likeCount {return false}
        if _storage._followCount != rhs_storage._followCount {return false}
        if _storage._storyboardNum != rhs_storage._storyboardNum {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._isliked != rhs_storage._isliked {return false}
        if _storage._isfolllowed != rhs_storage._isfolllowed {return false}
        if _storage._ctime != rhs_storage._ctime {return false}
        if _storage._mtime != rhs_storage._mtime {return false}
        if _storage._currentUserStatus != rhs_storage._currentUserStatus {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_StoryBoardParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StoryBoardParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "board_id"),
    2: .same(proto: "StoryDescription"),
    3: .same(proto: "NumIds"),
    4: .same(proto: "NumSteps"),
    5: .same(proto: "SdModel"),
    6: .same(proto: "RefImage"),
    7: .same(proto: "ComicLayoutStyle"),
    8: .same(proto: "ComicStyle"),
    9: .same(proto: "NegativePrompt"),
    10: .same(proto: "OutputQuality"),
    11: .same(proto: "GuidanceScale"),
    13: .same(proto: "OutputFormat"),
    14: .same(proto: "ImageWidth"),
    15: .same(proto: "ImageHeight"),
    16: .same(proto: "Self32AttentionLayers"),
    17: .same(proto: "Self64AttentionLayers"),
    18: .same(proto: "Self128AttentionLayers"),
  ]

  fileprivate class _StorageClass {
    var _boardID: Int64 = 0
    var _storyDescription: String = String()
    var _numIds: Int32 = 0
    var _numSteps: Int32 = 0
    var _sdModel: String = String()
    var _refImage: String = String()
    var _comicLayoutStyle: String = String()
    var _comicStyle: String = String()
    var _negativePrompt: String = String()
    var _outputQuality: Int32 = 0
    var _guidanceScale: Float = 0
    var _outputFormat: Int32 = 0
    var _imageWidth: Int32 = 0
    var _imageHeight: Int32 = 0
    var _self32AttentionLayers: Int32 = 0
    var _self64AttentionLayers: Int32 = 0
    var _self128AttentionLayers: Int32 = 0

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _boardID = source._boardID
      _storyDescription = source._storyDescription
      _numIds = source._numIds
      _numSteps = source._numSteps
      _sdModel = source._sdModel
      _refImage = source._refImage
      _comicLayoutStyle = source._comicLayoutStyle
      _comicStyle = source._comicStyle
      _negativePrompt = source._negativePrompt
      _outputQuality = source._outputQuality
      _guidanceScale = source._guidanceScale
      _outputFormat = source._outputFormat
      _imageWidth = source._imageWidth
      _imageHeight = source._imageHeight
      _self32AttentionLayers = source._self32AttentionLayers
      _self64AttentionLayers = source._self64AttentionLayers
      _self128AttentionLayers = source._self128AttentionLayers
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._boardID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._storyDescription) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._numIds) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._numSteps) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._sdModel) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._refImage) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._comicLayoutStyle) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._comicStyle) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._negativePrompt) }()
        case 10: try { try decoder.decodeSingularInt32Field(value: &_storage._outputQuality) }()
        case 11: try { try decoder.decodeSingularFloatField(value: &_storage._guidanceScale) }()
        case 13: try { try decoder.decodeSingularInt32Field(value: &_storage._outputFormat) }()
        case 14: try { try decoder.decodeSingularInt32Field(value: &_storage._imageWidth) }()
        case 15: try { try decoder.decodeSingularInt32Field(value: &_storage._imageHeight) }()
        case 16: try { try decoder.decodeSingularInt32Field(value: &_storage._self32AttentionLayers) }()
        case 17: try { try decoder.decodeSingularInt32Field(value: &_storage._self64AttentionLayers) }()
        case 18: try { try decoder.decodeSingularInt32Field(value: &_storage._self128AttentionLayers) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._boardID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._boardID, fieldNumber: 1)
      }
      if !_storage._storyDescription.isEmpty {
        try visitor.visitSingularStringField(value: _storage._storyDescription, fieldNumber: 2)
      }
      if _storage._numIds != 0 {
        try visitor.visitSingularInt32Field(value: _storage._numIds, fieldNumber: 3)
      }
      if _storage._numSteps != 0 {
        try visitor.visitSingularInt32Field(value: _storage._numSteps, fieldNumber: 4)
      }
      if !_storage._sdModel.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sdModel, fieldNumber: 5)
      }
      if !_storage._refImage.isEmpty {
        try visitor.visitSingularStringField(value: _storage._refImage, fieldNumber: 6)
      }
      if !_storage._comicLayoutStyle.isEmpty {
        try visitor.visitSingularStringField(value: _storage._comicLayoutStyle, fieldNumber: 7)
      }
      if !_storage._comicStyle.isEmpty {
        try visitor.visitSingularStringField(value: _storage._comicStyle, fieldNumber: 8)
      }
      if !_storage._negativePrompt.isEmpty {
        try visitor.visitSingularStringField(value: _storage._negativePrompt, fieldNumber: 9)
      }
      if _storage._outputQuality != 0 {
        try visitor.visitSingularInt32Field(value: _storage._outputQuality, fieldNumber: 10)
      }
      if _storage._guidanceScale.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._guidanceScale, fieldNumber: 11)
      }
      if _storage._outputFormat != 0 {
        try visitor.visitSingularInt32Field(value: _storage._outputFormat, fieldNumber: 13)
      }
      if _storage._imageWidth != 0 {
        try visitor.visitSingularInt32Field(value: _storage._imageWidth, fieldNumber: 14)
      }
      if _storage._imageHeight != 0 {
        try visitor.visitSingularInt32Field(value: _storage._imageHeight, fieldNumber: 15)
      }
      if _storage._self32AttentionLayers != 0 {
        try visitor.visitSingularInt32Field(value: _storage._self32AttentionLayers, fieldNumber: 16)
      }
      if _storage._self64AttentionLayers != 0 {
        try visitor.visitSingularInt32Field(value: _storage._self64AttentionLayers, fieldNumber: 17)
      }
      if _storage._self128AttentionLayers != 0 {
        try visitor.visitSingularInt32Field(value: _storage._self128AttentionLayers, fieldNumber: 18)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_StoryBoardParams, rhs: Common_StoryBoardParams) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._boardID != rhs_storage._boardID {return false}
        if _storage._storyDescription != rhs_storage._storyDescription {return false}
        if _storage._numIds != rhs_storage._numIds {return false}
        if _storage._numSteps != rhs_storage._numSteps {return false}
        if _storage._sdModel != rhs_storage._sdModel {return false}
        if _storage._refImage != rhs_storage._refImage {return false}
        if _storage._comicLayoutStyle != rhs_storage._comicLayoutStyle {return false}
        if _storage._comicStyle != rhs_storage._comicStyle {return false}
        if _storage._negativePrompt != rhs_storage._negativePrompt {return false}
        if _storage._outputQuality != rhs_storage._outputQuality {return false}
        if _storage._guidanceScale != rhs_storage._guidanceScale {return false}
        if _storage._outputFormat != rhs_storage._outputFormat {return false}
        if _storage._imageWidth != rhs_storage._imageWidth {return false}
        if _storage._imageHeight != rhs_storage._imageHeight {return false}
        if _storage._self32AttentionLayers != rhs_storage._self32AttentionLayers {return false}
        if _storage._self64AttentionLayers != rhs_storage._self64AttentionLayers {return false}
        if _storage._self128AttentionLayers != rhs_storage._self128AttentionLayers {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_TimeLine: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TimeLine"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "root_id"),
    2: .standard(proto: "group_id"),
    3: .standard(proto: "project_id"),
    4: .standard(proto: "creator_id"),
    5: .same(proto: "title"),
    6: .standard(proto: "item_id"),
    9: .same(proto: "Ctime"),
    10: .same(proto: "Mtime"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.rootID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.groupID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.projectID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.creatorID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.itemID) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.ctime) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.mtime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rootID != 0 {
      try visitor.visitSingularInt64Field(value: self.rootID, fieldNumber: 1)
    }
    if self.groupID != 0 {
      try visitor.visitSingularInt64Field(value: self.groupID, fieldNumber: 2)
    }
    if self.projectID != 0 {
      try visitor.visitSingularInt64Field(value: self.projectID, fieldNumber: 3)
    }
    if self.creatorID != 0 {
      try visitor.visitSingularInt64Field(value: self.creatorID, fieldNumber: 4)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 5)
    }
    if self.itemID != 0 {
      try visitor.visitSingularInt64Field(value: self.itemID, fieldNumber: 6)
    }
    if self.ctime != 0 {
      try visitor.visitSingularInt64Field(value: self.ctime, fieldNumber: 9)
    }
    if self.mtime != 0 {
      try visitor.visitSingularInt64Field(value: self.mtime, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_TimeLine, rhs: Common_TimeLine) -> Bool {
    if lhs.rootID != rhs.rootID {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs.projectID != rhs.projectID {return false}
    if lhs.creatorID != rhs.creatorID {return false}
    if lhs.title != rhs.title {return false}
    if lhs.itemID != rhs.itemID {return false}
    if lhs.ctime != rhs.ctime {return false}
    if lhs.mtime != rhs.mtime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_CreateStoryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateStoryRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "title"),
    3: .standard(proto: "short_desc"),
    4: .standard(proto: "creator_id"),
    5: .standard(proto: "owner_id"),
    6: .standard(proto: "group_id"),
    7: .same(proto: "origin"),
    8: .same(proto: "status"),
    9: .standard(proto: "is_achieve"),
    10: .standard(proto: "is_close"),
    11: .standard(proto: "is_ai_gen"),
    12: .same(proto: "params"),
    13: .same(proto: "roles"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _title: String = String()
    var _shortDesc: String = String()
    var _creatorID: Int64 = 0
    var _ownerID: Int64 = 0
    var _groupID: Int64 = 0
    var _origin: String = String()
    var _status: Int32 = 0
    var _isAchieve: Bool = false
    var _isClose: Bool = false
    var _isAiGen: Bool = false
    var _params: Common_StoryParams? = nil
    var _roles: [Common_StoryRole] = []

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _title = source._title
      _shortDesc = source._shortDesc
      _creatorID = source._creatorID
      _ownerID = source._ownerID
      _groupID = source._groupID
      _origin = source._origin
      _status = source._status
      _isAchieve = source._isAchieve
      _isClose = source._isClose
      _isAiGen = source._isAiGen
      _params = source._params
      _roles = source._roles
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._title) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._shortDesc) }()
        case 4: try { try decoder.decodeSingularInt64Field(value: &_storage._creatorID) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._ownerID) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._groupID) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._origin) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._status) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._isAchieve) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._isClose) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._isAiGen) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._params) }()
        case 13: try { try decoder.decodeRepeatedMessageField(value: &_storage._roles) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._title.isEmpty {
        try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 2)
      }
      if !_storage._shortDesc.isEmpty {
        try visitor.visitSingularStringField(value: _storage._shortDesc, fieldNumber: 3)
      }
      if _storage._creatorID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._creatorID, fieldNumber: 4)
      }
      if _storage._ownerID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._ownerID, fieldNumber: 5)
      }
      if _storage._groupID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._groupID, fieldNumber: 6)
      }
      if !_storage._origin.isEmpty {
        try visitor.visitSingularStringField(value: _storage._origin, fieldNumber: 7)
      }
      if _storage._status != 0 {
        try visitor.visitSingularInt32Field(value: _storage._status, fieldNumber: 8)
      }
      if _storage._isAchieve != false {
        try visitor.visitSingularBoolField(value: _storage._isAchieve, fieldNumber: 9)
      }
      if _storage._isClose != false {
        try visitor.visitSingularBoolField(value: _storage._isClose, fieldNumber: 10)
      }
      if _storage._isAiGen != false {
        try visitor.visitSingularBoolField(value: _storage._isAiGen, fieldNumber: 11)
      }
      try { if let v = _storage._params {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if !_storage._roles.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._roles, fieldNumber: 13)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_CreateStoryRequest, rhs: Common_CreateStoryRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._shortDesc != rhs_storage._shortDesc {return false}
        if _storage._creatorID != rhs_storage._creatorID {return false}
        if _storage._ownerID != rhs_storage._ownerID {return false}
        if _storage._groupID != rhs_storage._groupID {return false}
        if _storage._origin != rhs_storage._origin {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._isAchieve != rhs_storage._isAchieve {return false}
        if _storage._isClose != rhs_storage._isClose {return false}
        if _storage._isAiGen != rhs_storage._isAiGen {return false}
        if _storage._params != rhs_storage._params {return false}
        if _storage._roles != rhs_storage._roles {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_CreateStoryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateStoryResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
    3: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_CreateStoryResponse, rhs: Common_CreateStoryResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_CreateStoryResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Common_CreateStoryResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "story_id"),
    2: .standard(proto: "board_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.boardID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt32Field(value: self.storyID, fieldNumber: 1)
    }
    if self.boardID != 0 {
      try visitor.visitSingularInt32Field(value: self.boardID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_CreateStoryResponse.DataMessage, rhs: Common_CreateStoryResponse.DataMessage) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.boardID != rhs.boardID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_UpdateStoryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateStoryRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "short_desc"),
    2: .same(proto: "origin"),
    3: .same(proto: "status"),
    4: .standard(proto: "is_achieve"),
    5: .standard(proto: "is_close"),
    6: .standard(proto: "is_ai_gen"),
    7: .same(proto: "params"),
    8: .standard(proto: "story_id"),
    10: .same(proto: "roles"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.shortDesc) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.origin) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.status) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isAchieve) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.isClose) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isAiGen) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._params) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.roles) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.shortDesc.isEmpty {
      try visitor.visitSingularStringField(value: self.shortDesc, fieldNumber: 1)
    }
    if !self.origin.isEmpty {
      try visitor.visitSingularStringField(value: self.origin, fieldNumber: 2)
    }
    if self.status != 0 {
      try visitor.visitSingularInt32Field(value: self.status, fieldNumber: 3)
    }
    if self.isAchieve != false {
      try visitor.visitSingularBoolField(value: self.isAchieve, fieldNumber: 4)
    }
    if self.isClose != false {
      try visitor.visitSingularBoolField(value: self.isClose, fieldNumber: 5)
    }
    if self.isAiGen != false {
      try visitor.visitSingularBoolField(value: self.isAiGen, fieldNumber: 6)
    }
    try { if let v = self._params {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 8)
    }
    if !self.roles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.roles, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_UpdateStoryRequest, rhs: Common_UpdateStoryRequest) -> Bool {
    if lhs.shortDesc != rhs.shortDesc {return false}
    if lhs.origin != rhs.origin {return false}
    if lhs.status != rhs.status {return false}
    if lhs.isAchieve != rhs.isAchieve {return false}
    if lhs.isClose != rhs.isClose {return false}
    if lhs.isAiGen != rhs.isAiGen {return false}
    if lhs._params != rhs._params {return false}
    if lhs.storyID != rhs.storyID {return false}
    if lhs.roles != rhs.roles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_UpdateStoryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateStoryResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
    3: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_UpdateStoryResponse, rhs: Common_UpdateStoryResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_UpdateStoryResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Common_UpdateStoryResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "story_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.storyID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt32Field(value: self.storyID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_UpdateStoryResponse.DataMessage, rhs: Common_UpdateStoryResponse.DataMessage) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_GetStoryInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryInfoRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "story_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_GetStoryInfoRequest, rhs: Common_GetStoryInfoRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_GetStoryInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryInfoResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
    4: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_GetStoryInfoResponse, rhs: Common_GetStoryInfoResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_GetStoryInfoResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Common_GetStoryInfoResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "info"),
    2: .same(proto: "creator"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._creator) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._creator {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_GetStoryInfoResponse.DataMessage, rhs: Common_GetStoryInfoResponse.DataMessage) -> Bool {
    if lhs._info != rhs._info {return false}
    if lhs._creator != rhs._creator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_CreateStoryboardRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateStoryboardRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "board"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._board) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._board {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_CreateStoryboardRequest, rhs: Common_CreateStoryboardRequest) -> Bool {
    if lhs._board != rhs._board {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_CreateStoryboardResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateStoryboardResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
    3: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_CreateStoryboardResponse, rhs: Common_CreateStoryboardResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_CreateStoryboardResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Common_CreateStoryboardResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "board_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.boardID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.boardID != 0 {
      try visitor.visitSingularInt64Field(value: self.boardID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_CreateStoryboardResponse.DataMessage, rhs: Common_CreateStoryboardResponse.DataMessage) -> Bool {
    if lhs.boardID != rhs.boardID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_GetStoryboardRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryboardRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "board_id"),
    2: .standard(proto: "user_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.boardID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.boardID != 0 {
      try visitor.visitSingularInt64Field(value: self.boardID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_GetStoryboardRequest, rhs: Common_GetStoryboardRequest) -> Bool {
    if lhs.boardID != rhs.boardID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_GetStoryboardResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryboardResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
    3: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_GetStoryboardResponse, rhs: Common_GetStoryboardResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_GetStoryboardResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Common_GetStoryboardResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "info"),
    2: .same(proto: "creator"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._creator) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._creator {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_GetStoryboardResponse.DataMessage, rhs: Common_GetStoryboardResponse.DataMessage) -> Bool {
    if lhs._info != rhs._info {return false}
    if lhs._creator != rhs._creator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_GetStoryboardsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryboardsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "story_id"),
    2: .standard(proto: "timeline_id"),
    4: .standard(proto: "start_time"),
    5: .standard(proto: "end_time"),
    6: .standard(proto: "user_id"),
    7: .standard(proto: "is_multi_branch"),
    8: .same(proto: "page"),
    9: .standard(proto: "page_size"),
    10: .standard(proto: "order_by"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.timelineID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.startTime) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.endTime) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.isMultiBranch) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.page) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 10: try { try decoder.decodeSingularEnumField(value: &self.orderBy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.timelineID != 0 {
      try visitor.visitSingularInt64Field(value: self.timelineID, fieldNumber: 2)
    }
    if self.startTime != 0 {
      try visitor.visitSingularInt64Field(value: self.startTime, fieldNumber: 4)
    }
    if self.endTime != 0 {
      try visitor.visitSingularInt64Field(value: self.endTime, fieldNumber: 5)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 6)
    }
    if self.isMultiBranch != false {
      try visitor.visitSingularBoolField(value: self.isMultiBranch, fieldNumber: 7)
    }
    if self.page != 0 {
      try visitor.visitSingularInt32Field(value: self.page, fieldNumber: 8)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 9)
    }
    if self.orderBy != .unspecified {
      try visitor.visitSingularEnumField(value: self.orderBy, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_GetStoryboardsRequest, rhs: Common_GetStoryboardsRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.timelineID != rhs.timelineID {return false}
    if lhs.startTime != rhs.startTime {return false}
    if lhs.endTime != rhs.endTime {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.isMultiBranch != rhs.isMultiBranch {return false}
    if lhs.page != rhs.page {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.orderBy != rhs.orderBy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_StoryBoardActiveRole: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StoryBoardActiveRole"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "role_id"),
    2: .standard(proto: "role_name"),
    3: .standard(proto: "role_avatar"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.roleName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.roleAvatar) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 1)
    }
    if !self.roleName.isEmpty {
      try visitor.visitSingularStringField(value: self.roleName, fieldNumber: 2)
    }
    if !self.roleAvatar.isEmpty {
      try visitor.visitSingularStringField(value: self.roleAvatar, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_StoryBoardActiveRole, rhs: Common_StoryBoardActiveRole) -> Bool {
    if lhs.roleID != rhs.roleID {return false}
    if lhs.roleName != rhs.roleName {return false}
    if lhs.roleAvatar != rhs.roleAvatar {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_StoryBoardActiveUser: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StoryBoardActiveUser"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .standard(proto: "user_name"),
    3: .standard(proto: "user_avatar"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.userAvatar) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 2)
    }
    if !self.userAvatar.isEmpty {
      try visitor.visitSingularStringField(value: self.userAvatar, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_StoryBoardActiveUser, rhs: Common_StoryBoardActiveUser) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.userName != rhs.userName {return false}
    if lhs.userAvatar != rhs.userAvatar {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_StoryBoardActive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StoryBoardActive"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "storyboard"),
    2: .standard(proto: "total_like_count"),
    3: .standard(proto: "total_comment_count"),
    4: .standard(proto: "total_share_count"),
    5: .standard(proto: "total_render_count"),
    6: .standard(proto: "total_fork_count"),
    7: .same(proto: "users"),
    8: .same(proto: "roles"),
    9: .same(proto: "creator"),
    10: .same(proto: "summary"),
    11: .same(proto: "isliked"),
    12: .same(proto: "mtime"),
  ]

  fileprivate class _StorageClass {
    var _storyboard: Common_StoryBoard? = nil
    var _totalLikeCount: Int64 = 0
    var _totalCommentCount: Int64 = 0
    var _totalShareCount: Int64 = 0
    var _totalRenderCount: Int64 = 0
    var _totalForkCount: Int64 = 0
    var _users: [Common_StoryBoardActiveUser] = []
    var _roles: [Common_StoryBoardActiveRole] = []
    var _creator: Common_StoryBoardActiveUser? = nil
    var _summary: Common_StorySummaryInfo? = nil
    var _isliked: Bool = false
    var _mtime: Int64 = 0

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _storyboard = source._storyboard
      _totalLikeCount = source._totalLikeCount
      _totalCommentCount = source._totalCommentCount
      _totalShareCount = source._totalShareCount
      _totalRenderCount = source._totalRenderCount
      _totalForkCount = source._totalForkCount
      _users = source._users
      _roles = source._roles
      _creator = source._creator
      _summary = source._summary
      _isliked = source._isliked
      _mtime = source._mtime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._storyboard) }()
        case 2: try { try decoder.decodeSingularInt64Field(value: &_storage._totalLikeCount) }()
        case 3: try { try decoder.decodeSingularInt64Field(value: &_storage._totalCommentCount) }()
        case 4: try { try decoder.decodeSingularInt64Field(value: &_storage._totalShareCount) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._totalRenderCount) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._totalForkCount) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._users) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._roles) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._creator) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._summary) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._isliked) }()
        case 12: try { try decoder.decodeSingularInt64Field(value: &_storage._mtime) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._storyboard {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if _storage._totalLikeCount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._totalLikeCount, fieldNumber: 2)
      }
      if _storage._totalCommentCount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._totalCommentCount, fieldNumber: 3)
      }
      if _storage._totalShareCount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._totalShareCount, fieldNumber: 4)
      }
      if _storage._totalRenderCount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._totalRenderCount, fieldNumber: 5)
      }
      if _storage._totalForkCount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._totalForkCount, fieldNumber: 6)
      }
      if !_storage._users.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._users, fieldNumber: 7)
      }
      if !_storage._roles.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._roles, fieldNumber: 8)
      }
      try { if let v = _storage._creator {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._summary {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if _storage._isliked != false {
        try visitor.visitSingularBoolField(value: _storage._isliked, fieldNumber: 11)
      }
      if _storage._mtime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._mtime, fieldNumber: 12)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_StoryBoardActive, rhs: Common_StoryBoardActive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._storyboard != rhs_storage._storyboard {return false}
        if _storage._totalLikeCount != rhs_storage._totalLikeCount {return false}
        if _storage._totalCommentCount != rhs_storage._totalCommentCount {return false}
        if _storage._totalShareCount != rhs_storage._totalShareCount {return false}
        if _storage._totalRenderCount != rhs_storage._totalRenderCount {return false}
        if _storage._totalForkCount != rhs_storage._totalForkCount {return false}
        if _storage._users != rhs_storage._users {return false}
        if _storage._roles != rhs_storage._roles {return false}
        if _storage._creator != rhs_storage._creator {return false}
        if _storage._summary != rhs_storage._summary {return false}
        if _storage._isliked != rhs_storage._isliked {return false}
        if _storage._mtime != rhs_storage._mtime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_StorySummaryInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StorySummaryInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "story_id"),
    2: .standard(proto: "story_title"),
    3: .standard(proto: "story_avatar"),
    4: .standard(proto: "story_description"),
    5: .standard(proto: "story_cover"),
    6: .standard(proto: "story_tags"),
    7: .standard(proto: "create_time"),
    8: .standard(proto: "create_user_id"),
    9: .standard(proto: "total_board_count"),
    10: .standard(proto: "total_like_count"),
    11: .standard(proto: "total_comment_count"),
    12: .standard(proto: "total_share_count"),
    13: .standard(proto: "total_render_count"),
    14: .standard(proto: "total_fork_count"),
    15: .standard(proto: "total_view_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.storyTitle) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.storyAvatar) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.storyDescription) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.storyCover) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.storyTags) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.createTime) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.createUserID) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.totalBoardCount) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.totalLikeCount) }()
      case 11: try { try decoder.decodeSingularInt64Field(value: &self.totalCommentCount) }()
      case 12: try { try decoder.decodeSingularInt64Field(value: &self.totalShareCount) }()
      case 13: try { try decoder.decodeSingularInt64Field(value: &self.totalRenderCount) }()
      case 14: try { try decoder.decodeSingularInt64Field(value: &self.totalForkCount) }()
      case 15: try { try decoder.decodeSingularInt64Field(value: &self.totalViewCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if !self.storyTitle.isEmpty {
      try visitor.visitSingularStringField(value: self.storyTitle, fieldNumber: 2)
    }
    if !self.storyAvatar.isEmpty {
      try visitor.visitSingularStringField(value: self.storyAvatar, fieldNumber: 3)
    }
    if !self.storyDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.storyDescription, fieldNumber: 4)
    }
    if !self.storyCover.isEmpty {
      try visitor.visitSingularStringField(value: self.storyCover, fieldNumber: 5)
    }
    if !self.storyTags.isEmpty {
      try visitor.visitSingularStringField(value: self.storyTags, fieldNumber: 6)
    }
    if self.createTime != 0 {
      try visitor.visitSingularInt64Field(value: self.createTime, fieldNumber: 7)
    }
    if self.createUserID != 0 {
      try visitor.visitSingularInt64Field(value: self.createUserID, fieldNumber: 8)
    }
    if self.totalBoardCount != 0 {
      try visitor.visitSingularInt64Field(value: self.totalBoardCount, fieldNumber: 9)
    }
    if self.totalLikeCount != 0 {
      try visitor.visitSingularInt64Field(value: self.totalLikeCount, fieldNumber: 10)
    }
    if self.totalCommentCount != 0 {
      try visitor.visitSingularInt64Field(value: self.totalCommentCount, fieldNumber: 11)
    }
    if self.totalShareCount != 0 {
      try visitor.visitSingularInt64Field(value: self.totalShareCount, fieldNumber: 12)
    }
    if self.totalRenderCount != 0 {
      try visitor.visitSingularInt64Field(value: self.totalRenderCount, fieldNumber: 13)
    }
    if self.totalForkCount != 0 {
      try visitor.visitSingularInt64Field(value: self.totalForkCount, fieldNumber: 14)
    }
    if self.totalViewCount != 0 {
      try visitor.visitSingularInt64Field(value: self.totalViewCount, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_StorySummaryInfo, rhs: Common_StorySummaryInfo) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.storyTitle != rhs.storyTitle {return false}
    if lhs.storyAvatar != rhs.storyAvatar {return false}
    if lhs.storyDescription != rhs.storyDescription {return false}
    if lhs.storyCover != rhs.storyCover {return false}
    if lhs.storyTags != rhs.storyTags {return false}
    if lhs.createTime != rhs.createTime {return false}
    if lhs.createUserID != rhs.createUserID {return false}
    if lhs.totalBoardCount != rhs.totalBoardCount {return false}
    if lhs.totalLikeCount != rhs.totalLikeCount {return false}
    if lhs.totalCommentCount != rhs.totalCommentCount {return false}
    if lhs.totalShareCount != rhs.totalShareCount {return false}
    if lhs.totalRenderCount != rhs.totalRenderCount {return false}
    if lhs.totalForkCount != rhs.totalForkCount {return false}
    if lhs.totalViewCount != rhs.totalViewCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_GetStoryboardsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryboardsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
    3: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_GetStoryboardsResponse, rhs: Common_GetStoryboardsResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_GetStoryboardsResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Common_GetStoryboardsResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "list"),
    4: .standard(proto: "is_multi_branch"),
    5: .same(proto: "total"),
    6: .same(proto: "offset"),
    7: .standard(proto: "page_size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isMultiBranch) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 1)
    }
    if self.isMultiBranch != false {
      try visitor.visitSingularBoolField(value: self.isMultiBranch, fieldNumber: 4)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 5)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 6)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_GetStoryboardsResponse.DataMessage, rhs: Common_GetStoryboardsResponse.DataMessage) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.isMultiBranch != rhs.isMultiBranch {return false}
    if lhs.total != rhs.total {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_DelStoryboardRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DelStoryboardRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "board_id"),
    2: .standard(proto: "story_id"),
    3: .standard(proto: "user_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.boardID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.boardID != 0 {
      try visitor.visitSingularInt64Field(value: self.boardID, fieldNumber: 1)
    }
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 2)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_DelStoryboardRequest, rhs: Common_DelStoryboardRequest) -> Bool {
    if lhs.boardID != rhs.boardID {return false}
    if lhs.storyID != rhs.storyID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_DelStoryboardResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DelStoryboardResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_DelStoryboardResponse, rhs: Common_DelStoryboardResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_ForkStoryboardRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ForkStoryboardRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "prev_board_id"),
    2: .standard(proto: "story_id"),
    3: .standard(proto: "user_id"),
    4: .same(proto: "board"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.prevBoardID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._board) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.prevBoardID != 0 {
      try visitor.visitSingularInt64Field(value: self.prevBoardID, fieldNumber: 1)
    }
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 2)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 3)
    }
    try { if let v = self._board {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_ForkStoryboardRequest, rhs: Common_ForkStoryboardRequest) -> Bool {
    if lhs.prevBoardID != rhs.prevBoardID {return false}
    if lhs.storyID != rhs.storyID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs._board != rhs._board {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_ForkStoryboardResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ForkStoryboardResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
    3: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_ForkStoryboardResponse, rhs: Common_ForkStoryboardResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_ForkStoryboardResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Common_ForkStoryboardResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "board_id"),
    2: .standard(proto: "story_id"),
    3: .standard(proto: "timeline_id"),
    4: .standard(proto: "prev_board_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.boardID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.timelineID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.prevBoardID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.boardID != 0 {
      try visitor.visitSingularInt64Field(value: self.boardID, fieldNumber: 1)
    }
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 2)
    }
    if self.timelineID != 0 {
      try visitor.visitSingularInt64Field(value: self.timelineID, fieldNumber: 3)
    }
    if self.prevBoardID != 0 {
      try visitor.visitSingularInt64Field(value: self.prevBoardID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_ForkStoryboardResponse.DataMessage, rhs: Common_ForkStoryboardResponse.DataMessage) -> Bool {
    if lhs.boardID != rhs.boardID {return false}
    if lhs.storyID != rhs.storyID {return false}
    if lhs.timelineID != rhs.timelineID {return false}
    if lhs.prevBoardID != rhs.prevBoardID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_UpdateStoryboardRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateStoryboardRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "board_id"),
    2: .standard(proto: "story_id"),
    3: .standard(proto: "user_id"),
    4: .same(proto: "params"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.boardID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._params) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.boardID != 0 {
      try visitor.visitSingularInt64Field(value: self.boardID, fieldNumber: 1)
    }
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 2)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 3)
    }
    try { if let v = self._params {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_UpdateStoryboardRequest, rhs: Common_UpdateStoryboardRequest) -> Bool {
    if lhs.boardID != rhs.boardID {return false}
    if lhs.storyID != rhs.storyID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs._params != rhs._params {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_UpdateStoryboardResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateStoryboardResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
    3: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_UpdateStoryboardResponse, rhs: Common_UpdateStoryboardResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_UpdateStoryboardResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Common_UpdateStoryboardResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "story_id"),
    2: .standard(proto: "board_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.boardID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.boardID != 0 {
      try visitor.visitSingularInt64Field(value: self.boardID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_UpdateStoryboardResponse.DataMessage, rhs: Common_UpdateStoryboardResponse.DataMessage) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.boardID != rhs.boardID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_WatchStoryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WatchStoryRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "story_id"),
    2: .standard(proto: "user_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_WatchStoryRequest, rhs: Common_WatchStoryRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_WatchStoryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WatchStoryResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
    3: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_WatchStoryResponse, rhs: Common_WatchStoryResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_WatchStoryResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Common_WatchStoryResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "story_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_WatchStoryResponse.DataMessage, rhs: Common_WatchStoryResponse.DataMessage) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_LikeStoryboardRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LikeStoryboardRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "board_id"),
    2: .standard(proto: "user_id"),
    3: .standard(proto: "story_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.boardID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.boardID != 0 {
      try visitor.visitSingularInt64Field(value: self.boardID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_LikeStoryboardRequest, rhs: Common_LikeStoryboardRequest) -> Bool {
    if lhs.boardID != rhs.boardID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.storyID != rhs.storyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_LikeStoryboardResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LikeStoryboardResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
    3: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_LikeStoryboardResponse, rhs: Common_LikeStoryboardResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_LikeStoryboardResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Common_LikeStoryboardResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "story_id"),
    2: .standard(proto: "board_id"),
    3: .standard(proto: "user_id"),
    4: .standard(proto: "like_num"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.boardID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.likeNum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.boardID != 0 {
      try visitor.visitSingularInt64Field(value: self.boardID, fieldNumber: 2)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 3)
    }
    if self.likeNum != 0 {
      try visitor.visitSingularInt64Field(value: self.likeNum, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_LikeStoryboardResponse.DataMessage, rhs: Common_LikeStoryboardResponse.DataMessage) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.boardID != rhs.boardID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.likeNum != rhs.likeNum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_UnLikeStoryboardRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnLikeStoryboardRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "board_id"),
    2: .standard(proto: "user_id"),
    3: .standard(proto: "story_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.boardID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.boardID != 0 {
      try visitor.visitSingularInt64Field(value: self.boardID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_UnLikeStoryboardRequest, rhs: Common_UnLikeStoryboardRequest) -> Bool {
    if lhs.boardID != rhs.boardID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.storyID != rhs.storyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_UnLikeStoryboardResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnLikeStoryboardResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_UnLikeStoryboardResponse, rhs: Common_UnLikeStoryboardResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_ShareStoryboardRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShareStoryboardRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "board_id"),
    2: .standard(proto: "user_id"),
    3: .standard(proto: "story_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.boardID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.boardID != 0 {
      try visitor.visitSingularInt64Field(value: self.boardID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_ShareStoryboardRequest, rhs: Common_ShareStoryboardRequest) -> Bool {
    if lhs.boardID != rhs.boardID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.storyID != rhs.storyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_ShareStoryboardResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShareStoryboardResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
    3: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_ShareStoryboardResponse, rhs: Common_ShareStoryboardResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_ShareStoryboardResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Common_ShareStoryboardResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "story_id"),
    2: .standard(proto: "board_id"),
    3: .standard(proto: "user_id"),
    4: .standard(proto: "share_num"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.boardID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.shareNum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.boardID != 0 {
      try visitor.visitSingularInt64Field(value: self.boardID, fieldNumber: 2)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 3)
    }
    if self.shareNum != 0 {
      try visitor.visitSingularInt64Field(value: self.shareNum, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_ShareStoryboardResponse.DataMessage, rhs: Common_ShareStoryboardResponse.DataMessage) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.boardID != rhs.boardID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.shareNum != rhs.shareNum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_RenderStoryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RenderStoryRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "story_id"),
    2: .standard(proto: "user_id"),
    4: .standard(proto: "is_regenerate"),
    7: .standard(proto: "board_id"),
    9: .standard(proto: "render_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isRegenerate) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.boardID) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.renderType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if self.isRegenerate != false {
      try visitor.visitSingularBoolField(value: self.isRegenerate, fieldNumber: 4)
    }
    if self.boardID != 0 {
      try visitor.visitSingularInt64Field(value: self.boardID, fieldNumber: 7)
    }
    if self.renderType != .textUnspecified {
      try visitor.visitSingularEnumField(value: self.renderType, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_RenderStoryRequest, rhs: Common_RenderStoryRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.isRegenerate != rhs.isRegenerate {return false}
    if lhs.boardID != rhs.boardID {return false}
    if lhs.renderType != rhs.renderType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_RenderStoryStructureValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RenderStoryStructureValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "urls"),
    3: .same(proto: "value"),
    4: .same(proto: "nums"),
    5: .same(proto: "extra"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.urls) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.value) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.nums) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.extra) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    if !self.urls.isEmpty {
      try visitor.visitRepeatedStringField(value: self.urls, fieldNumber: 2)
    }
    if self.value != 0 {
      try visitor.visitSingularInt32Field(value: self.value, fieldNumber: 3)
    }
    if self.nums != 0 {
      try visitor.visitSingularInt32Field(value: self.nums, fieldNumber: 4)
    }
    if !self.extra.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.extra, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_RenderStoryStructureValue, rhs: Common_RenderStoryStructureValue) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.urls != rhs.urls {return false}
    if lhs.value != rhs.value {return false}
    if lhs.nums != rhs.nums {return false}
    if lhs.extra != rhs.extra {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_RenderStoryStructure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RenderStoryStructure"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Common_RenderStoryStructureValue>.self, value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Common_RenderStoryStructureValue>.self, value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_RenderStoryStructure, rhs: Common_RenderStoryStructure) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_RenderStoryDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RenderStoryDetail"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "status"),
    3: .same(proto: "urls"),
    4: .standard(proto: "story_id"),
    5: .standard(proto: "board_id"),
    6: .standard(proto: "user_id"),
    7: .standard(proto: "render_type"),
    8: .same(proto: "result"),
    9: .same(proto: "timecost"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.status) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.urls) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.boardID) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.renderType) }()
      case 8: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Common_RenderStoryStructure>.self, value: &self.result) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.timecost) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    if self.status != 0 {
      try visitor.visitSingularInt32Field(value: self.status, fieldNumber: 2)
    }
    if !self.urls.isEmpty {
      try visitor.visitRepeatedStringField(value: self.urls, fieldNumber: 3)
    }
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 4)
    }
    if self.boardID != 0 {
      try visitor.visitSingularInt64Field(value: self.boardID, fieldNumber: 5)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 6)
    }
    if self.renderType != .textUnspecified {
      try visitor.visitSingularEnumField(value: self.renderType, fieldNumber: 7)
    }
    if !self.result.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Common_RenderStoryStructure>.self, value: self.result, fieldNumber: 8)
    }
    if self.timecost != 0 {
      try visitor.visitSingularInt32Field(value: self.timecost, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_RenderStoryDetail, rhs: Common_RenderStoryDetail) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.status != rhs.status {return false}
    if lhs.urls != rhs.urls {return false}
    if lhs.storyID != rhs.storyID {return false}
    if lhs.boardID != rhs.boardID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.renderType != rhs.renderType {return false}
    if lhs.result != rhs.result {return false}
    if lhs.timecost != rhs.timecost {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_RenderStoryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RenderStoryResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
    3: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_RenderStoryResponse, rhs: Common_RenderStoryResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_RenderStoryboardRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RenderStoryboardRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "board_id"),
    2: .standard(proto: "story_id"),
    3: .standard(proto: "user_id"),
    4: .standard(proto: "is_regenerate"),
    6: .standard(proto: "render_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.boardID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isRegenerate) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.renderType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.boardID != 0 {
      try visitor.visitSingularInt64Field(value: self.boardID, fieldNumber: 1)
    }
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 2)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 3)
    }
    if self.isRegenerate != false {
      try visitor.visitSingularBoolField(value: self.isRegenerate, fieldNumber: 4)
    }
    if self.renderType != .textUnspecified {
      try visitor.visitSingularEnumField(value: self.renderType, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_RenderStoryboardRequest, rhs: Common_RenderStoryboardRequest) -> Bool {
    if lhs.boardID != rhs.boardID {return false}
    if lhs.storyID != rhs.storyID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.isRegenerate != rhs.isRegenerate {return false}
    if lhs.renderType != rhs.renderType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_RenderStoryboardDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RenderStoryboardDetail"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "status"),
    3: .same(proto: "urls"),
    4: .standard(proto: "story_id"),
    5: .standard(proto: "board_id"),
    6: .standard(proto: "user_id"),
    7: .standard(proto: "render_type"),
    8: .same(proto: "result"),
    9: .same(proto: "timecost"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.status) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.urls) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.boardID) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.renderType) }()
      case 8: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Common_RenderStoryStructure>.self, value: &self.result) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.timecost) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    if self.status != 0 {
      try visitor.visitSingularInt32Field(value: self.status, fieldNumber: 2)
    }
    if !self.urls.isEmpty {
      try visitor.visitRepeatedStringField(value: self.urls, fieldNumber: 3)
    }
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 4)
    }
    if self.boardID != 0 {
      try visitor.visitSingularInt64Field(value: self.boardID, fieldNumber: 5)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 6)
    }
    if self.renderType != .textUnspecified {
      try visitor.visitSingularEnumField(value: self.renderType, fieldNumber: 7)
    }
    if !self.result.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Common_RenderStoryStructure>.self, value: self.result, fieldNumber: 8)
    }
    if self.timecost != 0 {
      try visitor.visitSingularInt32Field(value: self.timecost, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_RenderStoryboardDetail, rhs: Common_RenderStoryboardDetail) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.status != rhs.status {return false}
    if lhs.urls != rhs.urls {return false}
    if lhs.storyID != rhs.storyID {return false}
    if lhs.boardID != rhs.boardID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.renderType != rhs.renderType {return false}
    if lhs.result != rhs.result {return false}
    if lhs.timecost != rhs.timecost {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_RenderStoryboardResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RenderStoryboardResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
    3: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_RenderStoryboardResponse, rhs: Common_RenderStoryboardResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_GenStoryboardTextRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenStoryboardTextRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "board_id"),
    2: .standard(proto: "story_id"),
    3: .standard(proto: "user_id"),
    6: .standard(proto: "render_type"),
    9: .same(proto: "prompt"),
    10: .same(proto: "title"),
    11: .same(proto: "description"),
    13: .standard(proto: "sence_num"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.boardID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.renderType) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.prompt) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 13: try { try decoder.decodeSingularInt32Field(value: &self.senceNum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.boardID != 0 {
      try visitor.visitSingularInt64Field(value: self.boardID, fieldNumber: 1)
    }
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 2)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 3)
    }
    if self.renderType != .textUnspecified {
      try visitor.visitSingularEnumField(value: self.renderType, fieldNumber: 6)
    }
    if !self.prompt.isEmpty {
      try visitor.visitSingularStringField(value: self.prompt, fieldNumber: 9)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 10)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 11)
    }
    if self.senceNum != 0 {
      try visitor.visitSingularInt32Field(value: self.senceNum, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_GenStoryboardTextRequest, rhs: Common_GenStoryboardTextRequest) -> Bool {
    if lhs.boardID != rhs.boardID {return false}
    if lhs.storyID != rhs.storyID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.renderType != rhs.renderType {return false}
    if lhs.prompt != rhs.prompt {return false}
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.senceNum != rhs.senceNum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_GenStoryboardTextResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenStoryboardTextResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
    3: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_GenStoryboardTextResponse, rhs: Common_GenStoryboardTextResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_GenStoryboardImagesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenStoryboardImagesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "board_id"),
    2: .standard(proto: "story_id"),
    3: .standard(proto: "user_id"),
    4: .standard(proto: "is_regenerate"),
    6: .standard(proto: "render_type"),
    7: .standard(proto: "sence_id"),
    8: .standard(proto: "sence_name_key"),
    9: .same(proto: "prompt"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.boardID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isRegenerate) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.renderType) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.senceID) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.senceNameKey) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.prompt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.boardID != 0 {
      try visitor.visitSingularInt64Field(value: self.boardID, fieldNumber: 1)
    }
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 2)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 3)
    }
    if self.isRegenerate != false {
      try visitor.visitSingularBoolField(value: self.isRegenerate, fieldNumber: 4)
    }
    if self.renderType != .textUnspecified {
      try visitor.visitSingularEnumField(value: self.renderType, fieldNumber: 6)
    }
    if self.senceID != 0 {
      try visitor.visitSingularInt32Field(value: self.senceID, fieldNumber: 7)
    }
    if !self.senceNameKey.isEmpty {
      try visitor.visitSingularStringField(value: self.senceNameKey, fieldNumber: 8)
    }
    if !self.prompt.isEmpty {
      try visitor.visitSingularStringField(value: self.prompt, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_GenStoryboardImagesRequest, rhs: Common_GenStoryboardImagesRequest) -> Bool {
    if lhs.boardID != rhs.boardID {return false}
    if lhs.storyID != rhs.storyID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.isRegenerate != rhs.isRegenerate {return false}
    if lhs.renderType != rhs.renderType {return false}
    if lhs.senceID != rhs.senceID {return false}
    if lhs.senceNameKey != rhs.senceNameKey {return false}
    if lhs.prompt != rhs.prompt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_GenStoryboardImagesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenStoryboardImagesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
    3: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_GenStoryboardImagesResponse, rhs: Common_GenStoryboardImagesResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_FetchGroupStorysRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FetchGroupStorysRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .standard(proto: "user_id"),
    3: .same(proto: "page"),
    4: .standard(proto: "page_size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.page) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.groupID != 0 {
      try visitor.visitSingularInt64Field(value: self.groupID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if self.page != 0 {
      try visitor.visitSingularInt32Field(value: self.page, fieldNumber: 3)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_FetchGroupStorysRequest, rhs: Common_FetchGroupStorysRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_FetchGroupStorysResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FetchGroupStorysResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
    3: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_FetchGroupStorysResponse, rhs: Common_FetchGroupStorysResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_FetchGroupStorysResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Common_FetchGroupStorysResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "list"),
    3: .same(proto: "creator"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.creator) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 1)
    }
    if !self.creator.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.creator, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_FetchGroupStorysResponse.DataMessage, rhs: Common_FetchGroupStorysResponse.DataMessage) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.creator != rhs.creator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_GetStoryRenderRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryRenderRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "story_id"),
    2: .standard(proto: "render_status"),
    3: .standard(proto: "render_type"),
    4: .standard(proto: "user_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.renderStatus) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.renderType) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.renderStatus != 0 {
      try visitor.visitSingularInt32Field(value: self.renderStatus, fieldNumber: 2)
    }
    if self.renderType != 0 {
      try visitor.visitSingularInt32Field(value: self.renderType, fieldNumber: 3)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_GetStoryRenderRequest, rhs: Common_GetStoryRenderRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.renderStatus != rhs.renderStatus {return false}
    if lhs.renderType != rhs.renderType {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_GetStoryRenderResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryRenderResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
    3: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_GetStoryRenderResponse, rhs: Common_GetStoryRenderResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_GetStoryRenderResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Common_GetStoryRenderResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "list"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_GetStoryRenderResponse.DataMessage, rhs: Common_GetStoryRenderResponse.DataMessage) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_GetStoryBoardRenderRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryBoardRenderRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "board_id"),
    2: .standard(proto: "render_status"),
    3: .standard(proto: "render_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.boardID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.renderStatus) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.renderType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.boardID != 0 {
      try visitor.visitSingularInt64Field(value: self.boardID, fieldNumber: 1)
    }
    if self.renderStatus != 0 {
      try visitor.visitSingularInt32Field(value: self.renderStatus, fieldNumber: 2)
    }
    if self.renderType != 0 {
      try visitor.visitSingularInt32Field(value: self.renderType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_GetStoryBoardRenderRequest, rhs: Common_GetStoryBoardRenderRequest) -> Bool {
    if lhs.boardID != rhs.boardID {return false}
    if lhs.renderStatus != rhs.renderStatus {return false}
    if lhs.renderType != rhs.renderType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_GetStoryBoardRenderResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryBoardRenderResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
    3: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_GetStoryBoardRenderResponse, rhs: Common_GetStoryBoardRenderResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_GetStoryBoardRenderResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Common_GetStoryBoardRenderResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "list"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_GetStoryBoardRenderResponse.DataMessage, rhs: Common_GetStoryBoardRenderResponse.DataMessage) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_ContinueRenderStoryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ContinueRenderStoryRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "story_id"),
    2: .standard(proto: "prev_board_id"),
    3: .standard(proto: "user_id"),
    4: .standard(proto: "render_type"),
    5: .same(proto: "prompt"),
    6: .same(proto: "title"),
    7: .same(proto: "description"),
    8: .same(proto: "background"),
    9: .same(proto: "roles"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.prevBoardID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.renderType) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.prompt) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.background) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.roles) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.prevBoardID != 0 {
      try visitor.visitSingularInt64Field(value: self.prevBoardID, fieldNumber: 2)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 3)
    }
    if self.renderType != .textUnspecified {
      try visitor.visitSingularEnumField(value: self.renderType, fieldNumber: 4)
    }
    if !self.prompt.isEmpty {
      try visitor.visitSingularStringField(value: self.prompt, fieldNumber: 5)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 6)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 7)
    }
    if !self.background.isEmpty {
      try visitor.visitSingularStringField(value: self.background, fieldNumber: 8)
    }
    if !self.roles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.roles, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_ContinueRenderStoryRequest, rhs: Common_ContinueRenderStoryRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.prevBoardID != rhs.prevBoardID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.renderType != rhs.renderType {return false}
    if lhs.prompt != rhs.prompt {return false}
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.background != rhs.background {return false}
    if lhs.roles != rhs.roles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_ContinueRenderStoryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ContinueRenderStoryResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
    3: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_ContinueRenderStoryResponse, rhs: Common_ContinueRenderStoryResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_RenderStoryRolesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RenderStoryRolesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "story_id"),
    2: .standard(proto: "board_id"),
    3: .standard(proto: "user_id"),
    4: .same(proto: "prompt"),
    5: .same(proto: "background"),
    6: .same(proto: "params"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.boardID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.prompt) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.background) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._params) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.boardID != 0 {
      try visitor.visitSingularInt64Field(value: self.boardID, fieldNumber: 2)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 3)
    }
    if !self.prompt.isEmpty {
      try visitor.visitSingularStringField(value: self.prompt, fieldNumber: 4)
    }
    if !self.background.isEmpty {
      try visitor.visitSingularStringField(value: self.background, fieldNumber: 5)
    }
    try { if let v = self._params {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_RenderStoryRolesRequest, rhs: Common_RenderStoryRolesRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.boardID != rhs.boardID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.prompt != rhs.prompt {return false}
    if lhs.background != rhs.background {return false}
    if lhs._params != rhs._params {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_RenderStoryRolesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RenderStoryRolesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
    3: .same(proto: "list"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_RenderStoryRolesResponse, rhs: Common_RenderStoryRolesResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.list != rhs.list {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_RenderStoryRoleDetailRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RenderStoryRoleDetailRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "role_id"),
    2: .same(proto: "role"),
    3: .same(proto: "prompt"),
    4: .same(proto: "background"),
    5: .standard(proto: "user_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._role) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.prompt) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.background) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 1)
    }
    try { if let v = self._role {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.prompt.isEmpty {
      try visitor.visitSingularStringField(value: self.prompt, fieldNumber: 3)
    }
    if !self.background.isEmpty {
      try visitor.visitSingularStringField(value: self.background, fieldNumber: 4)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_RenderStoryRoleDetailRequest, rhs: Common_RenderStoryRoleDetailRequest) -> Bool {
    if lhs.roleID != rhs.roleID {return false}
    if lhs._role != rhs._role {return false}
    if lhs.prompt != rhs.prompt {return false}
    if lhs.background != rhs.background {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_RenderStoryRoleDetailResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RenderStoryRoleDetailResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
    3: .same(proto: "role"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._role) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._role {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_RenderStoryRoleDetailResponse, rhs: Common_RenderStoryRoleDetailResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._role != rhs._role {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_UpdateStoryRoleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateStoryRoleRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "role"),
    2: .standard(proto: "user_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._role) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._role {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_UpdateStoryRoleRequest, rhs: Common_UpdateStoryRoleRequest) -> Bool {
    if lhs._role != rhs._role {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_UpdateStoryRoleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateStoryRoleResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_UpdateStoryRoleResponse, rhs: Common_UpdateStoryRoleResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_GetStoryRolesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryRolesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "story_id"),
    2: .standard(proto: "user_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_GetStoryRolesRequest, rhs: Common_GetStoryRolesRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_GetStoryRolesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryRolesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
    3: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_GetStoryRolesResponse, rhs: Common_GetStoryRolesResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_GetStoryRolesResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Common_GetStoryRolesResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "list"),
    3: .same(proto: "creator"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.creator) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 1)
    }
    if !self.creator.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.creator, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_GetStoryRolesResponse.DataMessage, rhs: Common_GetStoryRolesResponse.DataMessage) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.creator != rhs.creator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_GetStoryBoardRolesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryBoardRolesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "board_id"),
    2: .standard(proto: "user_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.boardID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.boardID != 0 {
      try visitor.visitSingularInt64Field(value: self.boardID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_GetStoryBoardRolesRequest, rhs: Common_GetStoryBoardRolesRequest) -> Bool {
    if lhs.boardID != rhs.boardID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_GetStoryBoardRolesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryBoardRolesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
    3: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_GetStoryBoardRolesResponse, rhs: Common_GetStoryBoardRolesResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_GetStoryBoardRolesResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Common_GetStoryBoardRolesResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "list"),
    3: .same(proto: "creator"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.creator) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 1)
    }
    if !self.creator.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.creator, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_GetStoryBoardRolesResponse.DataMessage, rhs: Common_GetStoryBoardRolesResponse.DataMessage) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.creator != rhs.creator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_StoryBoardSence: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StoryBoardSence"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sence_id"),
    2: .same(proto: "content"),
    3: .standard(proto: "character_ids"),
    4: .standard(proto: "creator_id"),
    5: .standard(proto: "story_id"),
    6: .standard(proto: "board_id"),
    7: .standard(proto: "image_prompts"),
    8: .standard(proto: "audio_prompts"),
    9: .standard(proto: "video_prompts"),
    10: .standard(proto: "is_generating"),
    11: .standard(proto: "gen_result"),
    12: .same(proto: "images"),
    13: .standard(proto: "audio_url"),
    14: .standard(proto: "video_url"),
    15: .same(proto: "status"),
    16: .same(proto: "Ctime"),
    17: .same(proto: "Mtime"),
  ]

  fileprivate class _StorageClass {
    var _senceID: Int64 = 0
    var _content: String = String()
    var _characterIds: [String] = []
    var _creatorID: Int64 = 0
    var _storyID: Int64 = 0
    var _boardID: Int64 = 0
    var _imagePrompts: String = String()
    var _audioPrompts: String = String()
    var _videoPrompts: String = String()
    var _isGenerating: Int32 = 0
    var _genResult: String = String()
    var _images: [String] = []
    var _audioURL: String = String()
    var _videoURL: String = String()
    var _status: Int32 = 0
    var _ctime: Int64 = 0
    var _mtime: Int64 = 0

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _senceID = source._senceID
      _content = source._content
      _characterIds = source._characterIds
      _creatorID = source._creatorID
      _storyID = source._storyID
      _boardID = source._boardID
      _imagePrompts = source._imagePrompts
      _audioPrompts = source._audioPrompts
      _videoPrompts = source._videoPrompts
      _isGenerating = source._isGenerating
      _genResult = source._genResult
      _images = source._images
      _audioURL = source._audioURL
      _videoURL = source._videoURL
      _status = source._status
      _ctime = source._ctime
      _mtime = source._mtime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._senceID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._content) }()
        case 3: try { try decoder.decodeRepeatedStringField(value: &_storage._characterIds) }()
        case 4: try { try decoder.decodeSingularInt64Field(value: &_storage._creatorID) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._storyID) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._boardID) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._imagePrompts) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._audioPrompts) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._videoPrompts) }()
        case 10: try { try decoder.decodeSingularInt32Field(value: &_storage._isGenerating) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._genResult) }()
        case 12: try { try decoder.decodeRepeatedStringField(value: &_storage._images) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._audioURL) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._videoURL) }()
        case 15: try { try decoder.decodeSingularInt32Field(value: &_storage._status) }()
        case 16: try { try decoder.decodeSingularInt64Field(value: &_storage._ctime) }()
        case 17: try { try decoder.decodeSingularInt64Field(value: &_storage._mtime) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._senceID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._senceID, fieldNumber: 1)
      }
      if !_storage._content.isEmpty {
        try visitor.visitSingularStringField(value: _storage._content, fieldNumber: 2)
      }
      if !_storage._characterIds.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._characterIds, fieldNumber: 3)
      }
      if _storage._creatorID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._creatorID, fieldNumber: 4)
      }
      if _storage._storyID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._storyID, fieldNumber: 5)
      }
      if _storage._boardID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._boardID, fieldNumber: 6)
      }
      if !_storage._imagePrompts.isEmpty {
        try visitor.visitSingularStringField(value: _storage._imagePrompts, fieldNumber: 7)
      }
      if !_storage._audioPrompts.isEmpty {
        try visitor.visitSingularStringField(value: _storage._audioPrompts, fieldNumber: 8)
      }
      if !_storage._videoPrompts.isEmpty {
        try visitor.visitSingularStringField(value: _storage._videoPrompts, fieldNumber: 9)
      }
      if _storage._isGenerating != 0 {
        try visitor.visitSingularInt32Field(value: _storage._isGenerating, fieldNumber: 10)
      }
      if !_storage._genResult.isEmpty {
        try visitor.visitSingularStringField(value: _storage._genResult, fieldNumber: 11)
      }
      if !_storage._images.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._images, fieldNumber: 12)
      }
      if !_storage._audioURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._audioURL, fieldNumber: 13)
      }
      if !_storage._videoURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._videoURL, fieldNumber: 14)
      }
      if _storage._status != 0 {
        try visitor.visitSingularInt32Field(value: _storage._status, fieldNumber: 15)
      }
      if _storage._ctime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._ctime, fieldNumber: 16)
      }
      if _storage._mtime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._mtime, fieldNumber: 17)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_StoryBoardSence, rhs: Common_StoryBoardSence) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._senceID != rhs_storage._senceID {return false}
        if _storage._content != rhs_storage._content {return false}
        if _storage._characterIds != rhs_storage._characterIds {return false}
        if _storage._creatorID != rhs_storage._creatorID {return false}
        if _storage._storyID != rhs_storage._storyID {return false}
        if _storage._boardID != rhs_storage._boardID {return false}
        if _storage._imagePrompts != rhs_storage._imagePrompts {return false}
        if _storage._audioPrompts != rhs_storage._audioPrompts {return false}
        if _storage._videoPrompts != rhs_storage._videoPrompts {return false}
        if _storage._isGenerating != rhs_storage._isGenerating {return false}
        if _storage._genResult != rhs_storage._genResult {return false}
        if _storage._images != rhs_storage._images {return false}
        if _storage._audioURL != rhs_storage._audioURL {return false}
        if _storage._videoURL != rhs_storage._videoURL {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._ctime != rhs_storage._ctime {return false}
        if _storage._mtime != rhs_storage._mtime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_GetStoryBoardSencesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryBoardSencesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "board_id"),
    2: .standard(proto: "user_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.boardID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.boardID != 0 {
      try visitor.visitSingularInt64Field(value: self.boardID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_GetStoryBoardSencesRequest, rhs: Common_GetStoryBoardSencesRequest) -> Bool {
    if lhs.boardID != rhs.boardID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_GetStoryBoardSencesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryBoardSencesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
    3: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_GetStoryBoardSencesResponse, rhs: Common_GetStoryBoardSencesResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_GetStoryBoardSencesResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Common_GetStoryBoardSencesResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "list"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_GetStoryBoardSencesResponse.DataMessage, rhs: Common_GetStoryBoardSencesResponse.DataMessage) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_CreateStoryBoardSenceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateStoryBoardSenceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sence"),
    2: .standard(proto: "user_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._sence) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sence {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_CreateStoryBoardSenceRequest, rhs: Common_CreateStoryBoardSenceRequest) -> Bool {
    if lhs._sence != rhs._sence {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_CreateStoryBoardSenceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateStoryBoardSenceResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
    3: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_CreateStoryBoardSenceResponse, rhs: Common_CreateStoryBoardSenceResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_CreateStoryBoardSenceResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Common_CreateStoryBoardSenceResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sence_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.senceID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.senceID != 0 {
      try visitor.visitSingularInt64Field(value: self.senceID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_CreateStoryBoardSenceResponse.DataMessage, rhs: Common_CreateStoryBoardSenceResponse.DataMessage) -> Bool {
    if lhs.senceID != rhs.senceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_UpdateStoryBoardSenceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateStoryBoardSenceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sence"),
    2: .standard(proto: "user_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._sence) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sence {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_UpdateStoryBoardSenceRequest, rhs: Common_UpdateStoryBoardSenceRequest) -> Bool {
    if lhs._sence != rhs._sence {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_UpdateStoryBoardSenceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateStoryBoardSenceResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_UpdateStoryBoardSenceResponse, rhs: Common_UpdateStoryBoardSenceResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_DeleteStoryBoardSenceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteStoryBoardSenceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sence_id"),
    2: .standard(proto: "user_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.senceID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.senceID != 0 {
      try visitor.visitSingularInt64Field(value: self.senceID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_DeleteStoryBoardSenceRequest, rhs: Common_DeleteStoryBoardSenceRequest) -> Bool {
    if lhs.senceID != rhs.senceID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_DeleteStoryBoardSenceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteStoryBoardSenceResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_DeleteStoryBoardSenceResponse, rhs: Common_DeleteStoryBoardSenceResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_RenderStoryBoardSenceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RenderStoryBoardSenceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sence_id"),
    2: .standard(proto: "user_id"),
    3: .standard(proto: "board_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.senceID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.boardID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.senceID != 0 {
      try visitor.visitSingularInt64Field(value: self.senceID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if self.boardID != 0 {
      try visitor.visitSingularInt32Field(value: self.boardID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_RenderStoryBoardSenceRequest, rhs: Common_RenderStoryBoardSenceRequest) -> Bool {
    if lhs.senceID != rhs.senceID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.boardID != rhs.boardID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_RenderStoryBoardSenceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RenderStoryBoardSenceResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
    3: .standard(proto: "generating_stage"),
    4: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.generatingStage) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if self.generatingStage != 0 {
      try visitor.visitSingularInt32Field(value: self.generatingStage, fieldNumber: 3)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_RenderStoryBoardSenceResponse, rhs: Common_RenderStoryBoardSenceResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.generatingStage != rhs.generatingStage {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_RenderStoryBoardSencesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RenderStoryBoardSencesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .standard(proto: "board_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.boardID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.boardID != 0 {
      try visitor.visitSingularInt32Field(value: self.boardID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_RenderStoryBoardSencesRequest, rhs: Common_RenderStoryBoardSencesRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.boardID != rhs.boardID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_RenderStoryBoardSencesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RenderStoryBoardSencesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
    3: .standard(proto: "generating_stage"),
    4: .same(proto: "list"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.generatingStage) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if self.generatingStage != 0 {
      try visitor.visitSingularInt32Field(value: self.generatingStage, fieldNumber: 3)
    }
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_RenderStoryBoardSencesResponse, rhs: Common_RenderStoryBoardSencesResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.generatingStage != rhs.generatingStage {return false}
    if lhs.list != rhs.list {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_GetStoryBoardSenceGenerateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryBoardSenceGenerateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sence_id"),
    2: .standard(proto: "user_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.senceID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.senceID != 0 {
      try visitor.visitSingularInt64Field(value: self.senceID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_GetStoryBoardSenceGenerateRequest, rhs: Common_GetStoryBoardSenceGenerateRequest) -> Bool {
    if lhs.senceID != rhs.senceID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_GetStoryBoardSenceGenerateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryBoardSenceGenerateResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
    3: .standard(proto: "generating_stage"),
    4: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.generatingStage) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if self.generatingStage != 0 {
      try visitor.visitSingularInt32Field(value: self.generatingStage, fieldNumber: 3)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_GetStoryBoardSenceGenerateResponse, rhs: Common_GetStoryBoardSenceGenerateResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.generatingStage != rhs.generatingStage {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_GetStoryBoardGenerateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryBoardGenerateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "board_id"),
    2: .standard(proto: "user_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.boardID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.boardID != 0 {
      try visitor.visitSingularInt64Field(value: self.boardID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_GetStoryBoardGenerateRequest, rhs: Common_GetStoryBoardGenerateRequest) -> Bool {
    if lhs.boardID != rhs.boardID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_GetStoryBoardGenerateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryBoardGenerateResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
    3: .standard(proto: "generating_stage"),
    4: .same(proto: "list"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.generatingStage) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if self.generatingStage != 0 {
      try visitor.visitSingularInt32Field(value: self.generatingStage, fieldNumber: 3)
    }
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_GetStoryBoardGenerateResponse, rhs: Common_GetStoryBoardGenerateResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.generatingStage != rhs.generatingStage {return false}
    if lhs.list != rhs.list {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
