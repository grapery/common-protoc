// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: view_model.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Common_LikeType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case browser // = 0

  /// orange,激进的
  case left // = 1

  /// blue，温和的
  case middle // = 2

  /// green 保守的
  case right // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .browser
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .browser
    case 1: self = .left
    case 2: self = .middle
    case 3: self = .right
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .browser: return 0
    case .left: return 1
    case .middle: return 2
    case .right: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Common_LikeType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Common_LikeType] = [
    .browser,
    .left,
    .middle,
    .right,
  ]
}

#endif  // swift(>=4.2)

public enum Common_GenderType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// 不公开性别
  case none // = 0
  case man // = 1
  case women // = 2
  case double // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .none
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .man
    case 2: self = .women
    case 3: self = .double
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .none: return 0
    case .man: return 1
    case .women: return 2
    case .double: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Common_GenderType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Common_GenderType] = [
    .none,
    .man,
    .women,
    .double,
  ]
}

#endif  // swift(>=4.2)

public enum Common_UserStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case rest // = 0
  case study // = 1
  case busy // = 2
  case working // = 3
  case invisible // = 4
  case idle // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .rest
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .rest
    case 1: self = .study
    case 2: self = .busy
    case 3: self = .working
    case 4: self = .invisible
    case 5: self = .idle
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .rest: return 0
    case .study: return 1
    case .busy: return 2
    case .working: return 3
    case .invisible: return 4
    case .idle: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Common_UserStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Common_UserStatus] = [
    .rest,
    .study,
    .busy,
    .working,
    .invisible,
    .idle,
  ]
}

#endif  // swift(>=4.2)

public enum Common_GroupStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case notReady // = 0
  case normal // = 1
  case viewOnly // = 2
  case abandon // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .notReady
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .notReady
    case 1: self = .normal
    case 2: self = .viewOnly
    case 3: self = .abandon
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .notReady: return 0
    case .normal: return 1
    case .viewOnly: return 2
    case .abandon: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Common_GroupStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Common_GroupStatus] = [
    .notReady,
    .normal,
    .viewOnly,
    .abandon,
  ]
}

#endif  // swift(>=4.2)

public enum Common_ActiveType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case allActive // = 0
  case like // = 1
  case share // = 2
  case comment // = 3
  case collect // = 4
  case disAgree // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .allActive
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .allActive
    case 1: self = .like
    case 2: self = .share
    case 3: self = .comment
    case 4: self = .collect
    case 5: self = .disAgree
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .allActive: return 0
    case .like: return 1
    case .share: return 2
    case .comment: return 3
    case .collect: return 4
    case .disAgree: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Common_ActiveType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Common_ActiveType] = [
    .allActive,
    .like,
    .share,
    .comment,
    .collect,
    .disAgree,
  ]
}

#endif  // swift(>=4.2)

public enum Common_ItemType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case allItem // = 0
  case shortWord // = 1
  case paper // = 2
  case picture // = 3
  case video // = 4
  case music // = 5
  case link // = 6
  case location // = 7
  case UNRECOGNIZED(Int)

  public init() {
    self = .allItem
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .allItem
    case 1: self = .shortWord
    case 2: self = .paper
    case 3: self = .picture
    case 4: self = .video
    case 5: self = .music
    case 6: self = .link
    case 7: self = .location
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .allItem: return 0
    case .shortWord: return 1
    case .paper: return 2
    case .picture: return 3
    case .video: return 4
    case .music: return 5
    case .link: return 6
    case .location: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Common_ItemType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Common_ItemType] = [
    .allItem,
    .shortWord,
    .paper,
    .picture,
    .video,
    .music,
    .link,
    .location,
  ]
}

#endif  // swift(>=4.2)

public enum Common_AuthType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case notSupport // = 0
  case withPhone // = 1
  case withEmail // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .notSupport
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .notSupport
    case 1: self = .withPhone
    case 2: self = .withEmail
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .notSupport: return 0
    case .withPhone: return 1
    case .withEmail: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Common_AuthType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Common_AuthType] = [
    .notSupport,
    .withPhone,
    .withEmail,
  ]
}

#endif  // swift(>=4.2)

public enum Common_VisibleType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case allPublic // = 0
  case `public` // = 1
  case `private` // = 2
  case someone // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .allPublic
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .allPublic
    case 1: self = .public
    case 2: self = .private
    case 3: self = .someone
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .allPublic: return 0
    case .public: return 1
    case .private: return 2
    case .someone: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Common_VisibleType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Common_VisibleType] = [
    .allPublic,
    .public,
    .private,
    .someone,
  ]
}

#endif  // swift(>=4.2)

public struct Common_Tags {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var groupID: UInt64 = 0

  public var creatorID: UInt64 = 0

  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_UserInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: UInt64 = 0

  public var name: String = String()

  public var avatar: String = String()

  public var email: String = String()

  public var location: String = String()

  public var desc: String = String()

  public var ctime: Int64 = 0

  public var mtime: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_GroupInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var groupID: UInt64 {
    get {return _storage._groupID}
    set {_uniqueStorage()._groupID = newValue}
  }

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var avatar: String {
    get {return _storage._avatar}
    set {_uniqueStorage()._avatar = newValue}
  }

  public var desc: String {
    get {return _storage._desc}
    set {_uniqueStorage()._desc = newValue}
  }

  public var creator: Common_UserInfo {
    get {return _storage._creator ?? Common_UserInfo()}
    set {_uniqueStorage()._creator = newValue}
  }
  /// Returns true if `creator` has been explicitly set.
  public var hasCreator: Bool {return _storage._creator != nil}
  /// Clears the value of `creator`. Subsequent reads from it will return its default value.
  public mutating func clearCreator() {_uniqueStorage()._creator = nil}

  public var owner: Common_UserInfo {
    get {return _storage._owner ?? Common_UserInfo()}
    set {_uniqueStorage()._owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return _storage._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {_uniqueStorage()._owner = nil}

  public var tags: [Common_Tags] {
    get {return _storage._tags}
    set {_uniqueStorage()._tags = newValue}
  }

  public var ctime: Int64 {
    get {return _storage._ctime}
    set {_uniqueStorage()._ctime = newValue}
  }

  public var mtime: Int64 {
    get {return _storage._mtime}
    set {_uniqueStorage()._mtime = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Common_ProjectInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var projectID: UInt64 {
    get {return _storage._projectID}
    set {_uniqueStorage()._projectID = newValue}
  }

  public var groupID: UInt32 {
    get {return _storage._groupID}
    set {_uniqueStorage()._groupID = newValue}
  }

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var avatar: String {
    get {return _storage._avatar}
    set {_uniqueStorage()._avatar = newValue}
  }

  public var creator: Common_UserInfo {
    get {return _storage._creator ?? Common_UserInfo()}
    set {_uniqueStorage()._creator = newValue}
  }
  /// Returns true if `creator` has been explicitly set.
  public var hasCreator: Bool {return _storage._creator != nil}
  /// Clears the value of `creator`. Subsequent reads from it will return its default value.
  public mutating func clearCreator() {_uniqueStorage()._creator = nil}

  public var owner: Common_UserInfo {
    get {return _storage._owner ?? Common_UserInfo()}
    set {_uniqueStorage()._owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return _storage._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {_uniqueStorage()._owner = nil}

  public var tags: [Common_Tags] {
    get {return _storage._tags}
    set {_uniqueStorage()._tags = newValue}
  }

  public var visable: Common_VisibleType {
    get {return _storage._visable}
    set {_uniqueStorage()._visable = newValue}
  }

  public var isAchieve: Bool {
    get {return _storage._isAchieve}
    set {_uniqueStorage()._isAchieve = newValue}
  }

  public var isClose: Bool {
    get {return _storage._isClose}
    set {_uniqueStorage()._isClose = newValue}
  }

  public var ctime: Int64 {
    get {return _storage._ctime}
    set {_uniqueStorage()._ctime = newValue}
  }

  public var mtime: Int64 {
    get {return _storage._mtime}
    set {_uniqueStorage()._mtime = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Common_ProjectProfileInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var projectID: UInt64 = 0

  public var groupID: UInt32 = 0

  public var description_p: String = String()

  public var watchingCount: UInt64 = 0

  public var involvedCount: UInt64 = 0

  public var avatar: String = String()

  public var visable: Common_VisibleType = .allPublic

  public var isAchieve: Bool = false

  public var isClose: Bool = false

  public var isPrivate: Bool = false

  public var ctime: Int64 = 0

  public var mtime: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_ActiveInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var user: Common_UserInfo {
    get {return _storage._user ?? Common_UserInfo()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  public var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  public mutating func clearUser() {_uniqueStorage()._user = nil}

  public var activeType: Common_ActiveType {
    get {return _storage._activeType}
    set {_uniqueStorage()._activeType = newValue}
  }

  public var itemInfo: Common_ItemInfo {
    get {return _storage._itemInfo ?? Common_ItemInfo()}
    set {_uniqueStorage()._itemInfo = newValue}
  }
  /// Returns true if `itemInfo` has been explicitly set.
  public var hasItemInfo: Bool {return _storage._itemInfo != nil}
  /// Clears the value of `itemInfo`. Subsequent reads from it will return its default value.
  public mutating func clearItemInfo() {_uniqueStorage()._itemInfo = nil}

  public var projectInfo: Common_ProjectInfo {
    get {return _storage._projectInfo ?? Common_ProjectInfo()}
    set {_uniqueStorage()._projectInfo = newValue}
  }
  /// Returns true if `projectInfo` has been explicitly set.
  public var hasProjectInfo: Bool {return _storage._projectInfo != nil}
  /// Clears the value of `projectInfo`. Subsequent reads from it will return its default value.
  public mutating func clearProjectInfo() {_uniqueStorage()._projectInfo = nil}

  public var groupInfo: Common_GroupInfo {
    get {return _storage._groupInfo ?? Common_GroupInfo()}
    set {_uniqueStorage()._groupInfo = newValue}
  }
  /// Returns true if `groupInfo` has been explicitly set.
  public var hasGroupInfo: Bool {return _storage._groupInfo != nil}
  /// Clears the value of `groupInfo`. Subsequent reads from it will return its default value.
  public mutating func clearGroupInfo() {_uniqueStorage()._groupInfo = nil}

  public var ctime: Int64 {
    get {return _storage._ctime}
    set {_uniqueStorage()._ctime = newValue}
  }

  public var mtime: Int64 {
    get {return _storage._mtime}
    set {_uniqueStorage()._mtime = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Common_WordDetail {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var content: String = String()

  public var length: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_PictureInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var resourceURL: String = String()

  public var size: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_PictureDetail {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var list: [Common_PictureInfo] = []

  public var num: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_VideoInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var resourceURL: String = String()

  public var size: UInt64 = 0

  public var timeLength: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_VideoDetail {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var list: [Common_VideoInfo] = []

  public var num: UInt64 = 0

  public var ctime: Int64 = 0

  public var mtime: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_MusicShareDetail {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var resourceURL: String = String()

  public var source: UInt64 = 0

  public var ctime: Int64 = 0

  public var mtime: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_VoiceDetail {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var resourceURL: String = String()

  public var size: UInt64 = 0

  public var timeLength: UInt64 = 0

  public var ctime: Int64 = 0

  public var mtime: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_ShareDetail {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var resourceURL: String = String()

  public var source: UInt64 = 0

  public var ctime: Int64 = 0

  public var mtime: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_ItemDetail {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var detail: Common_ItemDetail.OneOf_Detail? = nil

  public var word: Common_WordDetail {
    get {
      if case .word(let v)? = detail {return v}
      return Common_WordDetail()
    }
    set {detail = .word(newValue)}
  }

  public var pictures: Common_PictureDetail {
    get {
      if case .pictures(let v)? = detail {return v}
      return Common_PictureDetail()
    }
    set {detail = .pictures(newValue)}
  }

  public var video: Common_VideoDetail {
    get {
      if case .video(let v)? = detail {return v}
      return Common_VideoDetail()
    }
    set {detail = .video(newValue)}
  }

  public var music: Common_MusicShareDetail {
    get {
      if case .music(let v)? = detail {return v}
      return Common_MusicShareDetail()
    }
    set {detail = .music(newValue)}
  }

  public var voice: Common_VoiceDetail {
    get {
      if case .voice(let v)? = detail {return v}
      return Common_VoiceDetail()
    }
    set {detail = .voice(newValue)}
  }

  public var share: Common_ShareDetail {
    get {
      if case .share(let v)? = detail {return v}
      return Common_ShareDetail()
    }
    set {detail = .share(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Detail: Equatable {
    case word(Common_WordDetail)
    case pictures(Common_PictureDetail)
    case video(Common_VideoDetail)
    case music(Common_MusicShareDetail)
    case voice(Common_VoiceDetail)
    case share(Common_ShareDetail)

  #if !swift(>=4.1)
    public static func ==(lhs: Common_ItemDetail.OneOf_Detail, rhs: Common_ItemDetail.OneOf_Detail) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.word, .word): return {
        guard case .word(let l) = lhs, case .word(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pictures, .pictures): return {
        guard case .pictures(let l) = lhs, case .pictures(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.video, .video): return {
        guard case .video(let l) = lhs, case .video(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.music, .music): return {
        guard case .music(let l) = lhs, case .music(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.voice, .voice): return {
        guard case .voice(let l) = lhs, case .voice(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.share, .share): return {
        guard case .share(let l) = lhs, case .share(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Common_ItemInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var groupID: UInt64 = 0

  public var projectID: UInt64 = 0

  public var userID: UInt64 = 0

  public var title: String = String()

  public var content: Common_ItemDetail {
    get {return _content ?? Common_ItemDetail()}
    set {_content = newValue}
  }
  /// Returns true if `content` has been explicitly set.
  public var hasContent: Bool {return self._content != nil}
  /// Clears the value of `content`. Subsequent reads from it will return its default value.
  public mutating func clearContent() {self._content = nil}

  public var itype: Common_ItemType = .allItem

  public var ctime: Int64 = 0

  public var mtime: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _content: Common_ItemDetail? = nil
}

public struct Common_UserProfileInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var ctime: Int64 = 0

  public var description_p: String = String()

  public var avatar: String = String()

  public var mtime: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_GroupProfileInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var groupID: Int64 = 0

  public var ctime: Int64 = 0

  public var mtime: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Common_UserPrivate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var connectType: Int64 = 0

  public var ctime: Int64 = 0

  public var mtime: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Common_LikeType: @unchecked Sendable {}
extension Common_GenderType: @unchecked Sendable {}
extension Common_UserStatus: @unchecked Sendable {}
extension Common_GroupStatus: @unchecked Sendable {}
extension Common_ActiveType: @unchecked Sendable {}
extension Common_ItemType: @unchecked Sendable {}
extension Common_AuthType: @unchecked Sendable {}
extension Common_VisibleType: @unchecked Sendable {}
extension Common_Tags: @unchecked Sendable {}
extension Common_UserInfo: @unchecked Sendable {}
extension Common_GroupInfo: @unchecked Sendable {}
extension Common_ProjectInfo: @unchecked Sendable {}
extension Common_ProjectProfileInfo: @unchecked Sendable {}
extension Common_ActiveInfo: @unchecked Sendable {}
extension Common_WordDetail: @unchecked Sendable {}
extension Common_PictureInfo: @unchecked Sendable {}
extension Common_PictureDetail: @unchecked Sendable {}
extension Common_VideoInfo: @unchecked Sendable {}
extension Common_VideoDetail: @unchecked Sendable {}
extension Common_MusicShareDetail: @unchecked Sendable {}
extension Common_VoiceDetail: @unchecked Sendable {}
extension Common_ShareDetail: @unchecked Sendable {}
extension Common_ItemDetail: @unchecked Sendable {}
extension Common_ItemDetail.OneOf_Detail: @unchecked Sendable {}
extension Common_ItemInfo: @unchecked Sendable {}
extension Common_UserProfileInfo: @unchecked Sendable {}
extension Common_GroupProfileInfo: @unchecked Sendable {}
extension Common_UserPrivate: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "common"

extension Common_LikeType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Browser"),
    1: .same(proto: "Left"),
    2: .same(proto: "Middle"),
    3: .same(proto: "Right"),
  ]
}

extension Common_GenderType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "None"),
    1: .same(proto: "Man"),
    2: .same(proto: "Women"),
    3: .same(proto: "Double"),
  ]
}

extension Common_UserStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Rest"),
    1: .same(proto: "Study"),
    2: .same(proto: "Busy"),
    3: .same(proto: "Working"),
    4: .same(proto: "Invisible"),
    5: .same(proto: "Idle"),
  ]
}

extension Common_GroupStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NotReady"),
    1: .same(proto: "Normal"),
    2: .same(proto: "ViewOnly"),
    3: .same(proto: "Abandon"),
  ]
}

extension Common_ActiveType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AllActive"),
    1: .same(proto: "Like"),
    2: .same(proto: "Share"),
    3: .same(proto: "Comment"),
    4: .same(proto: "Collect"),
    5: .same(proto: "DisAgree"),
  ]
}

extension Common_ItemType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AllItem"),
    1: .same(proto: "ShortWord"),
    2: .same(proto: "Paper"),
    3: .same(proto: "Picture"),
    4: .same(proto: "Video"),
    5: .same(proto: "Music"),
    6: .same(proto: "Link"),
    7: .same(proto: "Location"),
  ]
}

extension Common_AuthType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NotSupport"),
    1: .same(proto: "WithPhone"),
    2: .same(proto: "WithEmail"),
  ]
}

extension Common_VisibleType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AllPublic"),
    1: .same(proto: "Public"),
    2: .same(proto: "Private"),
    3: .same(proto: "Someone"),
  ]
}

extension Common_Tags: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Tags"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .same(proto: "creatorID"),
    3: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.creatorID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.groupID != 0 {
      try visitor.visitSingularUInt64Field(value: self.groupID, fieldNumber: 1)
    }
    if self.creatorID != 0 {
      try visitor.visitSingularUInt64Field(value: self.creatorID, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_Tags, rhs: Common_Tags) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.creatorID != rhs.creatorID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_UserInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .same(proto: "name"),
    3: .same(proto: "avatar"),
    4: .same(proto: "email"),
    5: .same(proto: "location"),
    6: .same(proto: "desc"),
    9: .same(proto: "Ctime"),
    10: .same(proto: "Mtime"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.avatar) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.email) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.location) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.desc) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.ctime) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.mtime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularUInt64Field(value: self.userID, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.avatar.isEmpty {
      try visitor.visitSingularStringField(value: self.avatar, fieldNumber: 3)
    }
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 4)
    }
    if !self.location.isEmpty {
      try visitor.visitSingularStringField(value: self.location, fieldNumber: 5)
    }
    if !self.desc.isEmpty {
      try visitor.visitSingularStringField(value: self.desc, fieldNumber: 6)
    }
    if self.ctime != 0 {
      try visitor.visitSingularInt64Field(value: self.ctime, fieldNumber: 9)
    }
    if self.mtime != 0 {
      try visitor.visitSingularInt64Field(value: self.mtime, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_UserInfo, rhs: Common_UserInfo) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.avatar != rhs.avatar {return false}
    if lhs.email != rhs.email {return false}
    if lhs.location != rhs.location {return false}
    if lhs.desc != rhs.desc {return false}
    if lhs.ctime != rhs.ctime {return false}
    if lhs.mtime != rhs.mtime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_GroupInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .same(proto: "name"),
    3: .same(proto: "avatar"),
    4: .same(proto: "desc"),
    5: .same(proto: "creator"),
    6: .same(proto: "owner"),
    7: .same(proto: "tags"),
    9: .same(proto: "Ctime"),
    10: .same(proto: "Mtime"),
  ]

  fileprivate class _StorageClass {
    var _groupID: UInt64 = 0
    var _name: String = String()
    var _avatar: String = String()
    var _desc: String = String()
    var _creator: Common_UserInfo? = nil
    var _owner: Common_UserInfo? = nil
    var _tags: [Common_Tags] = []
    var _ctime: Int64 = 0
    var _mtime: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _groupID = source._groupID
      _name = source._name
      _avatar = source._avatar
      _desc = source._desc
      _creator = source._creator
      _owner = source._owner
      _tags = source._tags
      _ctime = source._ctime
      _mtime = source._mtime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._groupID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._avatar) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._desc) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._creator) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._owner) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._tags) }()
        case 9: try { try decoder.decodeSingularInt64Field(value: &_storage._ctime) }()
        case 10: try { try decoder.decodeSingularInt64Field(value: &_storage._mtime) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._groupID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._groupID, fieldNumber: 1)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
      if !_storage._avatar.isEmpty {
        try visitor.visitSingularStringField(value: _storage._avatar, fieldNumber: 3)
      }
      if !_storage._desc.isEmpty {
        try visitor.visitSingularStringField(value: _storage._desc, fieldNumber: 4)
      }
      try { if let v = _storage._creator {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._owner {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._tags.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tags, fieldNumber: 7)
      }
      if _storage._ctime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._ctime, fieldNumber: 9)
      }
      if _storage._mtime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._mtime, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_GroupInfo, rhs: Common_GroupInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._groupID != rhs_storage._groupID {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._avatar != rhs_storage._avatar {return false}
        if _storage._desc != rhs_storage._desc {return false}
        if _storage._creator != rhs_storage._creator {return false}
        if _storage._owner != rhs_storage._owner {return false}
        if _storage._tags != rhs_storage._tags {return false}
        if _storage._ctime != rhs_storage._ctime {return false}
        if _storage._mtime != rhs_storage._mtime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_ProjectInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProjectInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .standard(proto: "group_id"),
    3: .same(proto: "name"),
    4: .same(proto: "avatar"),
    5: .same(proto: "creator"),
    6: .same(proto: "owner"),
    7: .same(proto: "tags"),
    8: .same(proto: "visable"),
    9: .same(proto: "isAchieve"),
    10: .same(proto: "isClose"),
    19: .same(proto: "Ctime"),
    20: .same(proto: "Mtime"),
  ]

  fileprivate class _StorageClass {
    var _projectID: UInt64 = 0
    var _groupID: UInt32 = 0
    var _name: String = String()
    var _avatar: String = String()
    var _creator: Common_UserInfo? = nil
    var _owner: Common_UserInfo? = nil
    var _tags: [Common_Tags] = []
    var _visable: Common_VisibleType = .allPublic
    var _isAchieve: Bool = false
    var _isClose: Bool = false
    var _ctime: Int64 = 0
    var _mtime: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _projectID = source._projectID
      _groupID = source._groupID
      _name = source._name
      _avatar = source._avatar
      _creator = source._creator
      _owner = source._owner
      _tags = source._tags
      _visable = source._visable
      _isAchieve = source._isAchieve
      _isClose = source._isClose
      _ctime = source._ctime
      _mtime = source._mtime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._projectID) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._groupID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._avatar) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._creator) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._owner) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._tags) }()
        case 8: try { try decoder.decodeSingularEnumField(value: &_storage._visable) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._isAchieve) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._isClose) }()
        case 19: try { try decoder.decodeSingularInt64Field(value: &_storage._ctime) }()
        case 20: try { try decoder.decodeSingularInt64Field(value: &_storage._mtime) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._projectID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._projectID, fieldNumber: 1)
      }
      if _storage._groupID != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._groupID, fieldNumber: 2)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 3)
      }
      if !_storage._avatar.isEmpty {
        try visitor.visitSingularStringField(value: _storage._avatar, fieldNumber: 4)
      }
      try { if let v = _storage._creator {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._owner {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._tags.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tags, fieldNumber: 7)
      }
      if _storage._visable != .allPublic {
        try visitor.visitSingularEnumField(value: _storage._visable, fieldNumber: 8)
      }
      if _storage._isAchieve != false {
        try visitor.visitSingularBoolField(value: _storage._isAchieve, fieldNumber: 9)
      }
      if _storage._isClose != false {
        try visitor.visitSingularBoolField(value: _storage._isClose, fieldNumber: 10)
      }
      if _storage._ctime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._ctime, fieldNumber: 19)
      }
      if _storage._mtime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._mtime, fieldNumber: 20)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_ProjectInfo, rhs: Common_ProjectInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._projectID != rhs_storage._projectID {return false}
        if _storage._groupID != rhs_storage._groupID {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._avatar != rhs_storage._avatar {return false}
        if _storage._creator != rhs_storage._creator {return false}
        if _storage._owner != rhs_storage._owner {return false}
        if _storage._tags != rhs_storage._tags {return false}
        if _storage._visable != rhs_storage._visable {return false}
        if _storage._isAchieve != rhs_storage._isAchieve {return false}
        if _storage._isClose != rhs_storage._isClose {return false}
        if _storage._ctime != rhs_storage._ctime {return false}
        if _storage._mtime != rhs_storage._mtime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_ProjectProfileInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProjectProfileInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .standard(proto: "group_id"),
    3: .same(proto: "Description"),
    5: .same(proto: "WatchingCount"),
    6: .same(proto: "InvolvedCount"),
    7: .same(proto: "Avatar"),
    8: .same(proto: "visable"),
    9: .same(proto: "isAchieve"),
    10: .same(proto: "isClose"),
    11: .same(proto: "isPrivate"),
    19: .same(proto: "Ctime"),
    20: .same(proto: "Mtime"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.groupID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.watchingCount) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.involvedCount) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.avatar) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.visable) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.isAchieve) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.isClose) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.isPrivate) }()
      case 19: try { try decoder.decodeSingularInt64Field(value: &self.ctime) }()
      case 20: try { try decoder.decodeSingularInt64Field(value: &self.mtime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.projectID != 0 {
      try visitor.visitSingularUInt64Field(value: self.projectID, fieldNumber: 1)
    }
    if self.groupID != 0 {
      try visitor.visitSingularUInt32Field(value: self.groupID, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if self.watchingCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.watchingCount, fieldNumber: 5)
    }
    if self.involvedCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.involvedCount, fieldNumber: 6)
    }
    if !self.avatar.isEmpty {
      try visitor.visitSingularStringField(value: self.avatar, fieldNumber: 7)
    }
    if self.visable != .allPublic {
      try visitor.visitSingularEnumField(value: self.visable, fieldNumber: 8)
    }
    if self.isAchieve != false {
      try visitor.visitSingularBoolField(value: self.isAchieve, fieldNumber: 9)
    }
    if self.isClose != false {
      try visitor.visitSingularBoolField(value: self.isClose, fieldNumber: 10)
    }
    if self.isPrivate != false {
      try visitor.visitSingularBoolField(value: self.isPrivate, fieldNumber: 11)
    }
    if self.ctime != 0 {
      try visitor.visitSingularInt64Field(value: self.ctime, fieldNumber: 19)
    }
    if self.mtime != 0 {
      try visitor.visitSingularInt64Field(value: self.mtime, fieldNumber: 20)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_ProjectProfileInfo, rhs: Common_ProjectProfileInfo) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.watchingCount != rhs.watchingCount {return false}
    if lhs.involvedCount != rhs.involvedCount {return false}
    if lhs.avatar != rhs.avatar {return false}
    if lhs.visable != rhs.visable {return false}
    if lhs.isAchieve != rhs.isAchieve {return false}
    if lhs.isClose != rhs.isClose {return false}
    if lhs.isPrivate != rhs.isPrivate {return false}
    if lhs.ctime != rhs.ctime {return false}
    if lhs.mtime != rhs.mtime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_ActiveInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActiveInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "user"),
    2: .same(proto: "activeType"),
    3: .same(proto: "itemInfo"),
    4: .same(proto: "projectInfo"),
    5: .same(proto: "groupInfo"),
    9: .same(proto: "Ctime"),
    10: .same(proto: "Mtime"),
  ]

  fileprivate class _StorageClass {
    var _user: Common_UserInfo? = nil
    var _activeType: Common_ActiveType = .allActive
    var _itemInfo: Common_ItemInfo? = nil
    var _projectInfo: Common_ProjectInfo? = nil
    var _groupInfo: Common_GroupInfo? = nil
    var _ctime: Int64 = 0
    var _mtime: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _user = source._user
      _activeType = source._activeType
      _itemInfo = source._itemInfo
      _projectInfo = source._projectInfo
      _groupInfo = source._groupInfo
      _ctime = source._ctime
      _mtime = source._mtime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._activeType) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._itemInfo) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._projectInfo) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._groupInfo) }()
        case 9: try { try decoder.decodeSingularInt64Field(value: &_storage._ctime) }()
        case 10: try { try decoder.decodeSingularInt64Field(value: &_storage._mtime) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if _storage._activeType != .allActive {
        try visitor.visitSingularEnumField(value: _storage._activeType, fieldNumber: 2)
      }
      try { if let v = _storage._itemInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._projectInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._groupInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if _storage._ctime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._ctime, fieldNumber: 9)
      }
      if _storage._mtime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._mtime, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_ActiveInfo, rhs: Common_ActiveInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._user != rhs_storage._user {return false}
        if _storage._activeType != rhs_storage._activeType {return false}
        if _storage._itemInfo != rhs_storage._itemInfo {return false}
        if _storage._projectInfo != rhs_storage._projectInfo {return false}
        if _storage._groupInfo != rhs_storage._groupInfo {return false}
        if _storage._ctime != rhs_storage._ctime {return false}
        if _storage._mtime != rhs_storage._mtime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_WordDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WordDetail"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "content"),
    2: .same(proto: "length"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.content) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.length) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 1)
    }
    if self.length != 0 {
      try visitor.visitSingularUInt64Field(value: self.length, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_WordDetail, rhs: Common_WordDetail) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.length != rhs.length {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_PictureInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PictureInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "resource_url"),
    2: .same(proto: "size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.resourceURL) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.size) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.resourceURL.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceURL, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularUInt64Field(value: self.size, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_PictureInfo, rhs: Common_PictureInfo) -> Bool {
    if lhs.resourceURL != rhs.resourceURL {return false}
    if lhs.size != rhs.size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_PictureDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PictureDetail"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "list"),
    2: .same(proto: "num"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.num) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 1)
    }
    if self.num != 0 {
      try visitor.visitSingularUInt64Field(value: self.num, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_PictureDetail, rhs: Common_PictureDetail) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.num != rhs.num {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_VideoInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VideoInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "resource_url"),
    2: .same(proto: "size"),
    3: .same(proto: "timeLength"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.resourceURL) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.size) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.timeLength) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.resourceURL.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceURL, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularUInt64Field(value: self.size, fieldNumber: 2)
    }
    if self.timeLength != 0 {
      try visitor.visitSingularUInt64Field(value: self.timeLength, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_VideoInfo, rhs: Common_VideoInfo) -> Bool {
    if lhs.resourceURL != rhs.resourceURL {return false}
    if lhs.size != rhs.size {return false}
    if lhs.timeLength != rhs.timeLength {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_VideoDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VideoDetail"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "list"),
    2: .same(proto: "num"),
    9: .same(proto: "Ctime"),
    10: .same(proto: "Mtime"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.num) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.ctime) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.mtime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 1)
    }
    if self.num != 0 {
      try visitor.visitSingularUInt64Field(value: self.num, fieldNumber: 2)
    }
    if self.ctime != 0 {
      try visitor.visitSingularInt64Field(value: self.ctime, fieldNumber: 9)
    }
    if self.mtime != 0 {
      try visitor.visitSingularInt64Field(value: self.mtime, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_VideoDetail, rhs: Common_VideoDetail) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.num != rhs.num {return false}
    if lhs.ctime != rhs.ctime {return false}
    if lhs.mtime != rhs.mtime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_MusicShareDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MusicShareDetail"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "resourceUrl"),
    2: .same(proto: "source"),
    9: .same(proto: "Ctime"),
    10: .same(proto: "Mtime"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.resourceURL) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.source) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.ctime) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.mtime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.resourceURL.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceURL, fieldNumber: 1)
    }
    if self.source != 0 {
      try visitor.visitSingularUInt64Field(value: self.source, fieldNumber: 2)
    }
    if self.ctime != 0 {
      try visitor.visitSingularInt64Field(value: self.ctime, fieldNumber: 9)
    }
    if self.mtime != 0 {
      try visitor.visitSingularInt64Field(value: self.mtime, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_MusicShareDetail, rhs: Common_MusicShareDetail) -> Bool {
    if lhs.resourceURL != rhs.resourceURL {return false}
    if lhs.source != rhs.source {return false}
    if lhs.ctime != rhs.ctime {return false}
    if lhs.mtime != rhs.mtime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_VoiceDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VoiceDetail"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "resourceUrl"),
    2: .same(proto: "size"),
    3: .same(proto: "timeLength"),
    9: .same(proto: "Ctime"),
    10: .same(proto: "Mtime"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.resourceURL) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.size) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.timeLength) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.ctime) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.mtime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.resourceURL.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceURL, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularUInt64Field(value: self.size, fieldNumber: 2)
    }
    if self.timeLength != 0 {
      try visitor.visitSingularUInt64Field(value: self.timeLength, fieldNumber: 3)
    }
    if self.ctime != 0 {
      try visitor.visitSingularInt64Field(value: self.ctime, fieldNumber: 9)
    }
    if self.mtime != 0 {
      try visitor.visitSingularInt64Field(value: self.mtime, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_VoiceDetail, rhs: Common_VoiceDetail) -> Bool {
    if lhs.resourceURL != rhs.resourceURL {return false}
    if lhs.size != rhs.size {return false}
    if lhs.timeLength != rhs.timeLength {return false}
    if lhs.ctime != rhs.ctime {return false}
    if lhs.mtime != rhs.mtime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_ShareDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShareDetail"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "resourceUrl"),
    2: .same(proto: "source"),
    9: .same(proto: "Ctime"),
    10: .same(proto: "Mtime"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.resourceURL) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.source) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.ctime) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.mtime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.resourceURL.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceURL, fieldNumber: 1)
    }
    if self.source != 0 {
      try visitor.visitSingularUInt64Field(value: self.source, fieldNumber: 2)
    }
    if self.ctime != 0 {
      try visitor.visitSingularInt64Field(value: self.ctime, fieldNumber: 9)
    }
    if self.mtime != 0 {
      try visitor.visitSingularInt64Field(value: self.mtime, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_ShareDetail, rhs: Common_ShareDetail) -> Bool {
    if lhs.resourceURL != rhs.resourceURL {return false}
    if lhs.source != rhs.source {return false}
    if lhs.ctime != rhs.ctime {return false}
    if lhs.mtime != rhs.mtime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_ItemDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ItemDetail"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "word"),
    2: .same(proto: "pictures"),
    3: .same(proto: "video"),
    4: .same(proto: "music"),
    5: .same(proto: "voice"),
    6: .same(proto: "share"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Common_WordDetail?
        var hadOneofValue = false
        if let current = self.detail {
          hadOneofValue = true
          if case .word(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.detail = .word(v)
        }
      }()
      case 2: try {
        var v: Common_PictureDetail?
        var hadOneofValue = false
        if let current = self.detail {
          hadOneofValue = true
          if case .pictures(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.detail = .pictures(v)
        }
      }()
      case 3: try {
        var v: Common_VideoDetail?
        var hadOneofValue = false
        if let current = self.detail {
          hadOneofValue = true
          if case .video(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.detail = .video(v)
        }
      }()
      case 4: try {
        var v: Common_MusicShareDetail?
        var hadOneofValue = false
        if let current = self.detail {
          hadOneofValue = true
          if case .music(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.detail = .music(v)
        }
      }()
      case 5: try {
        var v: Common_VoiceDetail?
        var hadOneofValue = false
        if let current = self.detail {
          hadOneofValue = true
          if case .voice(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.detail = .voice(v)
        }
      }()
      case 6: try {
        var v: Common_ShareDetail?
        var hadOneofValue = false
        if let current = self.detail {
          hadOneofValue = true
          if case .share(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.detail = .share(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.detail {
    case .word?: try {
      guard case .word(let v)? = self.detail else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .pictures?: try {
      guard case .pictures(let v)? = self.detail else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .video?: try {
      guard case .video(let v)? = self.detail else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .music?: try {
      guard case .music(let v)? = self.detail else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .voice?: try {
      guard case .voice(let v)? = self.detail else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .share?: try {
      guard case .share(let v)? = self.detail else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_ItemDetail, rhs: Common_ItemDetail) -> Bool {
    if lhs.detail != rhs.detail {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_ItemInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ItemInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .standard(proto: "project_id"),
    3: .standard(proto: "user_id"),
    4: .same(proto: "title"),
    5: .same(proto: "content"),
    6: .same(proto: "itype"),
    9: .same(proto: "Ctime"),
    10: .same(proto: "Mtime"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.projectID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.userID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._content) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.itype) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.ctime) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.mtime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.groupID != 0 {
      try visitor.visitSingularUInt64Field(value: self.groupID, fieldNumber: 1)
    }
    if self.projectID != 0 {
      try visitor.visitSingularUInt64Field(value: self.projectID, fieldNumber: 2)
    }
    if self.userID != 0 {
      try visitor.visitSingularUInt64Field(value: self.userID, fieldNumber: 3)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 4)
    }
    try { if let v = self._content {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.itype != .allItem {
      try visitor.visitSingularEnumField(value: self.itype, fieldNumber: 6)
    }
    if self.ctime != 0 {
      try visitor.visitSingularInt64Field(value: self.ctime, fieldNumber: 9)
    }
    if self.mtime != 0 {
      try visitor.visitSingularInt64Field(value: self.mtime, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_ItemInfo, rhs: Common_ItemInfo) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.projectID != rhs.projectID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.title != rhs.title {return false}
    if lhs._content != rhs._content {return false}
    if lhs.itype != rhs.itype {return false}
    if lhs.ctime != rhs.ctime {return false}
    if lhs.mtime != rhs.mtime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_UserProfileInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserProfileInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .same(proto: "Ctime"),
    3: .same(proto: "Description"),
    4: .same(proto: "avatar"),
    10: .same(proto: "Mtime"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.ctime) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.avatar) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.mtime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.ctime != 0 {
      try visitor.visitSingularInt64Field(value: self.ctime, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if !self.avatar.isEmpty {
      try visitor.visitSingularStringField(value: self.avatar, fieldNumber: 4)
    }
    if self.mtime != 0 {
      try visitor.visitSingularInt64Field(value: self.mtime, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_UserProfileInfo, rhs: Common_UserProfileInfo) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.ctime != rhs.ctime {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.avatar != rhs.avatar {return false}
    if lhs.mtime != rhs.mtime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_GroupProfileInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupProfileInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    9: .same(proto: "Ctime"),
    10: .same(proto: "Mtime"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.groupID) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.ctime) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.mtime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.groupID != 0 {
      try visitor.visitSingularInt64Field(value: self.groupID, fieldNumber: 1)
    }
    if self.ctime != 0 {
      try visitor.visitSingularInt64Field(value: self.ctime, fieldNumber: 9)
    }
    if self.mtime != 0 {
      try visitor.visitSingularInt64Field(value: self.mtime, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_GroupProfileInfo, rhs: Common_GroupProfileInfo) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.ctime != rhs.ctime {return false}
    if lhs.mtime != rhs.mtime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_UserPrivate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserPrivate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ConnectType"),
    2: .same(proto: "Ctime"),
    3: .same(proto: "Mtime"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.connectType) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.ctime) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.mtime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.connectType != 0 {
      try visitor.visitSingularInt64Field(value: self.connectType, fieldNumber: 1)
    }
    if self.ctime != 0 {
      try visitor.visitSingularInt64Field(value: self.ctime, fieldNumber: 2)
    }
    if self.mtime != 0 {
      try visitor.visitSingularInt64Field(value: self.mtime, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_UserPrivate, rhs: Common_UserPrivate) -> Bool {
    if lhs.connectType != rhs.connectType {return false}
    if lhs.ctime != rhs.ctime {return false}
    if lhs.mtime != rhs.mtime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
