// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

//// Token来源枚举
//// 指定生成任务使用的额度来源
public enum Rankquantity_Voyager_Api_TokenSource: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  //// 使用用户自己的token额度
  case userSelf // = 0

  //// 使用故事存储的token额度
  case storyStore // = 1

  //// 使用第三方赞助的token额度
  case thirdParty // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .userSelf
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .userSelf
    case 1: self = .storyStore
    case 2: self = .thirdParty
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .userSelf: return 0
    case .storyStore: return 1
    case .thirdParty: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Rankquantity_Voyager_Api_TokenSource] = [
    .userSelf,
    .storyStore,
    .thirdParty,
  ]

}

//// Token消耗来源类型
public enum Rankquantity_Voyager_Api_TokenSourceType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  //// 未指定
  case tokenSourceUnspecified // = 0

  //// 个人账户
  case tokenSourcePersonal // = 1

  //// 机构/组织账户
  case tokenSourceOrganization // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .tokenSourceUnspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .tokenSourceUnspecified
    case 1: self = .tokenSourcePersonal
    case 2: self = .tokenSourceOrganization
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .tokenSourceUnspecified: return 0
    case .tokenSourcePersonal: return 1
    case .tokenSourceOrganization: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Rankquantity_Voyager_Api_TokenSourceType] = [
    .tokenSourceUnspecified,
    .tokenSourcePersonal,
    .tokenSourceOrganization,
  ]

}

public struct Rankquantity_Voyager_Api_ActiveInfo: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var activeID: Int64 {
    get {return _storage._activeID}
    set {_uniqueStorage()._activeID = newValue}
  }

  public var user: Rankquantity_Voyager_Api_UserInfo {
    get {return _storage._user ?? Rankquantity_Voyager_Api_UserInfo()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  public var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  public mutating func clearUser() {_uniqueStorage()._user = nil}

  public var activeType: Rankquantity_Voyager_Api_ActiveType {
    get {return _storage._activeType}
    set {_uniqueStorage()._activeType = newValue}
  }

  public var groupInfo: Rankquantity_Voyager_Api_GroupInfo {
    get {return _storage._groupInfo ?? Rankquantity_Voyager_Api_GroupInfo()}
    set {_uniqueStorage()._groupInfo = newValue}
  }
  /// Returns true if `groupInfo` has been explicitly set.
  public var hasGroupInfo: Bool {return _storage._groupInfo != nil}
  /// Clears the value of `groupInfo`. Subsequent reads from it will return its default value.
  public mutating func clearGroupInfo() {_uniqueStorage()._groupInfo = nil}

  public var storyInfo: Rankquantity_Voyager_Api_Story {
    get {return _storage._storyInfo ?? Rankquantity_Voyager_Api_Story()}
    set {_uniqueStorage()._storyInfo = newValue}
  }
  /// Returns true if `storyInfo` has been explicitly set.
  public var hasStoryInfo: Bool {return _storage._storyInfo != nil}
  /// Clears the value of `storyInfo`. Subsequent reads from it will return its default value.
  public mutating func clearStoryInfo() {_uniqueStorage()._storyInfo = nil}

  public var roleInfo: Rankquantity_Voyager_Api_StoryRole {
    get {return _storage._roleInfo ?? Rankquantity_Voyager_Api_StoryRole()}
    set {_uniqueStorage()._roleInfo = newValue}
  }
  /// Returns true if `roleInfo` has been explicitly set.
  public var hasRoleInfo: Bool {return _storage._roleInfo != nil}
  /// Clears the value of `roleInfo`. Subsequent reads from it will return its default value.
  public mutating func clearRoleInfo() {_uniqueStorage()._roleInfo = nil}

  public var boardInfo: Rankquantity_Voyager_Api_StoryBoard {
    get {return _storage._boardInfo ?? Rankquantity_Voyager_Api_StoryBoard()}
    set {_uniqueStorage()._boardInfo = newValue}
  }
  /// Returns true if `boardInfo` has been explicitly set.
  public var hasBoardInfo: Bool {return _storage._boardInfo != nil}
  /// Clears the value of `boardInfo`. Subsequent reads from it will return its default value.
  public mutating func clearBoardInfo() {_uniqueStorage()._boardInfo = nil}

  public var content: String {
    get {return _storage._content}
    set {_uniqueStorage()._content = newValue}
  }

  public var ctime: Int64 {
    get {return _storage._ctime}
    set {_uniqueStorage()._ctime = newValue}
  }

  public var mtime: Int64 {
    get {return _storage._mtime}
    set {_uniqueStorage()._mtime = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

//// 用户登录请求
//// 
//// 支持多种登录方式的用户认证，包括密码登录、验证码登录和第三方登录
public struct Rankquantity_Voyager_Api_LoginRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// [必填] 账号
  //// 
  //// 支持邮箱、手机号或用户名
  //// 长度限制：3-100 字符
  public var account: String = String()

  //// [必填] 密码
  //// 
  //// 用户登录密码
  //// 长度限制：6-128 字符
  public var password: String = String()

  //// [必填] 登录类型
  //// 
  //// 指定使用的登录方式：
  //// - 1: 密码登录
  //// - 2: 验证码登录
  //// - 3: 第三方登录
  //// 取值范围：1-3
  public var loginType: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 用户登录响应
//// 返回登录结果和会话信息
public struct Rankquantity_Voyager_Api_LoginResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var msg: String = String()

  public var data: Rankquantity_Voyager_Api_LoginResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_LoginResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  //// 登录成功返回的数据
  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    //// 用户ID
    public var userID: Int64 = 0

    //// 访问令牌
    public var token: String = String()

    //// 当前时间戳
    public var timestamp: Int64 = 0

    //// 令牌过期时间戳
    public var expireAt: Int64 = 0

    //// 账号状态：0-正常，1-冻结，2-待激活
    public var status: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_LoginResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_LogoutRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: String = String()

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_LogoutResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var msg: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_RefreshTokenRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_RefreshTokenResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: String = String()

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 用户注册请求
//// 
//// 创建新用户账号，需要提供完整的注册信息
public struct Rankquantity_Voyager_Api_RegisterRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// [必填] 账号
  //// 
  //// 用户登录账号，用于身份标识
  //// 长度限制：3-50 字符
  //// 格式要求：字母、数字、下划线
  public var account: String = String()

  //// [必填] 密码
  //// 
  //// 用户登录密码
  //// 长度限制：6-128 字符
  //// 安全建议：包含字母、数字和特殊字符
  public var password: String = String()

  //// [必填] 用户昵称
  //// 
  //// 显示名称，用于界面展示
  //// 长度限制：1-50 字符
  public var name: String = String()

  //// [必填] 邮箱地址
  //// 
  //// 用于接收通知和找回密码
  //// 格式要求：符合邮箱格式规范（如 user@example.com）
  public var email: String = String()

  //// [必填] 手机号
  //// 
  //// 用于接收验证码和通知
  //// 长度限制：8-20 字符
  public var phone: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 用户注册响应
//// 返回注册结果
public struct Rankquantity_Voyager_Api_RegisterResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var msg: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_ConfirmRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_ConfirmResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Int32 = 0

  public var timestamp: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_ResetPasswordRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var account: String = String()

  public var oldPwd: String = String()

  public var newPwd: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_ResetPasswordResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var account: String = String()

  public var status: Int64 = 0

  public var timestamp: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// user ,group .project.item
public struct Rankquantity_Voyager_Api_UserInfoRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var account: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UserInfoResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var msg: String = String()

  public var data: Rankquantity_Voyager_Api_UserInfoResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_UserInfoResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var info: Rankquantity_Voyager_Api_UserInfo {
      get {return _info ?? Rankquantity_Voyager_Api_UserInfo()}
      set {_info = newValue}
    }
    /// Returns true if `info` has been explicitly set.
    public var hasInfo: Bool {return self._info != nil}
    /// Clears the value of `info`. Subsequent reads from it will return its default value.
    public mutating func clearInfo() {self._info = nil}

    public var profile: Rankquantity_Voyager_Api_UserProfileInfo {
      get {return _profile ?? Rankquantity_Voyager_Api_UserProfileInfo()}
      set {_profile = newValue}
    }
    /// Returns true if `profile` has been explicitly set.
    public var hasProfile: Bool {return self._profile != nil}
    /// Clears the value of `profile`. Subsequent reads from it will return its default value.
    public mutating func clearProfile() {self._profile = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _info: Rankquantity_Voyager_Api_UserInfo? = nil
    fileprivate var _profile: Rankquantity_Voyager_Api_UserProfileInfo? = nil
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_UserInfoResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_UpdateUserAvatorRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var avatar: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UpdateUserAvatorResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var msg: String = String()

  public var data: Rankquantity_Voyager_Api_UpdateUserAvatorResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_UpdateUserAvatorResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var info: Rankquantity_Voyager_Api_UserInfo {
      get {return _info ?? Rankquantity_Voyager_Api_UserInfo()}
      set {_info = newValue}
    }
    /// Returns true if `info` has been explicitly set.
    public var hasInfo: Bool {return self._info != nil}
    /// Clears the value of `info`. Subsequent reads from it will return its default value.
    public mutating func clearInfo() {self._info = nil}

    public var status: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _info: Rankquantity_Voyager_Api_UserInfo? = nil
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_UpdateUserAvatorResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_UserWatchingRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var timeStamp: Int64 = 0

  public var offset: Int32 = 0

  public var pageSize: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UserWatchingResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var msg: String = String()

  public var data: Rankquantity_Voyager_Api_UserWatchingResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_UserWatchingResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var haveMore: Bool = false

    public var total: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_UserWatchingResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_UserGroupRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var gtype: Rankquantity_Voyager_Api_GroupType = .protect

  public var offset: Int32 = 0

  public var pageSize: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UserGroupResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var msg: String = String()

  public var data: Rankquantity_Voyager_Api_UserGroupResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_UserGroupResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var list: [Rankquantity_Voyager_Api_GroupInfo] = []

    public var offset: Int32 = 0

    public var pageSize: Int32 = 0

    public var total: Int32 = 0

    public var haveMore: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_UserGroupResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_UserFollowingGroupRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var offset: Int32 = 0

  public var pageSize: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UserFollowingGroupResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var msg: String = String()

  public var data: Rankquantity_Voyager_Api_UserFollowingGroupResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_UserFollowingGroupResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var userID: Int64 = 0

    public var list: [Rankquantity_Voyager_Api_GroupInfo] = []

    public var offset: Int64 = 0

    public var pageSize: Int64 = 0

    public var total: Int32 = 0

    public var haveMore: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_UserFollowingGroupResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_UserUpdateRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var nickname: String = String()

  public var avatar: String = String()

  public var desc: String = String()

  public var data: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UserUpdateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var data: Rankquantity_Voyager_Api_UserUpdateResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_UserUpdateResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_UserUpdateResponse.DataMessage? = nil
}

//// 获取动态列表请求
//// 获取用户、群组或故事的活动动态
public struct Rankquantity_Voyager_Api_FetchActivesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  //// 群组ID，可选，用于筛选特定群组的动态
  public var groupID: Int64 = 0

  //// 故事ID，可选，用于筛选特定故事的动态
  public var storyID: Int64 = 0

  //// 故事板ID，可选，用于筛选特定故事板的动态
  public var boardID: Int64 = 0

  //// 动态流类型，指定要获取的动态类型
  public var atype: Rankquantity_Voyager_Api_ActiveFlowType = .allFlowType

  //// 时间戳，用于时间范围筛选，必须大于0
  public var timestamp: Int64 = 0

  //// 偏移量，用于分页，必须大于等于0
  public var offset: Int64 = 0

  //// 每页数量，范围1-100
  public var pageSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 获取动态列表响应
//// 返回活动动态列表
public struct Rankquantity_Voyager_Api_FetchActivesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var msg: String = String()

  public var data: Rankquantity_Voyager_Api_FetchActivesResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_FetchActivesResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  //// 返回数据
  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    //// 动态信息列表
    public var list: [Rankquantity_Voyager_Api_ActiveInfo] = []

    //// 当前时间戳
    public var timestamp: Int64 = 0

    //// 当前偏移量
    public var offset: Int64 = 0

    //// 每页数量
    public var pageSize: Int64 = 0

    //// 是否有更多数据
    public var haveMore: Bool = false

    //// 总数量
    public var total: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_FetchActivesResponse.DataMessage? = nil
}

//// 搜索用户请求
//// 
//// 根据名称搜索用户，支持模糊搜索和精确搜索，可在群组范围内搜索
public struct Rankquantity_Voyager_Api_SearchUserRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// [必填] 搜索关键词
  //// 
  //// 用户名或昵称的搜索关键词
  //// 长度限制：1-100 字符
  //// 支持：中文、英文、数字
  public var name: String = String()

  //// [可选] 群组ID
  //// 
  //// 限定在特定群组内搜索用户
  //// 验证规则：如果提供则必须大于等于 0
  //// 默认值：0（全局搜索）
  public var groupID: Int64 = 0

  //// [可选] 模糊搜索标志
  //// 
  //// 搜索模式选择
  //// 取值说明：
  //// - true: 模糊搜索（包含关键词即可）
  //// - false: 精确匹配（完全相同）
  //// 默认值：true
  public var isFuzzy: Bool = false

  //// [必填] 偏移量
  //// 
  //// 分页查询的起始位置
  //// 验证规则：必须大于等于 0
  public var offset: Int64 = 0

  //// [必填] 每页数量
  //// 
  //// 单页返回的最大记录数
  //// 验证规则：1-100
  //// 建议值：20
  public var pageSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 搜索用户响应
//// 返回匹配的用户列表
public struct Rankquantity_Voyager_Api_SearchUserResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var msg: String = String()

  public var data: Rankquantity_Voyager_Api_SearchUserResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_SearchUserResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  //// 返回数据
  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    //// 用户信息列表
    public var list: [Rankquantity_Voyager_Api_UserInfo] = []

    //// 当前偏移量
    public var offset: Int64 = 0

    //// 每页数量
    public var pageSize: Int64 = 0

    //// 总数量
    public var total: Int32 = 0

    //// 是否有更多数据
    public var haveMore: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_SearchUserResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_UserInitRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var deafaultGroup: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UserInitResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var msg: String = String()

  public var data: Rankquantity_Voyager_Api_UserInitResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_UserInitResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var userID: Int64 = 0

    public var list: [Rankquantity_Voyager_Api_GroupInfo] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_UserInitResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_GetGroupItemsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var groupID: Int64 = 0

  public var userID: Int64 = 0

  public var offset: Int64 = 0

  public var pageSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetGroupItemsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var msg: String = String()

  public var data: Rankquantity_Voyager_Api_GetGroupItemsResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_GetGroupItemsResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var list: [Rankquantity_Voyager_Api_ItemInfo] = []

    public var groupID: Int64 = 0

    public var userID: Int64 = 0

    public var offset: Int64 = 0

    public var pageSize: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_GetGroupItemsResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_GetUserItemsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var offset: Int64 = 0

  public var pageSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetUserItemsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var msg: String = String()

  public var data: Rankquantity_Voyager_Api_GetUserItemsResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_GetUserItemsResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var list: [Rankquantity_Voyager_Api_ItemInfo] = []

    public var userID: Int64 = 0

    public var offset: Int64 = 0

    public var pageSize: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_GetUserItemsResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_GetItemRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var groupID: Int64 = 0

  public var projectID: Int64 = 0

  public var itemID: Int64 = 0

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetItemResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var msg: String = String()

  public var data: Rankquantity_Voyager_Api_GetItemResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_GetItemResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var info: Rankquantity_Voyager_Api_ItemInfo {
      get {return _info ?? Rankquantity_Voyager_Api_ItemInfo()}
      set {_info = newValue}
    }
    /// Returns true if `info` has been explicitly set.
    public var hasInfo: Bool {return self._info != nil}
    /// Clears the value of `info`. Subsequent reads from it will return its default value.
    public mutating func clearInfo() {self._info = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _info: Rankquantity_Voyager_Api_ItemInfo? = nil
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_GetItemResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_CreateItemRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var groupID: Int64 = 0

  public var projectID: Int64 = 0

  public var name: String = String()

  public var atype: Rankquantity_Voyager_Api_ActiveType = .noneActive

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_CreateItemResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var data: Rankquantity_Voyager_Api_CreateItemResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_CreateItemResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var info: Rankquantity_Voyager_Api_ItemInfo {
      get {return _info ?? Rankquantity_Voyager_Api_ItemInfo()}
      set {_info = newValue}
    }
    /// Returns true if `info` has been explicitly set.
    public var hasInfo: Bool {return self._info != nil}
    /// Clears the value of `info`. Subsequent reads from it will return its default value.
    public mutating func clearInfo() {self._info = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _info: Rankquantity_Voyager_Api_ItemInfo? = nil
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_CreateItemResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_UpdateItemRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var groupID: Int64 = 0

  public var projectID: Int64 = 0

  public var itemID: Int64 = 0

  public var info: Rankquantity_Voyager_Api_ItemInfo {
    get {return _info ?? Rankquantity_Voyager_Api_ItemInfo()}
    set {_info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  public var hasInfo: Bool {return self._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  public mutating func clearInfo() {self._info = nil}

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _info: Rankquantity_Voyager_Api_ItemInfo? = nil
}

public struct Rankquantity_Voyager_Api_UpdateItemResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var data: Rankquantity_Voyager_Api_UpdateItemResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_UpdateItemResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var info: Rankquantity_Voyager_Api_ItemInfo {
      get {return _info ?? Rankquantity_Voyager_Api_ItemInfo()}
      set {_info = newValue}
    }
    /// Returns true if `info` has been explicitly set.
    public var hasInfo: Bool {return self._info != nil}
    /// Clears the value of `info`. Subsequent reads from it will return its default value.
    public mutating func clearInfo() {self._info = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _info: Rankquantity_Voyager_Api_ItemInfo? = nil
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_UpdateItemResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_DeleteItemRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var groupID: Int64 = 0

  public var projectID: Int64 = 0

  public var itemID: Int64 = 0

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_DeleteItemResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var data: Rankquantity_Voyager_Api_DeleteItemResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_DeleteItemResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_DeleteItemResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_LikeItemRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var groupID: Int64 = 0

  public var projectID: Int64 = 0

  public var itemID: Int64 = 0

  public var userID: Int64 = 0

  public var islike: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_LikeItemResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var data: Rankquantity_Voyager_Api_LikeItemResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_LikeItemResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_LikeItemResponse.DataMessage? = nil
}

//// 创建群组请求
//// 创建新的协作群组或团队
public struct Rankquantity_Voyager_Api_CreateGroupRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 创建者用户ID，必须大于0
  public var userID: Int64 = 0

  //// 群组名称，必填且长度1-100字符
  public var name: String = String()

  //// 群组描述，最大长度1000字符
  public var description_p: String = String()

  //// 群组头像URL
  public var avatar: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 创建群组响应
//// 返回创建的群组信息
public struct Rankquantity_Voyager_Api_CreateGroupResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  public var data: Rankquantity_Voyager_Api_CreateGroupResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_CreateGroupResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  //// 返回数据
  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    //// 创建的群组信息
    public var info: Rankquantity_Voyager_Api_GroupInfo {
      get {return _info ?? Rankquantity_Voyager_Api_GroupInfo()}
      set {_info = newValue}
    }
    /// Returns true if `info` has been explicitly set.
    public var hasInfo: Bool {return self._info != nil}
    /// Clears the value of `info`. Subsequent reads from it will return its default value.
    public mutating func clearInfo() {self._info = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _info: Rankquantity_Voyager_Api_GroupInfo? = nil
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_CreateGroupResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_GetGroupRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var groupID: Int64 = 0

  public var userID: Int64 = 0

  public var name: String = String()

  public var withProfile: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetGroupResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var data: Rankquantity_Voyager_Api_GetGroupResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_GetGroupResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var info: Rankquantity_Voyager_Api_GroupInfo {
      get {return _info ?? Rankquantity_Voyager_Api_GroupInfo()}
      set {_info = newValue}
    }
    /// Returns true if `info` has been explicitly set.
    public var hasInfo: Bool {return self._info != nil}
    /// Clears the value of `info`. Subsequent reads from it will return its default value.
    public mutating func clearInfo() {self._info = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _info: Rankquantity_Voyager_Api_GroupInfo? = nil
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_GetGroupResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_GetGroupActivesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var groupID: Int64 = 0

  public var atype: Rankquantity_Voyager_Api_ActiveType = .noneActive

  public var offset: Int64 = 0

  public var pageSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetGroupActivesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var data: Rankquantity_Voyager_Api_GetGroupActivesResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_GetGroupActivesResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var list: [Rankquantity_Voyager_Api_ActiveInfo] = []

    public var offset: Int64 = 0

    public var pageSize: Int64 = 0

    public var haveMore: Bool = false

    public var total: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_GetGroupActivesResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_UpdateGroupInfoRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var groupID: Int64 = 0

  public var info: Rankquantity_Voyager_Api_GroupInfo {
    get {return _info ?? Rankquantity_Voyager_Api_GroupInfo()}
    set {_info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  public var hasInfo: Bool {return self._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  public mutating func clearInfo() {self._info = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _info: Rankquantity_Voyager_Api_GroupInfo? = nil
}

public struct Rankquantity_Voyager_Api_UpdateGroupInfoResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var data: Rankquantity_Voyager_Api_UpdateGroupInfoResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_UpdateGroupInfoResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var info: Rankquantity_Voyager_Api_GroupInfo {
      get {return _info ?? Rankquantity_Voyager_Api_GroupInfo()}
      set {_info = newValue}
    }
    /// Returns true if `info` has been explicitly set.
    public var hasInfo: Bool {return self._info != nil}
    /// Clears the value of `info`. Subsequent reads from it will return its default value.
    public mutating func clearInfo() {self._info = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _info: Rankquantity_Voyager_Api_GroupInfo? = nil
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_UpdateGroupInfoResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_DeleteGroupRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var groupID: Int64 = 0

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_DeleteGroupResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var data: Rankquantity_Voyager_Api_DeleteGroupResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_DeleteGroupResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_DeleteGroupResponse.DataMessage? = nil
}

//// 获取群组成员列表请求
//// 分页获取指定群组的所有成员
public struct Rankquantity_Voyager_Api_FetchGroupMembersRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 群组ID，必须大于0
  public var groupID: Int64 = 0

  //// 偏移量，用于分页，必须大于等于0
  public var offset: Int64 = 0

  //// 每页数量，范围1-100
  public var pageSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 获取群组成员列表响应
//// 返回群组的成员列表及分页信息
public struct Rankquantity_Voyager_Api_FetchGroupMembersResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  public var data: Rankquantity_Voyager_Api_FetchGroupMembersResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_FetchGroupMembersResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  //// 返回数据
  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    //// 成员信息列表
    public var list: [Rankquantity_Voyager_Api_UserInfo] = []

    //// 当前偏移量
    public var offset: Int64 = 0

    //// 成员总数
    public var total: Int64 = 0

    //// 是否有更多数据
    public var haveMore: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_FetchGroupMembersResponse.DataMessage? = nil
}

//// 搜索群组请求
//// 根据名称搜索群组，支持不同范围的搜索
public struct Rankquantity_Voyager_Api_SearchGroupRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 搜索关键词，群组名称，长度1-100字符
  public var name: String = String()

  //// 请求用户ID，必须大于0
  public var userID: Int64 = 0

  //// 偏移量，用于分页，必须大于等于0
  public var offset: Int64 = 0

  //// 每页数量，范围1-100
  public var pageSize: Int64 = 0

  //// 搜索范围类型
  public var scope: Rankquantity_Voyager_Api_ScopeType = .protectScope

  //// 故事ID（可选），用于在特定故事相关的群组中搜索
  public var storyID: Int64 = 0

  //// 群组ID（可选），用于在特定群组内搜索
  public var groupID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 搜索群组响应
//// 返回匹配的群组列表
public struct Rankquantity_Voyager_Api_SearchGroupResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  public var data: Rankquantity_Voyager_Api_SearchGroupResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_SearchGroupResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  //// 返回数据
  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    //// 群组信息列表
    public var list: [Rankquantity_Voyager_Api_GroupInfo] = []

    //// 当前偏移量
    public var offset: Int64 = 0

    //// 每页数量
    public var pageSize: Int64 = 0

    //// 是否有更多数据
    public var haveMore: Bool = false

    //// 总数量
    public var total: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_SearchGroupResponse.DataMessage? = nil
}

//// 加入群组请求
//// 用户申请加入指定群组
public struct Rankquantity_Voyager_Api_JoinGroupRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 群组ID，必须大于0
  public var groupID: Int64 = 0

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 加入群组响应
//// 返回加入群组的结果
public struct Rankquantity_Voyager_Api_JoinGroupResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  public var data: Rankquantity_Voyager_Api_JoinGroupResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_JoinGroupResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  //// 返回数据
  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_JoinGroupResponse.DataMessage? = nil
}

//// 离开群组请求
//// 用户退出指定群组
public struct Rankquantity_Voyager_Api_LeaveGroupRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 群组ID，必须大于0
  public var groupID: Int64 = 0

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 离开群组响应
//// 返回离开群组的结果
public struct Rankquantity_Voyager_Api_LeaveGroupResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  public var data: Rankquantity_Voyager_Api_LeaveGroupResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_LeaveGroupResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  //// 返回数据
  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_LeaveGroupResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_DisscussParams: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_CreateDisscussReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_CreateDisscusResp: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var data: Rankquantity_Voyager_Api_CreateDisscusResp.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_CreateDisscusResp.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_CreateDisscusResp.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_GetDisscusReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetDisscusResp: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var data: Rankquantity_Voyager_Api_GetDisscusResp.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_GetDisscusResp.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_GetDisscusResp.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_VersionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_VersionResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var data: Rankquantity_Voyager_Api_VersionResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_VersionResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var version: String = String()

    public var buildTime: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_VersionResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_AboutRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_AboutResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var content: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_ExploreRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_ExploreResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var data: Rankquantity_Voyager_Api_ExploreResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_ExploreResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_ExploreResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_GetProjectMembersRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var projectID: Int32 = 0

  public var userID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetProjectMembersResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var data: Rankquantity_Voyager_Api_GetProjectMembersResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_GetProjectMembersResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var list: [Rankquantity_Voyager_Api_UserInfo] = []

    public var total: Int32 = 0

    public var role: Dictionary<String,Int64> = [:]

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_GetProjectMembersResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_GetProjectWatcherRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var projectID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetProjectWatcherResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var data: Rankquantity_Voyager_Api_GetProjectWatcherResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_GetProjectWatcherResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var list: [Rankquantity_Voyager_Api_UserInfo] = []

    public var total: Int32 = 0

    public var timestamp: Dictionary<Int64,Int64> = [:]

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_GetProjectWatcherResponse.DataMessage? = nil
}

//// 上传图片请求
//// 
//// 上传图片文件到服务器，支持多种常见图片格式
public struct Rankquantity_Voyager_Api_UploadImageRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// [必填] 图片数据
  //// 
  //// 图片的二进制内容
  //// 大小限制：最大 10MB (10485760 字节)
  //// 支持格式：JPEG、PNG、GIF、WebP、BMP
  //// 建议：上传前进行客户端压缩以提高速度
  public var imageData: Data = Data()

  //// [必填] 文件名
  //// 
  //// 包含扩展名的文件名
  //// 长度限制：1-255 字符
  //// 示例：avatar.jpg, cover.png
  public var filename: String = String()

  //// [必填] 文件MIME类型
  //// 
  //// 图片的内容类型标识
  //// 格式要求：必须为有效的图片MIME类型
  //// 允许值：
  //// - image/jpeg 或 image/jpg
  //// - image/png
  //// - image/gif
  //// - image/webp
  //// - image/bmp
  public var contentType: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 上传图片响应
//// 返回上传成功的图片信息
public struct Rankquantity_Voyager_Api_UploadImageResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  public var data: Rankquantity_Voyager_Api_UploadImageResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_UploadImageResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  //// 返回数据
  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    //// 文件唯一标识符
    public var fileID: String = String()

    //// 图片访问URL
    public var url: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_UploadImageResponse.DataMessage? = nil
}

//// 获取故事贡献者请求
//// 获取参与故事创作的所有贡献者列表
public struct Rankquantity_Voyager_Api_GetStoryContributorsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 故事ID，必须大于0
  public var storyID: Int64 = 0

  //// 请求用户ID，必须大于0
  public var userID: Int64 = 0

  //// 偏移量，用于分页，必须大于等于0
  public var offset: Int64 = 0

  //// 每页数量，范围1-100
  public var pageSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 故事贡献者信息
//// 表示参与故事创作的用户信息
public struct Rankquantity_Voyager_Api_StoryContributor: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 贡献者用户ID
  public var userID: Int64 = 0

  //// 贡献者用户名
  public var username: String = String()

  //// 贡献者头像URL
  public var avatar: String = String()

  //// VIP等级，0表示普通用户
  public var viplevel: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 获取故事贡献者响应
//// 返回故事的贡献者列表
public struct Rankquantity_Voyager_Api_GetStoryContributorsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  public var data: Rankquantity_Voyager_Api_GetStoryContributorsResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_GetStoryContributorsResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  //// 返回数据
  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    //// 贡献者列表
    public var list: [Rankquantity_Voyager_Api_StoryContributor] = []

    //// 贡献者总数
    public var total: Int64 = 0

    //// 是否有更多数据
    public var haveMore: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_GetStoryContributorsResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_GetGroupProfileRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var groupID: Int64 = 0

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_GetGroupProfileResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var data: Rankquantity_Voyager_Api_GetGroupProfileResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_GetGroupProfileResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var info: Rankquantity_Voyager_Api_GroupProfileInfo {
      get {return _info ?? Rankquantity_Voyager_Api_GroupProfileInfo()}
      set {_info = newValue}
    }
    /// Returns true if `info` has been explicitly set.
    public var hasInfo: Bool {return self._info != nil}
    /// Clears the value of `info`. Subsequent reads from it will return its default value.
    public mutating func clearInfo() {self._info = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _info: Rankquantity_Voyager_Api_GroupProfileInfo? = nil
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_GetGroupProfileResponse.DataMessage? = nil
}

public struct Rankquantity_Voyager_Api_UpdateGroupProfileRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var groupID: Int64 = 0

  public var info: Rankquantity_Voyager_Api_GroupProfileInfo {
    get {return _info ?? Rankquantity_Voyager_Api_GroupProfileInfo()}
    set {_info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  public var hasInfo: Bool {return self._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  public mutating func clearInfo() {self._info = nil}

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _info: Rankquantity_Voyager_Api_GroupProfileInfo? = nil
}

public struct Rankquantity_Voyager_Api_UpdateGroupProfileResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 获取故事角色海报列表请求
//// 获取指定角色的所有海报图片列表
public struct Rankquantity_Voyager_Api_GetStoryRolePosterListRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 故事ID，必须大于0
  public var storyID: Int64 = 0

  //// 角色ID，必须大于0
  public var roleID: Int64 = 0

  //// 请求用户ID，必须大于0
  public var userID: Int64 = 0

  //// 偏移量，用于分页，必须大于等于0
  public var offset: Int64 = 0

  //// 每页数量，范围1-100
  public var pageSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 角色海报详细信息
//// 表示角色海报图片的完整信息
public struct Rankquantity_Voyager_Api_RolePosterDetail: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 海报ID
  public var id: Int64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  //// 所属故事ID
  public var storyID: Int64 {
    get {return _storage._storyID}
    set {_uniqueStorage()._storyID = newValue}
  }

  //// 所属角色ID
  public var roleID: Int64 {
    get {return _storage._roleID}
    set {_uniqueStorage()._roleID = newValue}
  }

  //// 海报图片URL
  public var posterURL: String {
    get {return _storage._posterURL}
    set {_uniqueStorage()._posterURL = newValue}
  }

  //// 生成提示词
  public var prompt: String {
    get {return _storage._prompt}
    set {_uniqueStorage()._prompt = newValue}
  }

  //// 点赞数
  public var likeCount: Int64 {
    get {return _storage._likeCount}
    set {_uniqueStorage()._likeCount = newValue}
  }

  //// 当前用户是否已点赞
  public var isLikedByUser: Bool {
    get {return _storage._isLikedByUser}
    set {_uniqueStorage()._isLikedByUser = newValue}
  }

  //// 海报创建者信息
  public var creator: Rankquantity_Voyager_Api_UserInfo {
    get {return _storage._creator ?? Rankquantity_Voyager_Api_UserInfo()}
    set {_uniqueStorage()._creator = newValue}
  }
  /// Returns true if `creator` has been explicitly set.
  public var hasCreator: Bool {return _storage._creator != nil}
  /// Clears the value of `creator`. Subsequent reads from it will return its default value.
  public mutating func clearCreator() {_uniqueStorage()._creator = nil}

  //// 创建时间戳
  public var createdAt: Int64 {
    get {return _storage._createdAt}
    set {_uniqueStorage()._createdAt = newValue}
  }

  //// 更新时间戳
  public var updatedAt: Int64 {
    get {return _storage._updatedAt}
    set {_uniqueStorage()._updatedAt = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

//// 获取故事角色海报列表响应
//// 返回角色的海报列表及分页信息
public struct Rankquantity_Voyager_Api_GetStoryRolePosterListResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  //// 海报列表
  public var posters: [Rankquantity_Voyager_Api_RolePosterDetail] = []

  //// 海报总数
  public var total: Int64 = 0

  //// 是否有更多数据
  public var haveMore: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 点赞角色海报请求
//// 为角色海报点赞
public struct Rankquantity_Voyager_Api_LikeStoryRolePosterRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 故事ID，必须大于0
  public var storyID: Int64 = 0

  //// 角色ID，必须大于0
  public var roleID: Int64 = 0

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  //// 海报ID，必须大于0
  public var posterID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 点赞角色海报响应
//// 返回点赞后的最新点赞数
public struct Rankquantity_Voyager_Api_LikeStoryRolePosterResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  //// 当前点赞总数
  public var currentLikeCount: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 取消点赞角色海报请求
//// 取消对角色海报的点赞
public struct Rankquantity_Voyager_Api_UnLikeStoryRolePosterRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 故事ID，必须大于0
  public var storyID: Int64 = 0

  //// 角色ID，必须大于0
  public var roleID: Int64 = 0

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  //// 海报ID，必须大于0
  public var posterID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 取消点赞角色海报响应
//// 返回取消点赞后的最新点赞数
public struct Rankquantity_Voyager_Api_UnLikeStoryRolePosterResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  //// 当前点赞总数
  public var currentLikeCount: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 获取用户生成任务状态请求
//// 查询用户的所有生成任务状态
public struct Rankquantity_Voyager_Api_FetchUserGenTaskStatusRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  //// 任务ID（可选），用于查询特定任务
  public var taskID: String = String()

  //// 时间戳，用于时间筛选
  public var timestamp: Int64 = 0

  //// 页码，从1开始
  public var pageNum: Int64 = 0

  //// 每页数量，范围1-100
  public var pageSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 故事生成任务详情
//// 包含故事生成任务的详细参数和结果
public struct Rankquantity_Voyager_Api_StoryGentaskDetail: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 故事ID
  public var storyID: Int64 = 0

  //// 故事板ID
  public var boardID: Int64 = 0

  //// 故事板描述
  public var storyboardDesc: String = String()

  //// 场景ID
  public var senceID: Int64 = 0

  //// 场景描述
  public var senceDesc: String = String()

  //// 生成提示词
  public var prompt: String = String()

  //// 任务类型：1-图片，2-视频，3-音频
  public var taskType: Int64 = 0

  //// 任务阶段
  public var taskStage: Int64 = 0

  //// 起始图片URL
  public var startImageURL: String = String()

  //// 结束图片URL
  public var endImageURL: String = String()

  //// 生成的视频URL
  public var videoURL: String = String()

  //// 参考图片URL
  public var regImageURL: String = String()

  //// 生成风格
  public var style: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 用户生成任务状态信息
//// 表示单个生成任务的完整状态
public struct Rankquantity_Voyager_Api_UserGenTaskStatus: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 任务ID，唯一标识符
  public var taskID: String {
    get {return _storage._taskID}
    set {_uniqueStorage()._taskID = newValue}
  }

  //// 用户ID
  public var userID: Int64 {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  //// 任务状态：pending, running, success, failed
  public var status: String {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  //// 任务详情
  public var detail: Rankquantity_Voyager_Api_StoryGentaskDetail {
    get {return _storage._detail ?? Rankquantity_Voyager_Api_StoryGentaskDetail()}
    set {_uniqueStorage()._detail = newValue}
  }
  /// Returns true if `detail` has been explicitly set.
  public var hasDetail: Bool {return _storage._detail != nil}
  /// Clears the value of `detail`. Subsequent reads from it will return its default value.
  public mutating func clearDetail() {_uniqueStorage()._detail = nil}

  //// 创建时间戳
  public var createTime: Int64 {
    get {return _storage._createTime}
    set {_uniqueStorage()._createTime = newValue}
  }

  //// 更新时间戳
  public var updateTime: Int64 {
    get {return _storage._updateTime}
    set {_uniqueStorage()._updateTime = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

//// 获取用户生成任务状态响应
//// 返回用户的生成任务列表
public struct Rankquantity_Voyager_Api_FetchUserGenTaskStatusResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  //// 任务状态列表
  public var tasks: [Rankquantity_Voyager_Api_UserGenTaskStatus] = []

  //// 任务总数
  public var total: Int64 = 0

  //// 是否有更多数据
  public var haveMore: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 生成角色头像请求
//// 使用AI为角色生成个性化头像
public struct Rankquantity_Voyager_Api_GenerateRoleAvatarRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 角色ID，必须大于0
  public var roleID: Int64 = 0

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  //// 参考头像URL（可选）
  public var refAvatarURL: String = String()

  //// 角色描述，用于生成头像，最大长度1000字符
  public var description_p: String = String()

  //// 头像风格
  public var style: String = String()

  //// 图片宽高比设置
  public var imageRatios: Rankquantity_Voyager_Api_ImageRatios = .ratio11

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 生成角色头像响应
//// 返回生成的头像URL
public struct Rankquantity_Voyager_Api_GenerateRoleAvatarResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  //// 生成的头像URL
  public var avatarURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 生成故事场景视频请求
//// 
//// 为指定的故事场景生成AI视频内容，支持自定义提示词和风格
public struct Rankquantity_Voyager_Api_GenerateStorySceneVideoRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// [必填] 故事ID
  //// 
  //// 场景所属的故事ID
  //// 验证规则：必须大于 0
  public var storyID: Int64 = 0

  //// [必填] 故事板ID
  //// 
  //// 场景所属的故事板ID
  //// 验证规则：必须大于 0
  public var boardID: Int64 = 0

  //// [必填] 场景ID
  //// 
  //// 要生成视频的场景唯一标识
  //// 验证规则：必须大于 0
  public var senceID: Int64 = 0

  //// [必填] 用户ID
  //// 
  //// 发起生成请求的用户ID
  //// 验证规则：必须大于 0
  //// 用途：用于计费和权限验证
  public var userID: Int64 = 0

  //// [必填] Token来源
  //// 
  //// 指定使用哪种额度来支付生成费用
  //// 取值说明：
  //// - TOKEN_SOURCE_USER_SELF: 使用用户自己的token
  //// - TOKEN_SOURCE_STORY_STORE: 使用故事存储的token
  //// - TOKEN_SOURCE_THIRD_PARTY: 使用第三方赞助token
  public var tokenSource: Rankquantity_Voyager_Api_TokenSource = .userSelf

  //// [可选] 生成提示词
  //// 
  //// 视频生成的提示词描述
  //// 长度限制：最大 2000 字符
  //// 用途：控制视频的内容、风格和细节
  //// 默认值：使用场景描述自动生成
  public var prompt: String = String()

  //// [可选] 负面提示词
  //// 
  //// 指定不希望出现的元素
  //// 长度限制：最大 1000 字符
  //// 用途：避免生成不想要的内容（如暴力、血腥等）
  public var negativePrompt: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 生成故事场景视频任务详情
//// 包含视频生成任务的状态和结果信息
public struct Rankquantity_Voyager_Api_GenerateStorySceneVideoTaskDetail: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 任务ID，唯一标识符
  public var taskID: String = String()

  //// 任务状态
  public var taskStatus: Rankquantity_Voyager_Api_StoryGenStatus = .unspecified

  //// 生成的视频URL
  public var videoURL: String = String()

  //// 视频缩略图URL
  public var videoThumbnailURL: String = String()

  //// 视频时长（秒）
  public var duration: Int64 = 0

  //// 视频分辨率，如 1920x1080
  public var resolution: String = String()

  //// 视频格式，如 mp4, webm
  public var videoFormat: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 生成故事场景视频响应
//// 返回视频生成任务的详细信息
public struct Rankquantity_Voyager_Api_GenerateStorySceneVideoResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  //// 任务详情
  public var detail: Rankquantity_Voyager_Api_GenerateStorySceneVideoTaskDetail {
    get {return _detail ?? Rankquantity_Voyager_Api_GenerateStorySceneVideoTaskDetail()}
    set {_detail = newValue}
  }
  /// Returns true if `detail` has been explicitly set.
  public var hasDetail: Bool {return self._detail != nil}
  /// Clears the value of `detail`. Subsequent reads from it will return its default value.
  public mutating func clearDetail() {self._detail = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _detail: Rankquantity_Voyager_Api_GenerateStorySceneVideoTaskDetail? = nil
}

//// 生成故事角色视频请求
//// 为指定的故事角色生成宣传视频
public struct Rankquantity_Voyager_Api_GenerateStoryRoleVideoRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 故事ID，必须大于0
  public var storyID: Int64 = 0

  //// 角色ID，必须大于0
  public var roleID: Int64 = 0

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  //// 海报ID，必须大于0
  public var posterID: Int64 = 0

  //// 参考背景图片URL
  public var refBackgroundURL: String = String()

  //// 参考头像图片URL
  public var refAvatarURL: String = String()

  //// 文本提示词，最大长度2000字符
  public var textPrompt: String = String()

  //// 图片宽高比设置
  public var imageRatios: Rankquantity_Voyager_Api_ImageRatios = .ratio11

  //// 视频风格
  public var style: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 生成故事角色视频任务详情
//// 包含角色视频生成任务的状态和结果信息
public struct Rankquantity_Voyager_Api_GenerateStoryRoleVideoTaskDetail: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 任务ID，唯一标识符
  public var taskID: String = String()

  //// 任务状态
  public var taskStatus: Rankquantity_Voyager_Api_StoryGenStatus = .unspecified

  //// 生成的视频URL
  public var videoURL: String = String()

  //// 视频缩略图URL
  public var videoThumbnailURL: String = String()

  //// 视频时长（秒）
  public var duration: Int64 = 0

  //// 视频分辨率，如 1920x1080
  public var resolution: String = String()

  //// 视频格式，如 mp4, webm
  public var videoFormat: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 生成故事角色视频响应
//// 返回角色视频生成任务的详细信息
public struct Rankquantity_Voyager_Api_GenerateStoryRoleVideoResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  //// 任务详情
  public var detail: Rankquantity_Voyager_Api_GenerateStoryRoleVideoTaskDetail {
    get {return _detail ?? Rankquantity_Voyager_Api_GenerateStoryRoleVideoTaskDetail()}
    set {_detail = newValue}
  }
  /// Returns true if `detail` has been explicitly set.
  public var hasDetail: Bool {return self._detail != nil}
  /// Clears the value of `detail`. Subsequent reads from it will return its default value.
  public mutating func clearDetail() {self._detail = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _detail: Rankquantity_Voyager_Api_GenerateStoryRoleVideoTaskDetail? = nil
}

//// 获取故事参与者请求
//// 获取参与故事创作的所有用户列表
public struct Rankquantity_Voyager_Api_GetStoryParticipantsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 故事ID，必须大于0
  public var storyID: Int64 = 0

  //// 偏移量，用于分页，必须大于等于0
  public var offset: Int64 = 0

  //// 每页数量，范围1-100
  public var pageSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 获取故事参与者响应
//// 返回故事的参与者列表
public struct Rankquantity_Voyager_Api_GetStoryParticipantsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  //// 参与者列表
  public var participants: [Rankquantity_Voyager_Api_UserInfo] = []

  //// 参与者总数
  public var total: Int64 = 0

  //// 是否有更多数据
  public var haveMore: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 更新故事头像请求
//// 更新故事的头像图片
public struct Rankquantity_Voyager_Api_UpdateStoryAvatarRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 故事ID，必须大于0
  public var storyID: Int64 = 0

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  //// 头像图片URL，必填
  public var avatarURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 更新故事头像响应
//// 返回更新操作的结果
public struct Rankquantity_Voyager_Api_UpdateStoryAvatarResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 更新故事封面请求
//// 更新故事的封面图片
public struct Rankquantity_Voyager_Api_UpdateStoryCoverRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 故事ID，必须大于0
  public var storyID: Int64 = 0

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  //// 封面图片URL
  public var coverURL: String = String()

  //// 是否使用AI生成的封面
  public var useAiCover: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 更新故事封面响应
//// 返回更新操作的结果
public struct Rankquantity_Voyager_Api_UpdateStoryCoverResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 获取故事图片风格请求
//// 获取故事可用的图片风格列表
public struct Rankquantity_Voyager_Api_GetStoryImageStyleRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 故事ID，必须大于0
  public var storyID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 故事风格描述
//// 表示一个图片风格的信息
public struct Rankquantity_Voyager_Api_StoryStyleDesc: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 风格ID
  public var id: Int64 = 0

  //// 风格名称
  public var style: String = String()

  //// 风格描述
  public var description_p: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 获取故事图片风格响应
//// 返回可用的风格列表
public struct Rankquantity_Voyager_Api_GetStoryImageStyleResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  //// 风格列表
  public var style: [Rankquantity_Voyager_Api_StoryStyleDesc] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 更新故事图片风格请求
//// 设置故事使用的图片风格
public struct Rankquantity_Voyager_Api_UpdateStoryImageStyleRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 故事ID，必须大于0
  public var storyID: Int64 = 0

  //// 风格ID，必须大于0
  public var styleID: Int64 = 0

  //// 风格名称
  public var style: String = String()

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 更新故事图片风格响应
//// 返回更新操作的结果
public struct Rankquantity_Voyager_Api_UpdateStoryImageStyleResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 更新故事最大场景数请求
//// 设置故事允许的最大场景数量
public struct Rankquantity_Voyager_Api_UpdateStorySenceMaxNumberRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 故事ID，必须大于0
  public var storyID: Int64 = 0

  //// 最大场景数，范围1-1000
  public var maxNumber: Int64 = 0

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 更新故事最大场景数响应
//// 返回更新操作的结果
public struct Rankquantity_Voyager_Api_UpdateStorySenceMaxNumberResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 更新故事角色提示词请求
//// 更新角色AI生成时使用的提示词
public struct Rankquantity_Voyager_Api_UpdateStoryRolePromptRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 故事ID，必须大于0
  public var storyID: Int64 = 0

  //// 角色ID，必须大于0
  public var roleID: Int64 = 0

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  //// 新的提示词，最大长度2000字符
  public var prompt: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 更新故事角色提示词响应
//// 返回更新操作的结果
public struct Rankquantity_Voyager_Api_UpdateStoryRolePromptResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 更新故事角色描述详情请求
//// 更新角色的详细描述信息
public struct Rankquantity_Voyager_Api_UpdateStoryRoleDescriptionDetailRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 故事ID，必须大于0
  public var storyID: Int64 = 0

  //// 角色ID，必须大于0
  public var roleID: Int64 = 0

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  //// 角色详细描述，必填
  public var characterDetail: Rankquantity_Voyager_Api_CharacterDetail {
    get {return _characterDetail ?? Rankquantity_Voyager_Api_CharacterDetail()}
    set {_characterDetail = newValue}
  }
  /// Returns true if `characterDetail` has been explicitly set.
  public var hasCharacterDetail: Bool {return self._characterDetail != nil}
  /// Clears the value of `characterDetail`. Subsequent reads from it will return its default value.
  public mutating func clearCharacterDetail() {self._characterDetail = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _characterDetail: Rankquantity_Voyager_Api_CharacterDetail? = nil
}

//// 更新故事角色描述详情响应
//// 返回更新操作的结果
public struct Rankquantity_Voyager_Api_UpdateStoryRoleDescriptionDetailResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 生成故事角色参数
//// 包含角色海报生成所需的所有参数
public struct Rankquantity_Voyager_Api_GenerateStoryRoleParams: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 原始参考图片URL
  public var originImageURL: String = String()

  //// 附加参考图片URL列表，最多5张
  public var additionalImageUrls: [String] = []

  //// 文本提示词，最大长度2000字符
  public var textPrompt: String = String()

  //// 负面提示词，最大长度1000字符
  public var negativePrompt: String = String()

  //// 生成风格
  public var style: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 生成故事角色海报请求
//// 为角色生成海报图片
public struct Rankquantity_Voyager_Api_GenerateStoryRolePosterRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 故事ID，必须大于0
  public var storyID: Int64 = 0

  //// 角色ID，必须大于0
  public var roleID: Int64 = 0

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  //// 生成参数，必填
  public var params: Rankquantity_Voyager_Api_GenerateStoryRoleParams {
    get {return _params ?? Rankquantity_Voyager_Api_GenerateStoryRoleParams()}
    set {_params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  public var hasParams: Bool {return self._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  public mutating func clearParams() {self._params = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _params: Rankquantity_Voyager_Api_GenerateStoryRoleParams? = nil
}

//// 生成故事角色海报响应
//// 返回生成的海报信息
public struct Rankquantity_Voyager_Api_GenerateStoryRolePosterResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  //// 生成的海报图片URL
  public var imageURL: String = String()

  //// 海报ID
  public var posterID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 更新故事角色海报请求
//// 更新角色海报的信息或可见性
public struct Rankquantity_Voyager_Api_UpdateStoryRolePosterRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 故事ID，必须大于0
  public var storyID: Int64 = 0

  //// 角色ID，必须大于0
  public var roleID: Int64 = 0

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  //// 海报ID，必须大于0
  public var posterID: Int64 = 0

  //// 新的图片URL
  public var imageURL: String = String()

  //// 是否公开，true表示公开可见
  public var isPublic: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 更新故事角色海报响应
//// 返回更新后的海报ID
public struct Rankquantity_Voyager_Api_UpdateStoryRolePosterResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  //// 海报ID
  public var posterID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 获取关注列表请求
//// 获取用户关注的其他用户列表
public struct Rankquantity_Voyager_Api_GetFollowListRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  //// 偏移量，用于分页，必须大于等于0
  public var offset: Int64 = 0

  //// 每页数量，范围1-100
  public var pageSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 获取关注列表响应
//// 返回用户关注的用户列表
public struct Rankquantity_Voyager_Api_GetFollowListResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  //// 关注的用户列表
  public var followers: [Rankquantity_Voyager_Api_UserInfo] = []

  //// 关注总数
  public var total: Int64 = 0

  //// 是否有更多数据
  public var haveMore: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 获取粉丝列表请求
//// 获取关注该用户的粉丝列表
public struct Rankquantity_Voyager_Api_GetFollowerListRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  //// 偏移量，用于分页，必须大于等于0
  public var offset: Int64 = 0

  //// 每页数量，范围1-100
  public var pageSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 获取粉丝列表响应
//// 返回关注该用户的粉丝列表
public struct Rankquantity_Voyager_Api_GetFollowerListResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  //// 粉丝用户列表
  public var followers: [Rankquantity_Voyager_Api_UserInfo] = []

  //// 粉丝总数
  public var total: Int64 = 0

  //// 是否有更多数据
  public var haveMore: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 关注用户请求
//// 关注另一个用户，建立关注关系
public struct Rankquantity_Voyager_Api_FollowUserRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 发起关注的用户ID，必须大于0
  public var userID: Int64 = 0

  //// 被关注的用户ID，必须大于0
  public var followerID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 关注用户响应
//// 返回关注操作的结果
public struct Rankquantity_Voyager_Api_FollowUserResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 取消关注用户请求
//// 取消对另一个用户的关注
public struct Rankquantity_Voyager_Api_UnfollowUserRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 发起取消关注的用户ID，必须大于0
  public var userID: Int64 = 0

  //// 被取消关注的用户ID，必须大于0
  public var followerID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 取消关注用户响应
//// 返回取消关注操作的结果
public struct Rankquantity_Voyager_Api_UnfollowUserResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 热门故事角色请求
//// 获取指定时间范围内的热门角色列表
public struct Rankquantity_Voyager_Api_TrendingStoryRoleRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 开始时间戳（秒），必须大于0
  public var start: Int64 = 0

  //// 结束时间戳（秒），必须大于开始时间
  public var end: Int64 = 0

  //// 每页数量，范围1-100
  public var pageSize: Int64 = 0

  //// 页码，从1开始
  public var pageNumber: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 热门故事角色响应
//// 返回热门角色列表及分页信息
public struct Rankquantity_Voyager_Api_TrendingStoryRoleResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  public var data: Rankquantity_Voyager_Api_TrendingStoryRoleResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_TrendingStoryRoleResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  //// 返回数据
  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    //// 热门角色列表
    public var list: [Rankquantity_Voyager_Api_StoryRole] = []

    //// 每页数量
    public var pageSize: Int64 = 0

    //// 当前页码
    public var pageNumber: Int64 = 0

    //// 总数量
    public var total: Int64 = 0

    //// 是否有更多数据
    public var haveMore: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_TrendingStoryRoleResponse.DataMessage? = nil
}

//// 热门故事请求
//// 获取指定时间范围内的热门故事列表
public struct Rankquantity_Voyager_Api_TrendingStoryRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 开始时间戳（秒），必须大于0
  public var start: Int64 = 0

  //// 结束时间戳（秒），必须大于开始时间
  public var end: Int64 = 0

  //// 每页数量，范围1-100
  public var pageSize: Int64 = 0

  //// 页码，从1开始
  public var pageNumber: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 热门故事响应
//// 返回热门故事列表及分页信息
public struct Rankquantity_Voyager_Api_TrendingStoryResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  public var data: Rankquantity_Voyager_Api_TrendingStoryResponse.DataMessage {
    get {return _data ?? Rankquantity_Voyager_Api_TrendingStoryResponse.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  //// 返回数据
  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    //// 热门故事列表
    public var list: [Rankquantity_Voyager_Api_Story] = []

    //// 每页数量
    public var pageSize: Int64 = 0

    //// 当前页码
    public var pageNumber: Int64 = 0

    //// 总数量
    public var total: Int64 = 0

    //// 是否有更多数据
    public var haveMore: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_TrendingStoryResponse.DataMessage? = nil
}

//// 获取故事角色列表请求
//// 获取指定故事的角色列表，支持搜索筛选
public struct Rankquantity_Voyager_Api_GetStoryRoleListRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 故事ID，必须大于0
  public var storyID: Int64 = 0

  //// 请求用户ID，必须大于0
  public var userID: Int64 = 0

  //// 故事板ID（可选），用于筛选特定故事板的角色
  public var boardID: Int64 = 0

  //// 搜索关键词（可选），用于搜索角色名称
  public var searchKey: String = String()

  //// 偏移量，用于分页，必须大于等于0
  public var offset: Int64 = 0

  //// 每页数量，范围1-100
  public var pageSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 获取故事角色列表响应
//// 返回故事的角色列表
public struct Rankquantity_Voyager_Api_GetStoryRoleListResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  //// 角色列表
  public var roles: [Rankquantity_Voyager_Api_StoryRole] = []

  //// 角色总数
  public var total: Int64 = 0

  //// 是否有更多数据
  public var haveMore: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 收藏故事请求
//// 将故事添加到用户的收藏夹
public struct Rankquantity_Voyager_Api_ArchiveStoryRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 故事ID，必须大于0
  public var storyID: Int64 = 0

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 收藏故事响应
//// 返回收藏操作的结果
public struct Rankquantity_Voyager_Api_ArchiveStoryResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 创建故事评论请求
//// 
//// 在故事下创建新的评论，支持富文本内容和@提及功能
public struct Rankquantity_Voyager_Api_CreateStoryCommentRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// [必填] 故事ID
  //// 
  //// 要评论的故事唯一标识
  //// 验证规则：必须大于 0
  public var storyID: Int64 = 0

  //// [必填] 评论者用户ID
  //// 
  //// 发表评论的用户ID
  //// 验证规则：必须大于 0
  //// 权限要求：用户必须已登录
  public var userID: Int64 = 0

  //// [必填] 评论内容
  //// 
  //// 评论的文本内容
  //// 长度限制：1-2000 字符
  //// 支持：纯文本、Markdown、@用户提及
  //// 内容要求：不能包含违规内容
  public var content: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 创建故事评论响应
//// 返回创建的评论信息
public struct Rankquantity_Voyager_Api_CreateStoryCommentResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  //// 响应消息
  public var message: String {
    get {return _storage._message}
    set {_uniqueStorage()._message = newValue}
  }

  //// 创建的评论信息
  public var comment: Rankquantity_Voyager_Api_CommentInfo {
    get {return _storage._comment ?? Rankquantity_Voyager_Api_CommentInfo()}
    set {_uniqueStorage()._comment = newValue}
  }
  /// Returns true if `comment` has been explicitly set.
  public var hasComment: Bool {return _storage._comment != nil}
  /// Clears the value of `comment`. Subsequent reads from it will return its default value.
  public mutating func clearComment() {_uniqueStorage()._comment = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

//// 获取故事评论列表请求
//// 分页获取指定故事的评论列表
public struct Rankquantity_Voyager_Api_GetStoryCommentsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 故事ID，必须大于0
  public var storyID: Int64 = 0

  //// 请求用户ID，必须大于0
  public var userID: Int64 = 0

  //// 偏移量，用于分页，必须大于等于0
  public var offset: Int64 = 0

  //// 每页数量，范围1-100
  public var pageSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 故事评论信息
//// 表示单条评论的完整信息
public struct Rankquantity_Voyager_Api_StoryComment: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 评论ID
  public var commentID: Int64 {
    get {return _storage._commentID}
    set {_uniqueStorage()._commentID = newValue}
  }

  //// 所属故事ID
  public var storyID: Int64 {
    get {return _storage._storyID}
    set {_uniqueStorage()._storyID = newValue}
  }

  //// 所属故事板ID（可选）
  public var boardID: Int64 {
    get {return _storage._boardID}
    set {_uniqueStorage()._boardID = newValue}
  }

  //// 相关角色ID（可选）
  public var roleID: Int64 {
    get {return _storage._roleID}
    set {_uniqueStorage()._roleID = newValue}
  }

  //// 上一条评论ID（用于回复链）
  public var prevID: Int64 {
    get {return _storage._prevID}
    set {_uniqueStorage()._prevID = newValue}
  }

  //// 根评论ID（用于楼层结构）
  public var rootCommentID: Int64 {
    get {return _storage._rootCommentID}
    set {_uniqueStorage()._rootCommentID = newValue}
  }

  //// 评论者用户ID
  public var userID: Int64 {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  //// 评论内容
  public var content: String {
    get {return _storage._content}
    set {_uniqueStorage()._content = newValue}
  }

  //// 创建时间
  public var createdAt: Int64 {
    get {return _storage._createdAt}
    set {_uniqueStorage()._createdAt = newValue}
  }

  //// 更新时间
  public var updatedAt: Int64 {
    get {return _storage._updatedAt}
    set {_uniqueStorage()._updatedAt = newValue}
  }

  //// 点赞数
  public var likeCount: Int64 {
    get {return _storage._likeCount}
    set {_uniqueStorage()._likeCount = newValue}
  }

  //// 回复数
  public var replyCount: Int64 {
    get {return _storage._replyCount}
    set {_uniqueStorage()._replyCount = newValue}
  }

  //// 当前用户是否已点赞，1-已点赞，0-未点赞
  public var isLiked: Int64 {
    get {return _storage._isLiked}
    set {_uniqueStorage()._isLiked = newValue}
  }

  //// 评论创建者信息
  public var creator: Rankquantity_Voyager_Api_UserInfo {
    get {return _storage._creator ?? Rankquantity_Voyager_Api_UserInfo()}
    set {_uniqueStorage()._creator = newValue}
  }
  /// Returns true if `creator` has been explicitly set.
  public var hasCreator: Bool {return _storage._creator != nil}
  /// Clears the value of `creator`. Subsequent reads from it will return its default value.
  public mutating func clearCreator() {_uniqueStorage()._creator = nil}

  //// 创建时间戳
  public var createdAtTimestamp: Int64 {
    get {return _storage._createdAtTimestamp}
    set {_uniqueStorage()._createdAtTimestamp = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

//// 获取故事评论列表响应
//// 返回故事的评论列表及分页信息
public struct Rankquantity_Voyager_Api_GetStoryCommentsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  //// 评论列表
  public var comments: [Rankquantity_Voyager_Api_StoryComment] = []

  //// 评论总数
  public var total: Int64 = 0

  //// 当前偏移量
  public var offset: Int64 = 0

  //// 每页数量
  public var pageSize: Int64 = 0

  //// 是否有更多数据
  public var haveMore: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 删除故事评论请求
//// 删除指定的故事评论
public struct Rankquantity_Voyager_Api_DeleteStoryCommentRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 评论ID，必须大于0
  public var commentID: Int64 = 0

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 删除故事评论响应
//// 返回删除操作的结果
public struct Rankquantity_Voyager_Api_DeleteStoryCommentResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 获取故事评论回复列表请求
//// 获取指定评论的所有回复
public struct Rankquantity_Voyager_Api_GetStoryCommentRepliesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 评论ID，必须大于0
  public var commentID: Int64 = 0

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  //// 偏移量，用于分页，必须大于等于0
  public var offset: Int64 = 0

  //// 每页数量，范围1-100
  public var pageSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 获取故事评论回复列表响应
//// 返回评论的回复列表
public struct Rankquantity_Voyager_Api_GetStoryCommentRepliesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  //// 回复列表
  public var replies: [Rankquantity_Voyager_Api_StoryComment] = []

  //// 回复总数
  public var total: Int64 = 0

  //// 当前偏移量
  public var offset: Int64 = 0

  //// 每页数量
  public var pageSize: Int64 = 0

  //// 是否有更多数据
  public var haveMore: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 创建故事评论回复请求
//// 回复指定的故事评论
public struct Rankquantity_Voyager_Api_CreateStoryCommentReplyRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 评论ID，必须大于0
  public var commentID: Int64 = 0

  //// 回复者用户ID，必须大于0
  public var userID: Int64 = 0

  //// 回复内容，必填且长度1-2000字符
  public var content: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 创建故事评论回复响应
//// 返回创建的回复信息
public struct Rankquantity_Voyager_Api_CreateStoryCommentReplyResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  //// 响应消息
  public var message: String {
    get {return _storage._message}
    set {_uniqueStorage()._message = newValue}
  }

  //// 创建的回复信息
  public var comment: Rankquantity_Voyager_Api_CommentInfo {
    get {return _storage._comment ?? Rankquantity_Voyager_Api_CommentInfo()}
    set {_uniqueStorage()._comment = newValue}
  }
  /// Returns true if `comment` has been explicitly set.
  public var hasComment: Bool {return _storage._comment != nil}
  /// Clears the value of `comment`. Subsequent reads from it will return its default value.
  public mutating func clearComment() {_uniqueStorage()._comment = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

//// 删除故事评论回复请求
//// 删除指定的评论回复
public struct Rankquantity_Voyager_Api_DeleteStoryCommentReplyRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 回复ID，必须大于0
  public var replyID: Int64 = 0

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 删除故事评论回复响应
//// 返回删除操作的结果
public struct Rankquantity_Voyager_Api_DeleteStoryCommentReplyResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 获取故事板评论列表请求
//// 分页获取指定故事板的所有评论
public struct Rankquantity_Voyager_Api_GetStoryBoardCommentsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 故事板ID，必须大于0
  public var boardID: Int64 = 0

  //// 请求用户ID，必须大于0
  public var userID: Int64 = 0

  //// 偏移量，用于分页，必须大于等于0
  public var offset: Int64 = 0

  //// 每页数量，范围1-100
  public var pageSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 获取故事板评论列表响应
//// 返回故事板的评论列表及分页信息
public struct Rankquantity_Voyager_Api_GetStoryBoardCommentsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  //// 评论列表
  public var comments: [Rankquantity_Voyager_Api_StoryComment] = []

  //// 评论总数
  public var total: Int64 = 0

  //// 当前偏移量
  public var offset: Int64 = 0

  //// 每页数量
  public var pageSize: Int64 = 0

  //// 是否有更多数据
  public var haveMore: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 创建故事板评论请求
//// 在故事板下创建新的评论
public struct Rankquantity_Voyager_Api_CreateStoryBoardCommentRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 故事板ID，必须大于0
  public var boardID: Int64 = 0

  //// 评论者用户ID，必须大于0
  public var userID: Int64 = 0

  //// 评论内容，必填且长度1-2000字符
  public var content: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 创建故事板评论响应
//// 返回创建的评论信息
public struct Rankquantity_Voyager_Api_CreateStoryBoardCommentResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  //// 响应消息
  public var message: String {
    get {return _storage._message}
    set {_uniqueStorage()._message = newValue}
  }

  //// 创建的评论信息
  public var comment: Rankquantity_Voyager_Api_CommentInfo {
    get {return _storage._comment ?? Rankquantity_Voyager_Api_CommentInfo()}
    set {_uniqueStorage()._comment = newValue}
  }
  /// Returns true if `comment` has been explicitly set.
  public var hasComment: Bool {return _storage._comment != nil}
  /// Clears the value of `comment`. Subsequent reads from it will return its default value.
  public mutating func clearComment() {_uniqueStorage()._comment = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

//// 删除故事板评论请求
//// 删除指定的故事板评论
public struct Rankquantity_Voyager_Api_DeleteStoryBoardCommentRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 故事板ID，必须大于0
  public var boardID: Int64 = 0

  //// 评论ID，必须大于0
  public var commentID: Int64 = 0

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 删除故事板评论响应
//// 返回删除操作的结果
public struct Rankquantity_Voyager_Api_DeleteStoryBoardCommentResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 获取故事板评论回复列表请求
//// 获取指定故事板评论的所有回复
public struct Rankquantity_Voyager_Api_GetStoryBoardCommentRepliesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 评论ID，必须大于0
  public var commentID: Int64 = 0

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  //// 偏移量，用于分页，必须大于等于0
  public var offset: Int64 = 0

  //// 每页数量，范围1-100
  public var pageSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 获取故事板评论回复列表响应
//// 返回评论的回复列表
public struct Rankquantity_Voyager_Api_GetStoryBoardCommentRepliesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  //// 回复列表
  public var replies: [Rankquantity_Voyager_Api_StoryComment] = []

  //// 回复总数
  public var total: Int64 = 0

  //// 当前偏移量
  public var offset: Int64 = 0

  //// 每页数量
  public var pageSize: Int64 = 0

  //// 是否有更多数据
  public var haveMore: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 点赞评论请求
//// 为评论点赞
public struct Rankquantity_Voyager_Api_LikeCommentRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 评论ID，必须大于0
  public var commentID: Int64 = 0

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 点赞评论响应
//// 返回点赞操作的结果
public struct Rankquantity_Voyager_Api_LikeCommentResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 取消点赞评论请求
//// 取消对评论的点赞
public struct Rankquantity_Voyager_Api_DislikeCommentRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 评论ID，必须大于0
  public var commentID: Int64 = 0

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 取消点赞评论响应
//// 返回取消点赞操作的结果
public struct Rankquantity_Voyager_Api_DislikeCommentResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 更新角色提示词请求
//// 更新角色的生成提示词
public struct Rankquantity_Voyager_Api_UpdateRolePromptRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  //// 角色ID，必须大于0
  public var roleID: Int64 = 0

  //// 新的提示词，最大长度2000字符
  public var prompt: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 更新角色提示词响应
//// 返回更新操作的结果
public struct Rankquantity_Voyager_Api_UpdateRolePromptResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 生成角色提示词请求
//// 使用AI为角色生成优化的提示词
public struct Rankquantity_Voyager_Api_GenerateRolePromptRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 故事ID，必须大于0
  public var storyID: Int64 = 0

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  //// 角色ID，必须大于0
  public var roleID: Int64 = 0

  //// 基础提示词，最大长度2000字符
  public var prompt: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 生成角色提示词响应
//// 返回AI生成的优化提示词
public struct Rankquantity_Voyager_Api_GenerateRolePromptResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  //// 生成的提示词
  public var prompt: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 更新角色描述请求
//// 更新角色的文本描述
public struct Rankquantity_Voyager_Api_UpdateRoleDescriptionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  //// 角色ID，必须大于0
  public var roleID: Int64 = 0

  //// 新的描述内容，最大长度2000字符
  public var description_p: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 更新角色描述响应
//// 返回更新操作的结果
public struct Rankquantity_Voyager_Api_UpdateRoleDescriptionResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 生成角色描述请求
//// 使用AI为角色生成详细的描述信息
public struct Rankquantity_Voyager_Api_GenerateRoleDescriptionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 故事ID，必须大于0
  public var storyID: Int64 = 0

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  //// 角色ID，必须大于0
  public var roleID: Int64 = 0

  //// 基础描述，最大长度2000字符
  public var description_p: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 生成角色描述响应
//// 返回AI生成的详细角色描述
public struct Rankquantity_Voyager_Api_GenerateRoleDescriptionResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  //// 生成的角色详细信息
  public var characterDetail: Rankquantity_Voyager_Api_CharacterDetail {
    get {return _characterDetail ?? Rankquantity_Voyager_Api_CharacterDetail()}
    set {_characterDetail = newValue}
  }
  /// Returns true if `characterDetail` has been explicitly set.
  public var hasCharacterDetail: Bool {return self._characterDetail != nil}
  /// Clears the value of `characterDetail`. Subsequent reads from it will return its default value.
  public mutating func clearCharacterDetail() {self._characterDetail = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _characterDetail: Rankquantity_Voyager_Api_CharacterDetail? = nil
}

//// 获取未发布故事板请求
//// 获取用户所有未发布状态的故事板列表
public struct Rankquantity_Voyager_Api_GetUnPublishStoryboardRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  //// 偏移量，用于分页，必须大于等于0
  public var offset: Int64 = 0

  //// 每页数量，范围1-100
  public var pageSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 获取未发布故事板响应
//// 返回未发布的故事板列表
public struct Rankquantity_Voyager_Api_GetUnPublishStoryboardResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  //// 故事板活动列表
  public var storyboardactives: [Rankquantity_Voyager_Api_StoryBoardActive] = []

  //// 总数量
  public var total: Int64 = 0

  //// 当前偏移量
  public var offset: Int64 = 0

  //// 每页数量
  public var pageSize: Int64 = 0

  //// 是否有更多数据
  public var haveMore: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 获取用户关注角色的活跃故事板请求
//// 获取用户关注的角色参与的活跃故事板列表
public struct Rankquantity_Voyager_Api_GetUserWatchRoleActiveStoryBoardsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  //// 角色ID，必须大于0
  public var roleID: Int64 = 0

  //// 偏移量，用于分页，必须大于等于0
  public var offset: Int64 = 0

  //// 每页数量，范围1-100
  public var pageSize: Int64 = 0

  //// 筛选条件，如 "published", "draft" 等
  public var filter: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 获取用户关注角色的活跃故事板响应
//// 返回角色参与的活跃故事板列表
public struct Rankquantity_Voyager_Api_GetUserWatchRoleActiveStoryBoardsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  //// 故事板列表
  public var storyboards: [Rankquantity_Voyager_Api_StoryBoardActive] = []

  //// 总数量
  public var total: Int64 = 0

  //// 当前偏移量
  public var offset: Int64 = 0

  //// 每页数量
  public var pageSize: Int64 = 0

  //// 是否有更多数据
  public var haveMore: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 获取用户关注故事的活跃故事板请求
//// 获取用户关注的故事中的活跃故事板列表
public struct Rankquantity_Voyager_Api_GetUserWatchStoryActiveStoryBoardsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  //// 故事ID，必须大于0
  public var storyID: Int64 = 0

  //// 偏移量，用于分页，必须大于等于0
  public var offset: Int64 = 0

  //// 每页数量，范围1-100
  public var pageSize: Int64 = 0

  //// 筛选条件，如 "published", "draft" 等
  public var filter: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 获取用户关注故事的活跃故事板响应
//// 返回故事中的活跃故事板列表
public struct Rankquantity_Voyager_Api_GetUserWatchStoryActiveStoryBoardsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  //// 故事板列表
  public var storyboards: [Rankquantity_Voyager_Api_StoryBoardActive] = []

  //// 总数量
  public var total: Int64 = 0

  //// 当前偏移量
  public var offset: Int64 = 0

  //// 每页数量
  public var pageSize: Int64 = 0

  //// 是否有更多数据
  public var haveMore: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 保存故事板草稿请求
//// 将当前故事板保存为草稿状态，便于后续继续编辑
public struct Rankquantity_Voyager_Api_SaveStoryboardCraftRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 故事板ID，必须大于0
  public var storyboardID: Int64 = 0

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 保存故事板草稿响应
//// 返回保存操作的结果
public struct Rankquantity_Voyager_Api_SaveStoryboardCraftResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 发布故事板请求
//// 将故事板发布为正式版本，其他用户可见
public struct Rankquantity_Voyager_Api_PublishStoryboardRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 故事板ID，必须大于0
  public var storyboardID: Int64 = 0

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 发布故事板响应
//// 返回发布操作的结果
public struct Rankquantity_Voyager_Api_PublishStoryboardResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 撤销故事板请求
//// 撤销已发布的故事板，保留AI生成内容但隐藏场景和图片
public struct Rankquantity_Voyager_Api_CancelStoryboardRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 故事板ID，必须大于0
  public var storyboardID: Int64 = 0

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 撤销故事板响应
//// 返回撤销操作的结果
public struct Rankquantity_Voyager_Api_CancelStoryboardResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 持续渲染故事角色请求
//// 持续优化和渲染角色形象，直到达到满意效果
public struct Rankquantity_Voyager_Api_RenderStoryRoleContinuouslyRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 角色ID，必须大于0
  public var roleID: Int64 = 0

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  //// 故事ID，必须大于0
  public var storyID: Int64 = 0

  //// 渲染提示词，最大长度2000字符
  public var prompt: String = String()

  //// 参考图片URL
  public var referenceImage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 持续渲染故事角色响应
//// 返回渲染结果和是否需要继续渲染的标志
public struct Rankquantity_Voyager_Api_RenderStoryRoleContinuouslyResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  //// 渲染详情
  public var detail: Rankquantity_Voyager_Api_RenderStoryRoleDetail {
    get {return _detail ?? Rankquantity_Voyager_Api_RenderStoryRoleDetail()}
    set {_detail = newValue}
  }
  /// Returns true if `detail` has been explicitly set.
  public var hasDetail: Bool {return self._detail != nil}
  /// Clears the value of `detail`. Subsequent reads from it will return its default value.
  public mutating func clearDetail() {self._detail = nil}

  //// 是否还有更多渲染步骤
  public var haveMore: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _detail: Rankquantity_Voyager_Api_RenderStoryRoleDetail? = nil
}

//// 获取下一个故事板请求
//// 获取当前故事板的后续故事板，支持多分支场景
public struct Rankquantity_Voyager_Api_GetNextStoryboardRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 当前故事板ID，必须大于0
  public var storyboardID: Int64 = 0

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  //// 故事ID，必须大于0
  public var storyID: Int64 = 0

  //// 是否多分支模式
  public var isMultiBranch: Bool = false

  //// 偏移量，用于分页，必须大于等于0
  public var offset: Int64 = 0

  //// 每页数量，范围1-100
  public var pageSize: Int64 = 0

  //// 总数量
  public var total: Int64 = 0

  //// 多分支排序方式
  public var orderBy: Rankquantity_Voyager_Api_MultiBranchOrderBy = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 获取下一个故事板响应
//// 返回后续故事板列表，支持多分支场景
public struct Rankquantity_Voyager_Api_GetNextStoryboardResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  //// 后续故事板列表
  public var storyboards: [Rankquantity_Voyager_Api_StoryBoardActive] = []

  //// 是否为多分支
  public var isMultiBranch: Bool = false

  //// 总数量
  public var total: Int64 = 0

  //// 当前偏移量
  public var offset: Int64 = 0

  //// 每页数量
  public var pageSize: Int64 = 0

  //// 是否有更多数据
  public var haveMore: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 获取用户聊天消息请求
//// 获取指定聊天会话中的消息记录
public struct Rankquantity_Voyager_Api_GetUserChatMessagesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  //// 聊天会话ID，必须大于0
  public var chatID: Int64 = 0

  //// 角色ID，必须大于0
  public var roleID: Int64 = 0

  //// 时间戳，用于获取指定时间之前的消息
  public var timestamp: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 获取用户聊天消息响应
//// 返回聊天消息列表
public struct Rankquantity_Voyager_Api_GetUserChatMessagesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  //// 消息列表
  public var messages: [Rankquantity_Voyager_Api_ChatMessage] = []

  //// 当前时间戳
  public var timestamp: Int64 = 0

  //// 消息总数
  public var total: Int64 = 0

  //// 是否有更多历史消息
  public var haveMore: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 获取用户与角色对话请求
//// 获取用户与指定角色的完整聊天会话
public struct Rankquantity_Voyager_Api_GetUserChatWithRoleRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 角色ID，必须大于0
  public var roleID: Int64 = 0

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 获取用户与角色对话响应
//// 返回完整的聊天记录和上下文信息
public struct Rankquantity_Voyager_Api_GetUserChatWithRoleResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  //// 聊天消息列表
  public var messages: [Rankquantity_Voyager_Api_ChatMessage] = []

  //// 聊天上下文信息
  public var chatContext: Rankquantity_Voyager_Api_ChatContext {
    get {return _chatContext ?? Rankquantity_Voyager_Api_ChatContext()}
    set {_chatContext = newValue}
  }
  /// Returns true if `chatContext` has been explicitly set.
  public var hasChatContext: Bool {return self._chatContext != nil}
  /// Clears the value of `chatContext`. Subsequent reads from it will return its default value.
  public mutating func clearChatContext() {self._chatContext = nil}

  //// 消息总数
  public var total: Int64 = 0

  //// 是否有更多历史消息
  public var haveMore: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chatContext: Rankquantity_Voyager_Api_ChatContext? = nil
}

//// 获取角色参与的故事板请求
//// 获取指定角色参与的所有故事板列表
public struct Rankquantity_Voyager_Api_GetStoryRoleStoryboardsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 角色ID，必须大于0
  public var roleID: Int64 = 0

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  //// 故事ID，必须大于0
  public var storyID: Int64 = 0

  //// 筛选条件，最大长度50字符
  public var filter: String = String()

  //// 偏移量，用于分页，必须大于等于0
  public var offset: Int64 = 0

  //// 每页数量，范围1-100
  public var pageSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 获取角色参与的故事板响应
//// 返回角色参与的故事板列表
public struct Rankquantity_Voyager_Api_GetStoryRoleStoryboardsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  //// 故事板活动列表
  public var storyboardactives: [Rankquantity_Voyager_Api_StoryBoardActive] = []

  //// 总数量
  public var total: Int64 = 0

  //// 当前偏移量
  public var offset: Int64 = 0

  //// 每页数量
  public var pageSize: Int64 = 0

  //// 是否有更多数据
  public var haveMore: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 获取角色参与的故事请求
//// 获取指定角色出现的所有故事列表
public struct Rankquantity_Voyager_Api_GetStoryRoleStoriesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 角色ID，必须大于0
  public var roleID: Int64 = 0

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  //// 筛选条件，最大长度50字符
  public var filter: String = String()

  //// 偏移量，用于分页，必须大于等于0
  public var offset: Int64 = 0

  //// 每页数量，范围1-100
  public var pageSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 获取角色参与的故事响应
//// 返回角色出现的故事列表
public struct Rankquantity_Voyager_Api_GetStoryRoleStoriesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  //// 故事列表
  public var stories: [Rankquantity_Voyager_Api_Story] = []

  //// 总数量
  public var total: Int64 = 0

  //// 当前偏移量
  public var offset: Int64 = 0

  //// 每页数量
  public var pageSize: Int64 = 0

  //// 是否有更多数据
  public var haveMore: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 创建与角色的对话请求
//// 开始一个新的与故事角色的聊天会话
public struct Rankquantity_Voyager_Api_CreateStoryRoleChatRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 角色ID，必须大于0
  public var roleID: Int64 = 0

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 聊天上下文信息
//// 表示一个聊天会话的完整状态
public struct Rankquantity_Voyager_Api_ChatContext: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 聊天会话ID
  public var chatID: Int64 {
    get {return _storage._chatID}
    set {_uniqueStorage()._chatID = newValue}
  }

  //// 角色ID
  public var roleID: Int64 {
    get {return _storage._roleID}
    set {_uniqueStorage()._roleID = newValue}
  }

  //// 用户ID
  public var userID: Int64 {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  //// 会话开始时间戳
  public var timestamp: Int64 {
    get {return _storage._timestamp}
    set {_uniqueStorage()._timestamp = newValue}
  }

  //// 最后更新时间戳
  public var lastUpdateTime: Int64 {
    get {return _storage._lastUpdateTime}
    set {_uniqueStorage()._lastUpdateTime = newValue}
  }

  //// 总消耗token数
  public var totalTokens: Int64 {
    get {return _storage._totalTokens}
    set {_uniqueStorage()._totalTokens = newValue}
  }

  //// 总消息数
  public var totalMessages: Int64 {
    get {return _storage._totalMessages}
    set {_uniqueStorage()._totalMessages = newValue}
  }

  //// 最后一条消息
  public var lastMessage: Rankquantity_Voyager_Api_ChatMessage {
    get {return _storage._lastMessage ?? Rankquantity_Voyager_Api_ChatMessage()}
    set {_uniqueStorage()._lastMessage = newValue}
  }
  /// Returns true if `lastMessage` has been explicitly set.
  public var hasLastMessage: Bool {return _storage._lastMessage != nil}
  /// Clears the value of `lastMessage`. Subsequent reads from it will return its default value.
  public mutating func clearLastMessage() {_uniqueStorage()._lastMessage = nil}

  //// 用户信息
  public var user: Rankquantity_Voyager_Api_UserInfo {
    get {return _storage._user ?? Rankquantity_Voyager_Api_UserInfo()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  public var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  public mutating func clearUser() {_uniqueStorage()._user = nil}

  //// 角色信息
  public var role: Rankquantity_Voyager_Api_StoryRole {
    get {return _storage._role ?? Rankquantity_Voyager_Api_StoryRole()}
    set {_uniqueStorage()._role = newValue}
  }
  /// Returns true if `role` has been explicitly set.
  public var hasRole: Bool {return _storage._role != nil}
  /// Clears the value of `role`. Subsequent reads from it will return its default value.
  public mutating func clearRole() {_uniqueStorage()._role = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

//// 创建与角色的对话响应
//// 返回创建的聊天会话信息
public struct Rankquantity_Voyager_Api_CreateStoryRoleChatResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  //// 聊天上下文信息
  public var chatContext: Rankquantity_Voyager_Api_ChatContext {
    get {return _chatContext ?? Rankquantity_Voyager_Api_ChatContext()}
    set {_chatContext = newValue}
  }
  /// Returns true if `chatContext` has been explicitly set.
  public var hasChatContext: Bool {return self._chatContext != nil}
  /// Clears the value of `chatContext`. Subsequent reads from it will return its default value.
  public mutating func clearChatContext() {self._chatContext = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chatContext: Rankquantity_Voyager_Api_ChatContext? = nil
}

//// 与故事角色聊天请求
//// 发送消息并获取角色的回复
public struct Rankquantity_Voyager_Api_ChatWithStoryRoleRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 角色ID，必须大于0
  public var roleID: Int64 = 0

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  //// 历史消息列表，最多包含最近50条消息
  public var messages: [Rankquantity_Voyager_Api_ChatMessage] = []

  //// 总消息数
  public var total: Int64 = 0

  //// 是否还有更多历史消息
  public var haveMore: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 与故事角色聊天响应
//// 返回角色的回复消息
public struct Rankquantity_Voyager_Api_ChatWithStoryRoleResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  //// 角色回复的消息列表
  public var replyMessages: [Rankquantity_Voyager_Api_ChatMessage] = []

  //// 总消息数
  public var total: Int64 = 0

  //// 是否还有更多消息
  public var haveMore: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 更新故事角色详情请求
//// 更新角色的完整详细信息
public struct Rankquantity_Voyager_Api_UpdateStoryRoleDetailRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 角色ID，必须大于0
  public var roleID: Int64 = 0

  //// 角色信息，必填
  public var role: Rankquantity_Voyager_Api_StoryRole {
    get {return _role ?? Rankquantity_Voyager_Api_StoryRole()}
    set {_role = newValue}
  }
  /// Returns true if `role` has been explicitly set.
  public var hasRole: Bool {return self._role != nil}
  /// Clears the value of `role`. Subsequent reads from it will return its default value.
  public mutating func clearRole() {self._role = nil}

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  //// 是否需要重新生成
  public var needRegen: Bool = false

  //// 背景图片URL
  public var backgroundImage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _role: Rankquantity_Voyager_Api_StoryRole? = nil
}

//// 更新故事角色详情响应
//// 返回更新操作的结果
public struct Rankquantity_Voyager_Api_UpdateStoryRoleDetailResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 更新故事角色头像请求
//// 更新角色的头像图片
public struct Rankquantity_Voyager_Api_UpdateStoryRoleAvatorRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 角色ID，必须大于0
  public var roleID: Int64 = 0

  //// 头像URL，必填
  public var avator: String = String()

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 更新故事角色头像响应
//// 返回更新操作的结果
public struct Rankquantity_Voyager_Api_UpdateStoryRoleAvatorResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 获取用户与角色对话列表请求
//// 获取用户与各个角色的所有聊天会话列表
public struct Rankquantity_Voyager_Api_GetUserWithRoleChatListRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  //// 故事ID（可选），用于筛选特定故事的角色对话
  public var storyID: Int64 = 0

  //// 偏移量，用于分页，必须大于等于0
  public var offset: Int64 = 0

  //// 每页数量，范围1-100
  public var pageSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 获取用户与角色对话列表响应
//// 返回聊天会话列表
public struct Rankquantity_Voyager_Api_GetUserWithRoleChatListResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  //// 聊天上下文列表
  public var chats: [Rankquantity_Voyager_Api_ChatContext] = []

  //// 对话总数
  public var total: Int64 = 0

  //// 当前偏移量
  public var offset: Int64 = 0

  //// 每页数量
  public var pageSize: Int64 = 0

  //// 是否有更多数据
  public var haveMore: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 获取用户创建的故事板请求
//// 获取指定用户创建的所有故事板列表
public struct Rankquantity_Voyager_Api_GetUserCreatedStoryboardsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  //// 故事ID（可选），用于筛选特定故事的故事板
  public var storyID: Int32 = 0

  //// 阶段状态筛选，0表示不筛选
  public var stage: Int32 = 0

  //// 偏移量，用于分页，必须大于等于0
  public var offset: Int64 = 0

  //// 每页数量，范围1-100
  public var pageSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 获取用户创建的故事板响应
//// 返回用户创建的故事板列表
public struct Rankquantity_Voyager_Api_GetUserCreatedStoryboardsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  //// 故事板列表
  public var storyboards: [Rankquantity_Voyager_Api_StoryBoardActive] = []

  //// 总数量
  public var total: Int64 = 0

  //// 是否有更多数据
  public var haveMore: Bool = false

  //// 当前偏移量
  public var offset: Int64 = 0

  //// 每页数量
  public var pageSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 获取用户创建的角色请求
//// 获取指定用户创建的所有故事角色列表
public struct Rankquantity_Voyager_Api_GetUserCreatedRolesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  //// 故事ID（可选），用于筛选特定故事的角色
  public var storyID: Int32 = 0

  //// 阶段状态筛选，0表示不筛选
  public var stage: Int32 = 0

  //// 偏移量，用于分页，必须大于等于0
  public var offset: Int64 = 0

  //// 每页数量，范围1-100
  public var pageSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 获取用户创建的角色响应
//// 返回用户创建的角色列表
public struct Rankquantity_Voyager_Api_GetUserCreatedRolesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  //// 角色列表
  public var roles: [Rankquantity_Voyager_Api_StoryRole] = []

  //// 总数量
  public var total: Int64 = 0

  //// 是否有更多数据
  public var haveMore: Bool = false

  //// 当前偏移量
  public var offset: Int64 = 0

  //// 每页数量
  public var pageSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 点赞故事角色请求
//// 为故事角色点赞
public struct Rankquantity_Voyager_Api_LikeStoryRoleRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 角色ID，必须大于0
  public var roleID: Int64 = 0

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  //// 故事ID，必须大于0
  public var storyID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 点赞故事角色响应
//// 返回点赞操作的结果
public struct Rankquantity_Voyager_Api_LikeStoryRoleResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 取消点赞故事角色请求
//// 取消对故事角色的点赞
public struct Rankquantity_Voyager_Api_UnLikeStoryRoleRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 角色ID，必须大于0
  public var roleID: Int64 = 0

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  //// 故事ID，必须大于0
  public var storyID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 取消点赞故事角色响应
//// 返回取消点赞操作的结果
public struct Rankquantity_Voyager_Api_UnLikeStoryRoleResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 关注故事角色请求
//// 关注指定的故事角色，接收该角色的动态
public struct Rankquantity_Voyager_Api_FollowStoryRoleRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 角色ID，必须大于0
  public var roleID: Int64 = 0

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  //// 故事ID，必须大于0
  public var storyID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 关注故事角色响应
//// 返回关注操作的结果
public struct Rankquantity_Voyager_Api_FollowStoryRoleResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 取消关注故事角色请求
//// 取消对故事角色的关注
public struct Rankquantity_Voyager_Api_UnFollowStoryRoleRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 角色ID，必须大于0
  public var roleID: Int64 = 0

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  //// 故事ID，必须大于0
  public var storyID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 取消关注故事角色响应
//// 返回取消关注操作的结果
public struct Rankquantity_Voyager_Api_UnFollowStoryRoleResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 搜索故事请求
//// 根据关键词搜索故事，支持不同范围的搜索
public struct Rankquantity_Voyager_Api_SearchStoriesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 请求用户ID，必须大于0
  public var userID: Int64 = 0

  //// 搜索关键词，长度1-200字符
  public var keyword: String = String()

  //// 偏移量，用于分页，必须大于等于0
  public var offset: Int64 = 0

  //// 每页数量，范围1-100
  public var pageSize: Int64 = 0

  //// 搜索范围类型：全局、群组内等
  public var scope: Rankquantity_Voyager_Api_ScopeType = .protectScope

  //// 群组ID（可选），用于在特定群组内搜索
  public var groupID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 搜索故事响应
//// 返回匹配的故事列表
public struct Rankquantity_Voyager_Api_SearchStoriesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  //// 匹配的故事列表
  public var stories: [Rankquantity_Voyager_Api_Story] = []

  //// 总数量
  public var total: Int64 = 0

  //// 是否有更多数据
  public var haveMore: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 搜索角色请求
//// 根据关键词搜索故事角色，支持不同范围的搜索
public struct Rankquantity_Voyager_Api_SearchRolesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 请求用户ID，必须大于0
  public var userID: Int64 = 0

  //// 搜索关键词，角色名称或描述，长度1-200字符
  public var keyword: String = String()

  //// 偏移量，用于分页，必须大于等于0
  public var offset: Int64 = 0

  //// 每页数量，范围1-100
  public var pageSize: Int64 = 0

  //// 搜索范围类型：全局、群组内、故事内等
  public var scope: Rankquantity_Voyager_Api_ScopeType = .protectScope

  //// 故事ID（可选），用于在特定故事内搜索
  public var storyID: Int64 = 0

  //// 群组ID（可选），用于在特定群组内搜索
  public var groupID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 搜索角色响应
//// 返回匹配的角色列表
public struct Rankquantity_Voyager_Api_SearchRolesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  //// 匹配的角色列表
  public var roles: [Rankquantity_Voyager_Api_StoryRole] = []

  //// 总数量
  public var total: Int64 = 0

  //// 是否有更多数据
  public var haveMore: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 恢复故事板请求
//// 从草稿或历史版本恢复故事板状态
public struct Rankquantity_Voyager_Api_RestoreStoryboardRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 故事板ID，必须大于0
  public var storyboardID: Int64 = 0

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  //// 故事ID，必须大于0
  public var storyID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 恢复故事板响应
//// 返回恢复的故事板完整信息
public struct Rankquantity_Voyager_Api_RestoreStoryboardResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  //// 故事板状态存储信息
  public var store: Rankquantity_Voyager_Api_StoryboardStageStore {
    get {return _store ?? Rankquantity_Voyager_Api_StoryboardStageStore()}
    set {_store = newValue}
  }
  /// Returns true if `store` has been explicitly set.
  public var hasStore: Bool {return self._store != nil}
  /// Clears the value of `store`. Subsequent reads from it will return its default value.
  public mutating func clearStore() {self._store = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _store: Rankquantity_Voyager_Api_StoryboardStageStore? = nil
}

//// 故事板阶段存储信息
//// 包含故事板的完整状态和版本信息
public struct Rankquantity_Voyager_Api_StoryboardStageStore: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 故事板信息
  public var storyboard: Rankquantity_Voyager_Api_StoryBoard {
    get {return _storyboard ?? Rankquantity_Voyager_Api_StoryBoard()}
    set {_storyboard = newValue}
  }
  /// Returns true if `storyboard` has been explicitly set.
  public var hasStoryboard: Bool {return self._storyboard != nil}
  /// Clears the value of `storyboard`. Subsequent reads from it will return its default value.
  public mutating func clearStoryboard() {self._storyboard = nil}

  //// 场景列表
  public var sences: Rankquantity_Voyager_Api_StoryBoardSences {
    get {return _sences ?? Rankquantity_Voyager_Api_StoryBoardSences()}
    set {_sences = newValue}
  }
  /// Returns true if `sences` has been explicitly set.
  public var hasSences: Bool {return self._sences != nil}
  /// Clears the value of `sences`. Subsequent reads from it will return its default value.
  public mutating func clearSences() {self._sences = nil}

  //// 当前阶段状态
  public var stage: Rankquantity_Voyager_Api_StoryboardStage = .unspecified

  //// 最后更新时间戳
  public var lastUpdateTime: Int64 = 0

  //// 版本号
  public var version: Int64 = 0

  //// 用户ID
  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storyboard: Rankquantity_Voyager_Api_StoryBoard? = nil
  fileprivate var _sences: Rankquantity_Voyager_Api_StoryBoardSences? = nil
}

//// 获取用户资料请求
//// 获取指定用户的详细资料信息
public struct Rankquantity_Voyager_Api_GetUserProfileRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 获取用户资料响应
//// 返回用户的详细资料
public struct Rankquantity_Voyager_Api_GetUserProfileResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  //// 用户资料信息
  public var info: Rankquantity_Voyager_Api_UserProfileInfo {
    get {return _info ?? Rankquantity_Voyager_Api_UserProfileInfo()}
    set {_info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  public var hasInfo: Bool {return self._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  public mutating func clearInfo() {self._info = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _info: Rankquantity_Voyager_Api_UserProfileInfo? = nil
}

//// 更新用户资料请求
//// 更新用户的个人资料信息
public struct Rankquantity_Voyager_Api_UpdateUserProfileRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  //// 背景图片URL
  public var backgroundImage: String = String()

  //// 头像URL
  public var avatar: String = String()

  //// 用户昵称，最大长度50字符
  public var name: String = String()

  //// 个人描述，最大长度500字符
  public var description_p: String = String()

  //// 所在地，最大长度100字符
  public var location: String = String()

  //// 邮箱地址，如果提供则必须符合邮箱格式
  public var email: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 更新用户资料响应
//// 返回更新操作的结果
public struct Rankquantity_Voyager_Api_UpdateUserProfileResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UpdateUserBackgroundImageRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var backgroundImage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rankquantity_Voyager_Api_UpdateUserBackgroundImageResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 创建故事角色请求
//// 在故事中创建新的角色
public struct Rankquantity_Voyager_Api_CreateStoryRoleRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 创建者用户ID，必须大于0
  public var userID: Int64 = 0

  //// 角色信息，必填
  public var role: Rankquantity_Voyager_Api_StoryRole {
    get {return _role ?? Rankquantity_Voyager_Api_StoryRole()}
    set {_role = newValue}
  }
  /// Returns true if `role` has been explicitly set.
  public var hasRole: Bool {return self._role != nil}
  /// Clears the value of `role`. Subsequent reads from it will return its default value.
  public mutating func clearRole() {self._role = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _role: Rankquantity_Voyager_Api_StoryRole? = nil
}

//// 创建故事角色响应
//// 返回创建操作的结果
public struct Rankquantity_Voyager_Api_CreateStoryRoleResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 获取故事角色详情请求
//// 获取指定角色的详细信息
public struct Rankquantity_Voyager_Api_GetStoryRoleDetailRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 角色ID，必须大于0
  public var roleID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 获取故事角色详情响应
//// 返回角色的详细信息
public struct Rankquantity_Voyager_Api_GetStoryRoleDetailResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  //// 角色详细信息
  public var info: Rankquantity_Voyager_Api_StoryRole {
    get {return _info ?? Rankquantity_Voyager_Api_StoryRole()}
    set {_info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  public var hasInfo: Bool {return self._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  public mutating func clearInfo() {self._info = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _info: Rankquantity_Voyager_Api_StoryRole? = nil
}

//// 渲染故事角色请求
//// 使用AI渲染角色的形象和特征
public struct Rankquantity_Voyager_Api_RenderStoryRoleRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 角色ID，必须大于0
  public var roleID: Int64 = 0

  //// 渲染提示词，最大长度2000字符
  public var prompt: String = String()

  //// 参考图片URL列表，最多10张
  public var refImages: [String] = []

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 渲染故事角色详情
//// 包含角色渲染后的完整特征信息
public struct Rankquantity_Voyager_Api_RenderStoryRoleDetail: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 角色ID
  public var roleID: Int64 = 0

  //// 生成任务ID
  public var genID: Int64 = 0

  //// 是否渲染完成
  public var isFinished: Bool = false

  //// 角色描述
  public var roleDescription: String = String()

  //// 角色性格特征
  public var roleCharacter: String = String()

  //// 角色行为特点
  public var roleBehavior: String = String()

  //// 角色目标
  public var roleGoal: String = String()

  //// 背景图片URL
  public var backgroundImage: String = String()

  //// 头像图片URL
  public var avatarImage: String = String()

  //// 背景故事
  public var background: String = String()

  //// 外观描述
  public var appearance: String = String()

  //// 性格描述
  public var personality: String = String()

  //// 能力特征
  public var abilityFeatures: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 渲染故事角色响应
//// 返回角色渲染的详细结果
public struct Rankquantity_Voyager_Api_RenderStoryRoleResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  //// 渲染详情
  public var detail: Rankquantity_Voyager_Api_RenderStoryRoleDetail {
    get {return _detail ?? Rankquantity_Voyager_Api_RenderStoryRoleDetail()}
    set {_detail = newValue}
  }
  /// Returns true if `detail` has been explicitly set.
  public var hasDetail: Bool {return self._detail != nil}
  /// Clears the value of `detail`. Subsequent reads from it will return its default value.
  public mutating func clearDetail() {self._detail = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _detail: Rankquantity_Voyager_Api_RenderStoryRoleDetail? = nil
}

//// 点赞故事请求
//// 为故事点赞表示喜欢
public struct Rankquantity_Voyager_Api_LikeStoryRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 故事ID，必须大于0
  public var storyID: Int64 = 0

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 点赞故事响应
//// 返回点赞操作的结果
public struct Rankquantity_Voyager_Api_LikeStoryResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 取消点赞故事请求
//// 取消对故事的点赞
public struct Rankquantity_Voyager_Api_UnLikeStoryRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 故事ID，必须大于0
  public var storyID: Int64 = 0

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 取消点赞故事响应
//// 返回取消点赞操作的结果
public struct Rankquantity_Voyager_Api_UnLikeStoryResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息
  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ==================== 删除用户故事板草稿 ====================
//// 删除用户故事板草稿请求
//// 
//// 用于删除指定用户的故事板草稿，支持批量删除操作
public struct Rankquantity_Voyager_Api_DeleteUserStoryboardDraftRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// [必填] 用户ID
  //// 
  //// 草稿所有者的用户ID
  //// 验证规则：必须大于 0
  public var userID: Int64 = 0

  //// [必填] 草稿ID
  //// 
  //// 要删除的草稿唯一标识符
  //// 验证规则：必须大于 0
  public var draftID: Int64 = 0

  //// [可选] 故事ID
  //// 
  //// 所属故事的ID，用于权限验证
  //// 验证规则：如果提供则必须大于等于 0
  //// 默认值：0（不筛选）
  public var storyID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 删除用户故事板草稿响应
//// 返回删除操作的结果状态
public struct Rankquantity_Voyager_Api_DeleteUserStoryboardDraftResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息描述
  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ==================== 用户活跃热力图 ====================
//// 热力图数据项
//// 
//// 表示单个日期的活跃度数据，用于生成GitHub风格的热力图可视化
public struct Rankquantity_Voyager_Api_HeatmapDataItem: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// [必填] 日期
  //// 
  //// 活跃度数据对应的日期
  //// 格式要求：YYYY-MM-DD（如 2024-01-15）
  //// 验证规则：必须符合日期格式正则表达式
  public var date: String = String()

  //// [必填] 活跃次数
  //// 
  //// 该日期的活跃操作次数（如创建、更新、评论等）
  //// 验证规则：必须大于等于 0
  //// 默认值：0
  public var count: Int64 = 0

  //// [必填] 热力等级
  //// 
  //// 用于显示不同颜色深度的等级值
  //// 取值说明：
  //// - 0: 无活跃（灰色）
  //// - 1: 低活跃（浅绿）
  //// - 2: 中活跃（绿色）
  //// - 3: 高活跃（深绿）
  //// - 4: 极高活跃（最深绿）
  //// 验证规则：0-4
  public var level: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 用户活跃热力图请求
//// 
//// 获取指定时间范围内用户的活跃度热力图数据，用于展示用户贡献度
public struct Rankquantity_Voyager_Api_UserActiveHeamapRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// [必填] 用户ID
  //// 
  //// 要查询活跃度的用户唯一标识
  //// 验证规则：必须大于 0
  public var userID: Int64 = 0

  //// [必填] 开始时间
  //// 
  //// 查询时间范围的起始时间戳（Unix时间戳，秒）
  //// 验证规则：必须大于 0
  //// 示例：1640995200（表示 2022-01-01 00:00:00 UTC）
  public var startTime: Int64 = 0

  //// [必填] 结束时间
  //// 
  //// 查询时间范围的结束时间戳（Unix时间戳，秒）
  //// 验证规则：必须大于 0，且应大于 start_time
  //// 建议范围：不超过1年
  public var endTime: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 用户活跃热力图响应
//// 返回用户在指定时间范围内的活跃度热力图数据
public struct Rankquantity_Voyager_Api_UserActiveHeamapResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息描述
  public var message: String = String()

  //// 热力图数据列表，包含每日的活跃度信息
  public var data: [Rankquantity_Voyager_Api_HeatmapDataItem] = []

  //// 总活跃次数统计
  public var totalCount: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ==================== 群组活跃热力图 ====================
//// 群组活跃热力图请求
//// 
//// 获取指定群组在指定时间范围内的活跃度热力图数据，展示群组整体活跃情况
public struct Rankquantity_Voyager_Api_GroupActiveHeamapRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// [必填] 群组ID
  //// 
  //// 要查询活跃度的群组唯一标识
  //// 验证规则：必须大于 0
  public var groupID: Int64 = 0

  //// [必填] 请求用户ID
  //// 
  //// 发起请求的用户ID，用于权限验证
  //// 验证规则：必须大于 0
  //// 用途：确认用户有权查看该群组的活跃数据
  public var userID: Int64 = 0

  //// [必填] 开始时间
  //// 
  //// 查询时间范围的起始时间戳（Unix时间戳，秒）
  //// 验证规则：必须大于 0
  public var startTime: Int64 = 0

  //// [必填] 结束时间
  //// 
  //// 查询时间范围的结束时间戳（Unix时间戳，秒）
  //// 验证规则：必须大于 0，且应大于 start_time
  //// 建议范围：不超过1年
  public var endTime: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 群组活跃热力图响应
//// 返回群组在指定时间范围内的活跃度热力图数据及统计信息
public struct Rankquantity_Voyager_Api_GroupActiveHeamapResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息描述
  public var message: String = String()

  //// 热力图数据列表，包含每日的群组活跃度信息
  public var data: [Rankquantity_Voyager_Api_HeatmapDataItem] = []

  //// 总活跃次数统计
  public var totalCount: Int64 = 0

  //// 参与活跃的成员数量
  public var memberCount: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ==================== 更新故事板是否可分叉 ====================
//// 更新故事板分叉权限请求
//// 
//// 设置故事板的分叉权限，控制其他用户是否可以基于此故事板创建分支版本
public struct Rankquantity_Voyager_Api_UpdateStoryboardForkAbleRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// [必填] 用户ID
  //// 
  //// 故事板所有者的用户ID
  //// 验证规则：必须大于 0
  //// 权限要求：仅所有者可修改分叉权限
  public var userID: Int64 = 0

  //// [必填] 故事板ID
  //// 
  //// 要设置权限的故事板唯一标识
  //// 验证规则：必须大于 0
  public var storyboardID: Int64 = 0

  //// [必填] 是否允许分叉
  //// 
  //// 分叉权限开关
  //// 取值说明：
  //// - true: 允许其他用户分叉此故事板
  //// - false: 禁止分叉，仅所有者可访问
  //// 默认值：false
  public var forkAble: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 更新故事板是否可分叉响应
//// 返回更新操作的结果状态
public struct Rankquantity_Voyager_Api_UpdateStoryboardForkAbleResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息描述
  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ==================== 用户故事板草稿列表 ====================
//// 用户故事板草稿列表请求
//// 分页获取指定用户的故事板草稿列表，支持按故事ID筛选
public struct Rankquantity_Voyager_Api_UserStoryboardDraftlistRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  //// 偏移量，用于分页，必须大于等于0
  public var offset: Int64 = 0

  //// 每页数量，范围1-100
  public var pageSize: Int64 = 0

  //// 故事ID（可选，用于筛选特定故事的草稿），如果提供则必须大于0
  public var storyID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 用户故事板草稿列表响应
//// 返回用户的故事板草稿列表及分页信息
public struct Rankquantity_Voyager_Api_UserStoryboardDraftlistResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息描述
  public var message: String = String()

  //// 草稿列表，包含草稿的详细信息
  public var drafts: [Rankquantity_Voyager_Api_StoryboardDraftDetail] = []

  //// 草稿总数
  public var total: Int64 = 0

  //// 是否有更多数据
  public var haveMore: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ==================== 用户故事板草稿详情 ====================
//// 故事板草稿详细信息
//// 包含故事板草稿的完整信息，包括内容、角色、场景等
public struct Rankquantity_Voyager_Api_StoryboardDraftDetail: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 草稿ID，唯一标识符
  public var draftID: Int64 {
    get {return _storage._draftID}
    set {_uniqueStorage()._draftID = newValue}
  }

  //// 所属故事ID
  public var storyID: Int64 {
    get {return _storage._storyID}
    set {_uniqueStorage()._storyID = newValue}
  }

  //// 关联的故事板ID
  public var storyboardID: Int64 {
    get {return _storage._storyboardID}
    set {_uniqueStorage()._storyboardID = newValue}
  }

  //// 草稿标题，最大长度200字符
  public var title: String {
    get {return _storage._title}
    set {_uniqueStorage()._title = newValue}
  }

  //// 草稿内容，最大长度10000字符
  public var content: String {
    get {return _storage._content}
    set {_uniqueStorage()._content = newValue}
  }

  //// 背景描述
  public var background: String {
    get {return _storage._background}
    set {_uniqueStorage()._background = newValue}
  }

  //// 参与的角色列表
  public var roles: [Rankquantity_Voyager_Api_StoryRole] {
    get {return _storage._roles}
    set {_uniqueStorage()._roles = newValue}
  }

  //// 场景列表
  public var sences: Rankquantity_Voyager_Api_StoryBoardSences {
    get {return _storage._sences ?? Rankquantity_Voyager_Api_StoryBoardSences()}
    set {_uniqueStorage()._sences = newValue}
  }
  /// Returns true if `sences` has been explicitly set.
  public var hasSences: Bool {return _storage._sences != nil}
  /// Clears the value of `sences`. Subsequent reads from it will return its default value.
  public mutating func clearSences() {_uniqueStorage()._sences = nil}

  //// 故事板渲染参数
  public var params: Rankquantity_Voyager_Api_StoryBoardParams {
    get {return _storage._params ?? Rankquantity_Voyager_Api_StoryBoardParams()}
    set {_uniqueStorage()._params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  public var hasParams: Bool {return _storage._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  public mutating func clearParams() {_uniqueStorage()._params = nil}

  //// 创建时间戳（秒）
  public var createdAt: Int64 {
    get {return _storage._createdAt}
    set {_uniqueStorage()._createdAt = newValue}
  }

  //// 最后更新时间戳（秒）
  public var updatedAt: Int64 {
    get {return _storage._updatedAt}
    set {_uniqueStorage()._updatedAt = newValue}
  }

  //// 生成阶段状态
  public var stage: Rankquantity_Voyager_Api_StoryboardStage {
    get {return _storage._stage}
    set {_uniqueStorage()._stage = newValue}
  }

  //// 草稿所有者用户ID
  public var userID: Int64 {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

//// 用户故事板草稿详情请求
//// 获取指定草稿的完整详细信息
public struct Rankquantity_Voyager_Api_UserDraftStoryboardDetailRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  //// 草稿ID，必须大于0
  public var draftID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 用户故事板草稿详情响应
//// 返回草稿的完整详细信息
public struct Rankquantity_Voyager_Api_UserDraftStoryboardDetailResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息描述
  public var message: String = String()

  //// 草稿详细信息
  public var detail: Rankquantity_Voyager_Api_StoryboardDraftDetail {
    get {return _detail ?? Rankquantity_Voyager_Api_StoryboardDraftDetail()}
    set {_detail = newValue}
  }
  /// Returns true if `detail` has been explicitly set.
  public var hasDetail: Bool {return self._detail != nil}
  /// Clears the value of `detail`. Subsequent reads from it will return its default value.
  public mutating func clearDetail() {self._detail = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _detail: Rankquantity_Voyager_Api_StoryboardDraftDetail? = nil
}

//// Token消耗记录
//// 记录AI功能使用的Token消耗情况
public struct Rankquantity_Voyager_Api_TokenConsumption: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Token消耗数量
  public var tokenCount: Int64 = 0

  //// Token来源类型
  public var sourceType: Rankquantity_Voyager_Api_TokenSourceType = .tokenSourceUnspecified

  //// 来源ID（个人用户ID或机构ID）
  public var sourceID: Int64 = 0

  //// 消耗时间戳
  public var consumedAt: Int64 = 0

  //// 消耗用途描述
  public var purpose: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// AI润色内容记录
//// 记录使用AI润色的原始内容和润色后的内容
public struct Rankquantity_Voyager_Api_AIPolishRecord: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 原始内容
  public var originalContent: String = String()

  //// 润色后的内容
  public var polishedContent: String = String()

  //// 润色时间戳
  public var polishedAt: Int64 = 0

  //// 润色类型（如：标题润色、描述润色、内容润色）
  public var polishType: String = String()

  //// Token消耗
  public var tokenConsumption: Rankquantity_Voyager_Api_TokenConsumption {
    get {return _tokenConsumption ?? Rankquantity_Voyager_Api_TokenConsumption()}
    set {_tokenConsumption = newValue}
  }
  /// Returns true if `tokenConsumption` has been explicitly set.
  public var hasTokenConsumption: Bool {return self._tokenConsumption != nil}
  /// Clears the value of `tokenConsumption`. Subsequent reads from it will return its default value.
  public mutating func clearTokenConsumption() {self._tokenConsumption = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _tokenConsumption: Rankquantity_Voyager_Api_TokenConsumption? = nil
}

//// 章节AI转译记录
//// 记录章节使用AI转译的场景和图片描述
public struct Rankquantity_Voyager_Api_ChapterTranslationRecord: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 章节ID
  public var chapterID: String = String()

  //// 章节标题
  public var chapterTitle: String = String()

  //// 原始场景描述
  public var originalScene: String = String()

  //// 转译后的场景描述
  public var translatedScene: String = String()

  //// 原始图片描述
  public var originalImageDesc: String = String()

  //// 转译后的图片描述
  public var translatedImageDesc: String = String()

  //// 转译时间戳
  public var translatedAt: Int64 = 0

  //// Token消耗
  public var tokenConsumption: Rankquantity_Voyager_Api_TokenConsumption {
    get {return _tokenConsumption ?? Rankquantity_Voyager_Api_TokenConsumption()}
    set {_tokenConsumption = newValue}
  }
  /// Returns true if `tokenConsumption` has been explicitly set.
  public var hasTokenConsumption: Bool {return self._tokenConsumption != nil}
  /// Clears the value of `tokenConsumption`. Subsequent reads from it will return its default value.
  public mutating func clearTokenConsumption() {self._tokenConsumption = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _tokenConsumption: Rankquantity_Voyager_Api_TokenConsumption? = nil
}

//// 生成提示词记录
//// 记录故事图片和视频生成使用的提示词
public struct Rankquantity_Voyager_Api_GenerationPromptRecord: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 内容类型（image/video）
  public var contentType: String = String()

  //// 内容ID（场景ID或其他相关ID）
  public var contentID: Int64 = 0

  //// 图片提示词
  public var imagePrompt: String = String()

  //// 视频提示词
  public var videoPrompt: String = String()

  //// 生成的图片URL列表
  public var generatedImages: [String] = []

  //// 生成的视频URL
  public var generatedVideo: String = String()

  //// 生成时间戳
  public var generatedAt: Int64 = 0

  //// Token消耗
  public var tokenConsumption: Rankquantity_Voyager_Api_TokenConsumption {
    get {return _tokenConsumption ?? Rankquantity_Voyager_Api_TokenConsumption()}
    set {_tokenConsumption = newValue}
  }
  /// Returns true if `tokenConsumption` has been explicitly set.
  public var hasTokenConsumption: Bool {return self._tokenConsumption != nil}
  /// Clears the value of `tokenConsumption`. Subsequent reads from it will return its default value.
  public mutating func clearTokenConsumption() {self._tokenConsumption = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _tokenConsumption: Rankquantity_Voyager_Api_TokenConsumption? = nil
}

//// 故事生成历史详情
//// 包含故事生成过程中的所有历史记录
public struct Rankquantity_Voyager_Api_StoryGenerationHistory: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 故事基本信息
  public var storyInfo: Rankquantity_Voyager_Api_Story {
    get {return _storage._storyInfo ?? Rankquantity_Voyager_Api_Story()}
    set {_uniqueStorage()._storyInfo = newValue}
  }
  /// Returns true if `storyInfo` has been explicitly set.
  public var hasStoryInfo: Bool {return _storage._storyInfo != nil}
  /// Clears the value of `storyInfo`. Subsequent reads from it will return its default value.
  public mutating func clearStoryInfo() {_uniqueStorage()._storyInfo = nil}

  //// 参与的角色信息列表
  public var roles: [Rankquantity_Voyager_Api_StoryRole] {
    get {return _storage._roles}
    set {_uniqueStorage()._roles = newValue}
  }

  //// AI润色记录列表（标题、描述等润色记录）
  public var polishRecords: [Rankquantity_Voyager_Api_AIPolishRecord] {
    get {return _storage._polishRecords}
    set {_uniqueStorage()._polishRecords = newValue}
  }

  //// 故事章节信息
  public var chapterInfo: Rankquantity_Voyager_Api_StoryInfo {
    get {return _storage._chapterInfo ?? Rankquantity_Voyager_Api_StoryInfo()}
    set {_uniqueStorage()._chapterInfo = newValue}
  }
  /// Returns true if `chapterInfo` has been explicitly set.
  public var hasChapterInfo: Bool {return _storage._chapterInfo != nil}
  /// Clears the value of `chapterInfo`. Subsequent reads from it will return its default value.
  public mutating func clearChapterInfo() {_uniqueStorage()._chapterInfo = nil}

  //// 章节AI转译记录列表
  public var translationRecords: [Rankquantity_Voyager_Api_ChapterTranslationRecord] {
    get {return _storage._translationRecords}
    set {_uniqueStorage()._translationRecords = newValue}
  }

  //// 生成提示词记录列表（图片、视频提示词）
  public var promptRecords: [Rankquantity_Voyager_Api_GenerationPromptRecord] {
    get {return _storage._promptRecords}
    set {_uniqueStorage()._promptRecords = newValue}
  }

  //// 最终内容（包含所有场景的完整内容）
  public var finalContent: [Rankquantity_Voyager_Api_StoryBoard] {
    get {return _storage._finalContent}
    set {_uniqueStorage()._finalContent = newValue}
  }

  //// 创建者信息
  public var creator: Rankquantity_Voyager_Api_UserInfo {
    get {return _storage._creator ?? Rankquantity_Voyager_Api_UserInfo()}
    set {_uniqueStorage()._creator = newValue}
  }
  /// Returns true if `creator` has been explicitly set.
  public var hasCreator: Bool {return _storage._creator != nil}
  /// Clears the value of `creator`. Subsequent reads from it will return its default value.
  public mutating func clearCreator() {_uniqueStorage()._creator = nil}

  //// Token总消耗记录
  public var totalTokenConsumptions: [Rankquantity_Voyager_Api_TokenConsumption] {
    get {return _storage._totalTokenConsumptions}
    set {_uniqueStorage()._totalTokenConsumptions = newValue}
  }

  //// 子故事板数量
  public var childStoryboardCount: Int64 {
    get {return _storage._childStoryboardCount}
    set {_uniqueStorage()._childStoryboardCount = newValue}
  }

  //// 创建时间戳
  public var createdAt: Int64 {
    get {return _storage._createdAt}
    set {_uniqueStorage()._createdAt = newValue}
  }

  //// 最后更新时间戳
  public var updatedAt: Int64 {
    get {return _storage._updatedAt}
    set {_uniqueStorage()._updatedAt = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

//// 获取故事生成历史请求
//// 根据故事ID、用户ID和故事板ID获取完整的生成历史记录
public struct Rankquantity_Voyager_Api_GetStoryGenerationHistoryRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 故事ID，必须大于0
  public var storyID: Int64 = 0

  //// 用户ID，必须大于0
  public var userID: Int64 = 0

  //// 故事板ID，必须大于0
  public var storyboardID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// 获取故事生成历史响应
//// 返回故事的完整生成历史记录
public struct Rankquantity_Voyager_Api_GetStoryGenerationHistoryResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// 响应状态码
  public var code: Rankquantity_Voyager_Api_ResponseCode = .ok

  //// 响应消息描述
  public var message: String = String()

  //// 故事生成历史数据
  public var data: Rankquantity_Voyager_Api_StoryGenerationHistory {
    get {return _data ?? Rankquantity_Voyager_Api_StoryGenerationHistory()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _data: Rankquantity_Voyager_Api_StoryGenerationHistory? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rankquantity.voyager.api"

extension Rankquantity_Voyager_Api_TokenSource: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0TOKEN_SOURCE_USER_SELF\0\u{1}TOKEN_SOURCE_STORY_STORE\0\u{1}TOKEN_SOURCE_THIRD_PARTY\0")
}

extension Rankquantity_Voyager_Api_TokenSourceType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0TOKEN_SOURCE_UNSPECIFIED\0\u{1}TOKEN_SOURCE_PERSONAL\0\u{1}TOKEN_SOURCE_ORGANIZATION\0")
}

extension Rankquantity_Voyager_Api_ActiveInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActiveInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}active_id\0\u{1}user\0\u{3}active_type\0\u{3}group_info\0\u{3}story_info\0\u{3}role_info\0\u{3}board_info\0\u{1}content\0\u{1}Ctime\0\u{1}Mtime\0")

  fileprivate class _StorageClass {
    var _activeID: Int64 = 0
    var _user: Rankquantity_Voyager_Api_UserInfo? = nil
    var _activeType: Rankquantity_Voyager_Api_ActiveType = .noneActive
    var _groupInfo: Rankquantity_Voyager_Api_GroupInfo? = nil
    var _storyInfo: Rankquantity_Voyager_Api_Story? = nil
    var _roleInfo: Rankquantity_Voyager_Api_StoryRole? = nil
    var _boardInfo: Rankquantity_Voyager_Api_StoryBoard? = nil
    var _content: String = String()
    var _ctime: Int64 = 0
    var _mtime: Int64 = 0

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _activeID = source._activeID
      _user = source._user
      _activeType = source._activeType
      _groupInfo = source._groupInfo
      _storyInfo = source._storyInfo
      _roleInfo = source._roleInfo
      _boardInfo = source._boardInfo
      _content = source._content
      _ctime = source._ctime
      _mtime = source._mtime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._activeID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._activeType) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._groupInfo) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._storyInfo) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._roleInfo) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._boardInfo) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._content) }()
        case 9: try { try decoder.decodeSingularInt64Field(value: &_storage._ctime) }()
        case 10: try { try decoder.decodeSingularInt64Field(value: &_storage._mtime) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._activeID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._activeID, fieldNumber: 1)
      }
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if _storage._activeType != .noneActive {
        try visitor.visitSingularEnumField(value: _storage._activeType, fieldNumber: 3)
      }
      try { if let v = _storage._groupInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._storyInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._roleInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._boardInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if !_storage._content.isEmpty {
        try visitor.visitSingularStringField(value: _storage._content, fieldNumber: 8)
      }
      if _storage._ctime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._ctime, fieldNumber: 9)
      }
      if _storage._mtime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._mtime, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_ActiveInfo, rhs: Rankquantity_Voyager_Api_ActiveInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._activeID != rhs_storage._activeID {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._activeType != rhs_storage._activeType {return false}
        if _storage._groupInfo != rhs_storage._groupInfo {return false}
        if _storage._storyInfo != rhs_storage._storyInfo {return false}
        if _storage._roleInfo != rhs_storage._roleInfo {return false}
        if _storage._boardInfo != rhs_storage._boardInfo {return false}
        if _storage._content != rhs_storage._content {return false}
        if _storage._ctime != rhs_storage._ctime {return false}
        if _storage._mtime != rhs_storage._mtime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_LoginRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoginRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}account\0\u{1}password\0\u{3}login_type\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.account) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.loginType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    if self.loginType != 0 {
      try visitor.visitSingularInt32Field(value: self.loginType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_LoginRequest, rhs: Rankquantity_Voyager_Api_LoginRequest) -> Bool {
    if lhs.account != rhs.account {return false}
    if lhs.password != rhs.password {return false}
    if lhs.loginType != rhs.loginType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_LoginResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoginResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}msg\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_LoginResponse, rhs: Rankquantity_Voyager_Api_LoginResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_LoginResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_LoginResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{1}token\0\u{1}timestamp\0\u{3}expire_at\0\u{1}status\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.expireAt) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 2)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 3)
    }
    if self.expireAt != 0 {
      try visitor.visitSingularInt64Field(value: self.expireAt, fieldNumber: 4)
    }
    if self.status != 0 {
      try visitor.visitSingularInt32Field(value: self.status, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_LoginResponse.DataMessage, rhs: Rankquantity_Voyager_Api_LoginResponse.DataMessage) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.token != rhs.token {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.expireAt != rhs.expireAt {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_LogoutRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LogoutRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}token\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_LogoutRequest, rhs: Rankquantity_Voyager_Api_LogoutRequest) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_LogoutResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LogoutResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}msg\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_LogoutResponse, rhs: Rankquantity_Voyager_Api_LogoutResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_RefreshTokenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RefreshTokenRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_RefreshTokenRequest, rhs: Rankquantity_Voyager_Api_RefreshTokenRequest) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_RefreshTokenResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RefreshTokenResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}token\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_RefreshTokenResponse, rhs: Rankquantity_Voyager_Api_RefreshTokenResponse) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_RegisterRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RegisterRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}account\0\u{1}password\0\u{1}name\0\u{1}email\0\u{1}phone\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.account) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.email) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.phone) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 4)
    }
    if !self.phone.isEmpty {
      try visitor.visitSingularStringField(value: self.phone, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_RegisterRequest, rhs: Rankquantity_Voyager_Api_RegisterRequest) -> Bool {
    if lhs.account != rhs.account {return false}
    if lhs.password != rhs.password {return false}
    if lhs.name != rhs.name {return false}
    if lhs.email != rhs.email {return false}
    if lhs.phone != rhs.phone {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_RegisterResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RegisterResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}msg\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_RegisterResponse, rhs: Rankquantity_Voyager_Api_RegisterResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_ConfirmRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConfirmRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_ConfirmRequest, rhs: Rankquantity_Voyager_Api_ConfirmRequest) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_ConfirmResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConfirmResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}status\0\u{1}timestamp\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.status) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != 0 {
      try visitor.visitSingularInt32Field(value: self.status, fieldNumber: 1)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_ConfirmResponse, rhs: Rankquantity_Voyager_Api_ConfirmResponse) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_ResetPasswordRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResetPasswordRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}account\0\u{1}oldPwd\0\u{1}newPwd\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.account) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.oldPwd) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.newPwd) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 1)
    }
    if !self.oldPwd.isEmpty {
      try visitor.visitSingularStringField(value: self.oldPwd, fieldNumber: 2)
    }
    if !self.newPwd.isEmpty {
      try visitor.visitSingularStringField(value: self.newPwd, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_ResetPasswordRequest, rhs: Rankquantity_Voyager_Api_ResetPasswordRequest) -> Bool {
    if lhs.account != rhs.account {return false}
    if lhs.oldPwd != rhs.oldPwd {return false}
    if lhs.newPwd != rhs.newPwd {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_ResetPasswordResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResetPasswordResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}account\0\u{1}status\0\u{1}timestamp\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.account) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.status) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 1)
    }
    if self.status != 0 {
      try visitor.visitSingularInt64Field(value: self.status, fieldNumber: 2)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_ResetPasswordResponse, rhs: Rankquantity_Voyager_Api_ResetPasswordResponse) -> Bool {
    if lhs.account != rhs.account {return false}
    if lhs.status != rhs.status {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UserInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserInfoRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{1}account\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.account) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UserInfoRequest, rhs: Rankquantity_Voyager_Api_UserInfoRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.account != rhs.account {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UserInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserInfoResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}msg\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UserInfoResponse, rhs: Rankquantity_Voyager_Api_UserInfoResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UserInfoResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_UserInfoResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}info\0\u{1}profile\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._profile) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._profile {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UserInfoResponse.DataMessage, rhs: Rankquantity_Voyager_Api_UserInfoResponse.DataMessage) -> Bool {
    if lhs._info != rhs._info {return false}
    if lhs._profile != rhs._profile {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateUserAvatorRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateUserAvatorRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{1}avatar\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.avatar) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if !self.avatar.isEmpty {
      try visitor.visitSingularStringField(value: self.avatar, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateUserAvatorRequest, rhs: Rankquantity_Voyager_Api_UpdateUserAvatorRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.avatar != rhs.avatar {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateUserAvatorResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateUserAvatorResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}msg\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateUserAvatorResponse, rhs: Rankquantity_Voyager_Api_UpdateUserAvatorResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateUserAvatorResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_UpdateUserAvatorResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}info\0\u{1}status\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.status != 0 {
      try visitor.visitSingularInt32Field(value: self.status, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateUserAvatorResponse.DataMessage, rhs: Rankquantity_Voyager_Api_UpdateUserAvatorResponse.DataMessage) -> Bool {
    if lhs._info != rhs._info {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UserWatchingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserWatchingRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{3}time_stamp\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.timeStamp) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.offset) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.timeStamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timeStamp, fieldNumber: 2)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt32Field(value: self.offset, fieldNumber: 3)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UserWatchingRequest, rhs: Rankquantity_Voyager_Api_UserWatchingRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.timeStamp != rhs.timeStamp {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UserWatchingResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserWatchingResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}msg\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UserWatchingResponse, rhs: Rankquantity_Voyager_Api_UserWatchingResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UserWatchingResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_UserWatchingResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}have_more\0\u{1}total\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 1)
    }
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UserWatchingResponse.DataMessage, rhs: Rankquantity_Voyager_Api_UserWatchingResponse.DataMessage) -> Bool {
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.total != rhs.total {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UserGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserGroupRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{1}gtype\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.gtype) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.offset) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.gtype != .protect {
      try visitor.visitSingularEnumField(value: self.gtype, fieldNumber: 2)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt32Field(value: self.offset, fieldNumber: 3)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UserGroupRequest, rhs: Rankquantity_Voyager_Api_UserGroupRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.gtype != rhs.gtype {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UserGroupResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserGroupResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}msg\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UserGroupResponse, rhs: Rankquantity_Voyager_Api_UserGroupResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UserGroupResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_UserGroupResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}list\0\u{1}offset\0\u{3}page_size\0\u{1}total\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.offset) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 1)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt32Field(value: self.offset, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 4)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UserGroupResponse.DataMessage, rhs: Rankquantity_Voyager_Api_UserGroupResponse.DataMessage) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.total != rhs.total {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UserFollowingGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserFollowingGroupRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.offset) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt32Field(value: self.offset, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UserFollowingGroupRequest, rhs: Rankquantity_Voyager_Api_UserFollowingGroupRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UserFollowingGroupResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserFollowingGroupResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}msg\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UserFollowingGroupResponse, rhs: Rankquantity_Voyager_Api_UserFollowingGroupResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UserFollowingGroupResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_UserFollowingGroupResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{1}list\0\u{1}offset\0\u{3}page_size\0\u{1}total\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 2)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 3)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 4)
    }
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 5)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UserFollowingGroupResponse.DataMessage, rhs: Rankquantity_Voyager_Api_UserFollowingGroupResponse.DataMessage) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.list != rhs.list {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.total != rhs.total {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UserUpdateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserUpdateRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{1}nickname\0\u{1}avatar\0\u{1}desc\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nickname) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.avatar) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.desc) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if !self.nickname.isEmpty {
      try visitor.visitSingularStringField(value: self.nickname, fieldNumber: 2)
    }
    if !self.avatar.isEmpty {
      try visitor.visitSingularStringField(value: self.avatar, fieldNumber: 3)
    }
    if !self.desc.isEmpty {
      try visitor.visitSingularStringField(value: self.desc, fieldNumber: 4)
    }
    if !self.data.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.data, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UserUpdateRequest, rhs: Rankquantity_Voyager_Api_UserUpdateRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.nickname != rhs.nickname {return false}
    if lhs.avatar != rhs.avatar {return false}
    if lhs.desc != rhs.desc {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UserUpdateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserUpdateResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UserUpdateResponse, rhs: Rankquantity_Voyager_Api_UserUpdateResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UserUpdateResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_UserUpdateResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UserUpdateResponse.DataMessage, rhs: Rankquantity_Voyager_Api_UserUpdateResponse.DataMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_FetchActivesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FetchActivesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{3}group_id\0\u{3}story_id\0\u{3}board_id\0\u{1}atype\0\u{1}timestamp\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.groupID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.boardID) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.atype) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.groupID != 0 {
      try visitor.visitSingularInt64Field(value: self.groupID, fieldNumber: 2)
    }
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 3)
    }
    if self.boardID != 0 {
      try visitor.visitSingularInt64Field(value: self.boardID, fieldNumber: 4)
    }
    if self.atype != .allFlowType {
      try visitor.visitSingularEnumField(value: self.atype, fieldNumber: 5)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 6)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 7)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_FetchActivesRequest, rhs: Rankquantity_Voyager_Api_FetchActivesRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs.storyID != rhs.storyID {return false}
    if lhs.boardID != rhs.boardID {return false}
    if lhs.atype != rhs.atype {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_FetchActivesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FetchActivesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}msg\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_FetchActivesResponse, rhs: Rankquantity_Voyager_Api_FetchActivesResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_FetchActivesResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_FetchActivesResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}list\0\u{1}timestamp\0\u{1}offset\0\u{3}page_size\0\u{3}have_more\0\u{1}total\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 1)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 2)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 3)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 4)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 5)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_FetchActivesResponse.DataMessage, rhs: Rankquantity_Voyager_Api_FetchActivesResponse.DataMessage) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.total != rhs.total {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_SearchUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchUserRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{3}group_id\0\u{3}is_fuzzy\0\u{2}\u{4}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.groupID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isFuzzy) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.groupID != 0 {
      try visitor.visitSingularInt64Field(value: self.groupID, fieldNumber: 2)
    }
    if self.isFuzzy != false {
      try visitor.visitSingularBoolField(value: self.isFuzzy, fieldNumber: 3)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 7)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_SearchUserRequest, rhs: Rankquantity_Voyager_Api_SearchUserRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs.isFuzzy != rhs.isFuzzy {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_SearchUserResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchUserResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}msg\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_SearchUserResponse, rhs: Rankquantity_Voyager_Api_SearchUserResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_SearchUserResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_SearchUserResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}list\0\u{1}offset\0\u{3}page_size\0\u{1}total\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 1)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 4)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_SearchUserResponse.DataMessage, rhs: Rankquantity_Voyager_Api_SearchUserResponse.DataMessage) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.total != rhs.total {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UserInitRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserInitRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{3}deafault_group\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.deafaultGroup) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if !self.deafaultGroup.isEmpty {
      try visitor.visitSingularStringField(value: self.deafaultGroup, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UserInitRequest, rhs: Rankquantity_Voyager_Api_UserInitRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.deafaultGroup != rhs.deafaultGroup {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UserInitResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserInitResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}msg\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UserInitResponse, rhs: Rankquantity_Voyager_Api_UserInitResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UserInitResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_UserInitResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{1}list\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UserInitResponse.DataMessage, rhs: Rankquantity_Voyager_Api_UserInitResponse.DataMessage) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.list != rhs.list {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetGroupItemsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetGroupItemsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_id\0\u{3}user_id\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.groupID != 0 {
      try visitor.visitSingularInt64Field(value: self.groupID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 3)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetGroupItemsRequest, rhs: Rankquantity_Voyager_Api_GetGroupItemsRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetGroupItemsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetGroupItemsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}msg\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetGroupItemsResponse, rhs: Rankquantity_Voyager_Api_GetGroupItemsResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetGroupItemsResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_GetGroupItemsResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}list\0\u{3}group_id\0\u{3}user_id\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.groupID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 1)
    }
    if self.groupID != 0 {
      try visitor.visitSingularInt64Field(value: self.groupID, fieldNumber: 2)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 3)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 4)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetGroupItemsResponse.DataMessage, rhs: Rankquantity_Voyager_Api_GetGroupItemsResponse.DataMessage) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetUserItemsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserItemsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetUserItemsRequest, rhs: Rankquantity_Voyager_Api_GetUserItemsRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetUserItemsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserItemsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}msg\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetUserItemsResponse, rhs: Rankquantity_Voyager_Api_GetUserItemsResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetUserItemsResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_GetUserItemsResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}list\0\u{3}user_id\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 3)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetUserItemsResponse.DataMessage, rhs: Rankquantity_Voyager_Api_GetUserItemsResponse.DataMessage) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetItemRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetItemRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_id\0\u{3}project_id\0\u{3}item_id\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.projectID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.itemID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.groupID != 0 {
      try visitor.visitSingularInt64Field(value: self.groupID, fieldNumber: 1)
    }
    if self.projectID != 0 {
      try visitor.visitSingularInt64Field(value: self.projectID, fieldNumber: 2)
    }
    if self.itemID != 0 {
      try visitor.visitSingularInt64Field(value: self.itemID, fieldNumber: 3)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetItemRequest, rhs: Rankquantity_Voyager_Api_GetItemRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.projectID != rhs.projectID {return false}
    if lhs.itemID != rhs.itemID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetItemResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetItemResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}msg\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetItemResponse, rhs: Rankquantity_Voyager_Api_GetItemResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetItemResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_GetItemResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}info\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetItemResponse.DataMessage, rhs: Rankquantity_Voyager_Api_GetItemResponse.DataMessage) -> Bool {
    if lhs._info != rhs._info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_CreateItemRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateItemRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_id\0\u{3}project_id\0\u{1}name\0\u{1}atype\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.projectID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.atype) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.groupID != 0 {
      try visitor.visitSingularInt64Field(value: self.groupID, fieldNumber: 1)
    }
    if self.projectID != 0 {
      try visitor.visitSingularInt64Field(value: self.projectID, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if self.atype != .noneActive {
      try visitor.visitSingularEnumField(value: self.atype, fieldNumber: 4)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_CreateItemRequest, rhs: Rankquantity_Voyager_Api_CreateItemRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.projectID != rhs.projectID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.atype != rhs.atype {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_CreateItemResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateItemResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_CreateItemResponse, rhs: Rankquantity_Voyager_Api_CreateItemResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_CreateItemResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_CreateItemResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}info\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_CreateItemResponse.DataMessage, rhs: Rankquantity_Voyager_Api_CreateItemResponse.DataMessage) -> Bool {
    if lhs._info != rhs._info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateItemRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateItemRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_id\0\u{3}project_id\0\u{3}item_id\0\u{1}info\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.projectID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.itemID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.groupID != 0 {
      try visitor.visitSingularInt64Field(value: self.groupID, fieldNumber: 1)
    }
    if self.projectID != 0 {
      try visitor.visitSingularInt64Field(value: self.projectID, fieldNumber: 2)
    }
    if self.itemID != 0 {
      try visitor.visitSingularInt64Field(value: self.itemID, fieldNumber: 3)
    }
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateItemRequest, rhs: Rankquantity_Voyager_Api_UpdateItemRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.projectID != rhs.projectID {return false}
    if lhs.itemID != rhs.itemID {return false}
    if lhs._info != rhs._info {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateItemResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateItemResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateItemResponse, rhs: Rankquantity_Voyager_Api_UpdateItemResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateItemResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_UpdateItemResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}info\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateItemResponse.DataMessage, rhs: Rankquantity_Voyager_Api_UpdateItemResponse.DataMessage) -> Bool {
    if lhs._info != rhs._info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_DeleteItemRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteItemRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_id\0\u{3}project_id\0\u{3}item_id\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.projectID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.itemID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.groupID != 0 {
      try visitor.visitSingularInt64Field(value: self.groupID, fieldNumber: 1)
    }
    if self.projectID != 0 {
      try visitor.visitSingularInt64Field(value: self.projectID, fieldNumber: 2)
    }
    if self.itemID != 0 {
      try visitor.visitSingularInt64Field(value: self.itemID, fieldNumber: 3)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_DeleteItemRequest, rhs: Rankquantity_Voyager_Api_DeleteItemRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.projectID != rhs.projectID {return false}
    if lhs.itemID != rhs.itemID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_DeleteItemResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteItemResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_DeleteItemResponse, rhs: Rankquantity_Voyager_Api_DeleteItemResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_DeleteItemResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_DeleteItemResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_DeleteItemResponse.DataMessage, rhs: Rankquantity_Voyager_Api_DeleteItemResponse.DataMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_LikeItemRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LikeItemRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_id\0\u{3}project_id\0\u{3}item_id\0\u{3}user_id\0\u{1}islike\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.projectID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.itemID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.islike) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.groupID != 0 {
      try visitor.visitSingularInt64Field(value: self.groupID, fieldNumber: 1)
    }
    if self.projectID != 0 {
      try visitor.visitSingularInt64Field(value: self.projectID, fieldNumber: 2)
    }
    if self.itemID != 0 {
      try visitor.visitSingularInt64Field(value: self.itemID, fieldNumber: 3)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 4)
    }
    if self.islike != false {
      try visitor.visitSingularBoolField(value: self.islike, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_LikeItemRequest, rhs: Rankquantity_Voyager_Api_LikeItemRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.projectID != rhs.projectID {return false}
    if lhs.itemID != rhs.itemID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.islike != rhs.islike {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_LikeItemResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LikeItemResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_LikeItemResponse, rhs: Rankquantity_Voyager_Api_LikeItemResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_LikeItemResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_LikeItemResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_LikeItemResponse.DataMessage, rhs: Rankquantity_Voyager_Api_LikeItemResponse.DataMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_CreateGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateGroupRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{1}name\0\u{1}description\0\u{1}avatar\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.avatar) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if !self.avatar.isEmpty {
      try visitor.visitSingularStringField(value: self.avatar, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_CreateGroupRequest, rhs: Rankquantity_Voyager_Api_CreateGroupRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.avatar != rhs.avatar {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_CreateGroupResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateGroupResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_CreateGroupResponse, rhs: Rankquantity_Voyager_Api_CreateGroupResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_CreateGroupResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_CreateGroupResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}info\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_CreateGroupResponse.DataMessage, rhs: Rankquantity_Voyager_Api_CreateGroupResponse.DataMessage) -> Bool {
    if lhs._info != rhs._info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetGroupRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_id\0\u{3}user_id\0\u{1}name\0\u{3}with_profile\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.withProfile) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.groupID != 0 {
      try visitor.visitSingularInt64Field(value: self.groupID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if self.withProfile != false {
      try visitor.visitSingularBoolField(value: self.withProfile, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetGroupRequest, rhs: Rankquantity_Voyager_Api_GetGroupRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.withProfile != rhs.withProfile {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetGroupResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetGroupResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetGroupResponse, rhs: Rankquantity_Voyager_Api_GetGroupResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetGroupResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_GetGroupResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}info\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetGroupResponse.DataMessage, rhs: Rankquantity_Voyager_Api_GetGroupResponse.DataMessage) -> Bool {
    if lhs._info != rhs._info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetGroupActivesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetGroupActivesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_id\0\u{1}atype\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.atype) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.groupID != 0 {
      try visitor.visitSingularInt64Field(value: self.groupID, fieldNumber: 1)
    }
    if self.atype != .noneActive {
      try visitor.visitSingularEnumField(value: self.atype, fieldNumber: 2)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 3)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetGroupActivesRequest, rhs: Rankquantity_Voyager_Api_GetGroupActivesRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.atype != rhs.atype {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetGroupActivesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetGroupActivesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetGroupActivesResponse, rhs: Rankquantity_Voyager_Api_GetGroupActivesResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetGroupActivesResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_GetGroupActivesResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}list\0\u{1}offset\0\u{3}page_size\0\u{3}have_more\0\u{1}total\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 1)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 3)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 4)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetGroupActivesResponse.DataMessage, rhs: Rankquantity_Voyager_Api_GetGroupActivesResponse.DataMessage) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.total != rhs.total {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateGroupInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateGroupInfoRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_id\0\u{1}info\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.groupID != 0 {
      try visitor.visitSingularInt64Field(value: self.groupID, fieldNumber: 1)
    }
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateGroupInfoRequest, rhs: Rankquantity_Voyager_Api_UpdateGroupInfoRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs._info != rhs._info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateGroupInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateGroupInfoResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateGroupInfoResponse, rhs: Rankquantity_Voyager_Api_UpdateGroupInfoResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateGroupInfoResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_UpdateGroupInfoResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}info\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateGroupInfoResponse.DataMessage, rhs: Rankquantity_Voyager_Api_UpdateGroupInfoResponse.DataMessage) -> Bool {
    if lhs._info != rhs._info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_DeleteGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteGroupRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_id\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.groupID != 0 {
      try visitor.visitSingularInt64Field(value: self.groupID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_DeleteGroupRequest, rhs: Rankquantity_Voyager_Api_DeleteGroupRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_DeleteGroupResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteGroupResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_DeleteGroupResponse, rhs: Rankquantity_Voyager_Api_DeleteGroupResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_DeleteGroupResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_DeleteGroupResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_DeleteGroupResponse.DataMessage, rhs: Rankquantity_Voyager_Api_DeleteGroupResponse.DataMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_FetchGroupMembersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FetchGroupMembersRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_id\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.groupID != 0 {
      try visitor.visitSingularInt64Field(value: self.groupID, fieldNumber: 1)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_FetchGroupMembersRequest, rhs: Rankquantity_Voyager_Api_FetchGroupMembersRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_FetchGroupMembersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FetchGroupMembersResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_FetchGroupMembersResponse, rhs: Rankquantity_Voyager_Api_FetchGroupMembersResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_FetchGroupMembersResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_FetchGroupMembersResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}list\0\u{1}offset\0\u{1}total\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 1)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 2)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 3)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_FetchGroupMembersResponse.DataMessage, rhs: Rankquantity_Voyager_Api_FetchGroupMembersResponse.DataMessage) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.total != rhs.total {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_SearchGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchGroupRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{3}user_id\0\u{1}offset\0\u{3}page_size\0\u{1}scope\0\u{3}story_id\0\u{3}group_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.scope) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.groupID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 3)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 4)
    }
    if self.scope != .protectScope {
      try visitor.visitSingularEnumField(value: self.scope, fieldNumber: 5)
    }
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 6)
    }
    if self.groupID != 0 {
      try visitor.visitSingularInt64Field(value: self.groupID, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_SearchGroupRequest, rhs: Rankquantity_Voyager_Api_SearchGroupRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.scope != rhs.scope {return false}
    if lhs.storyID != rhs.storyID {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_SearchGroupResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchGroupResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_SearchGroupResponse, rhs: Rankquantity_Voyager_Api_SearchGroupResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_SearchGroupResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_SearchGroupResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}list\0\u{1}offset\0\u{3}page_size\0\u{3}have_more\0\u{1}total\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 1)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 3)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 4)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_SearchGroupResponse.DataMessage, rhs: Rankquantity_Voyager_Api_SearchGroupResponse.DataMessage) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.total != rhs.total {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_JoinGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".JoinGroupRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_id\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.groupID != 0 {
      try visitor.visitSingularInt64Field(value: self.groupID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_JoinGroupRequest, rhs: Rankquantity_Voyager_Api_JoinGroupRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_JoinGroupResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".JoinGroupResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_JoinGroupResponse, rhs: Rankquantity_Voyager_Api_JoinGroupResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_JoinGroupResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_JoinGroupResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_JoinGroupResponse.DataMessage, rhs: Rankquantity_Voyager_Api_JoinGroupResponse.DataMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_LeaveGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LeaveGroupRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_id\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.groupID != 0 {
      try visitor.visitSingularInt64Field(value: self.groupID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_LeaveGroupRequest, rhs: Rankquantity_Voyager_Api_LeaveGroupRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_LeaveGroupResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LeaveGroupResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_LeaveGroupResponse, rhs: Rankquantity_Voyager_Api_LeaveGroupResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_LeaveGroupResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_LeaveGroupResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_LeaveGroupResponse.DataMessage, rhs: Rankquantity_Voyager_Api_LeaveGroupResponse.DataMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_DisscussParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DisscussParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_DisscussParams, rhs: Rankquantity_Voyager_Api_DisscussParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_CreateDisscussReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateDisscussReq"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_CreateDisscussReq, rhs: Rankquantity_Voyager_Api_CreateDisscussReq) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_CreateDisscusResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateDisscusResp"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_CreateDisscusResp, rhs: Rankquantity_Voyager_Api_CreateDisscusResp) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_CreateDisscusResp.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_CreateDisscusResp.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_CreateDisscusResp.DataMessage, rhs: Rankquantity_Voyager_Api_CreateDisscusResp.DataMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetDisscusReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDisscusReq"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetDisscusReq, rhs: Rankquantity_Voyager_Api_GetDisscusReq) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetDisscusResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDisscusResp"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetDisscusResp, rhs: Rankquantity_Voyager_Api_GetDisscusResp) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetDisscusResp.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_GetDisscusResp.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetDisscusResp.DataMessage, rhs: Rankquantity_Voyager_Api_GetDisscusResp.DataMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_VersionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VersionRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_VersionRequest, rhs: Rankquantity_Voyager_Api_VersionRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_VersionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VersionResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_VersionResponse, rhs: Rankquantity_Voyager_Api_VersionResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_VersionResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_VersionResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}version\0\u{3}build_time\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.buildTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 1)
    }
    if !self.buildTime.isEmpty {
      try visitor.visitSingularStringField(value: self.buildTime, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_VersionResponse.DataMessage, rhs: Rankquantity_Voyager_Api_VersionResponse.DataMessage) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.buildTime != rhs.buildTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_AboutRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AboutRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_AboutRequest, rhs: Rankquantity_Voyager_Api_AboutRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_AboutResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AboutResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}content\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.content) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_AboutResponse, rhs: Rankquantity_Voyager_Api_AboutResponse) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_ExploreRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExploreRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_ExploreRequest, rhs: Rankquantity_Voyager_Api_ExploreRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_ExploreResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExploreResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_ExploreResponse, rhs: Rankquantity_Voyager_Api_ExploreResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_ExploreResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_ExploreResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_ExploreResponse.DataMessage, rhs: Rankquantity_Voyager_Api_ExploreResponse.DataMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetProjectMembersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetProjectMembersRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}projectId\0\u{1}userId\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.projectID != 0 {
      try visitor.visitSingularInt32Field(value: self.projectID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt32Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetProjectMembersRequest, rhs: Rankquantity_Voyager_Api_GetProjectMembersRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetProjectMembersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetProjectMembersResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetProjectMembersResponse, rhs: Rankquantity_Voyager_Api_GetProjectMembersResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetProjectMembersResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_GetProjectMembersResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}list\0\u{1}total\0\u{1}role\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: &self.role) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 1)
    }
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 2)
    }
    if !self.role.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: self.role, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetProjectMembersResponse.DataMessage, rhs: Rankquantity_Voyager_Api_GetProjectMembersResponse.DataMessage) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.total != rhs.total {return false}
    if lhs.role != rhs.role {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetProjectWatcherRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetProjectWatcherRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}projectId\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.projectID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.projectID != 0 {
      try visitor.visitSingularInt32Field(value: self.projectID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetProjectWatcherRequest, rhs: Rankquantity_Voyager_Api_GetProjectWatcherRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetProjectWatcherResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetProjectWatcherResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetProjectWatcherResponse, rhs: Rankquantity_Voyager_Api_GetProjectWatcherResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetProjectWatcherResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_GetProjectWatcherResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}list\0\u{1}total\0\u{1}timestamp\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt64,SwiftProtobuf.ProtobufInt64>.self, value: &self.timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 1)
    }
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 2)
    }
    if !self.timestamp.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt64,SwiftProtobuf.ProtobufInt64>.self, value: self.timestamp, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetProjectWatcherResponse.DataMessage, rhs: Rankquantity_Voyager_Api_GetProjectWatcherResponse.DataMessage) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.total != rhs.total {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UploadImageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UploadImageRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}image_data\0\u{1}filename\0\u{3}content_type\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.imageData) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.filename) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.contentType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.imageData.isEmpty {
      try visitor.visitSingularBytesField(value: self.imageData, fieldNumber: 1)
    }
    if !self.filename.isEmpty {
      try visitor.visitSingularStringField(value: self.filename, fieldNumber: 2)
    }
    if !self.contentType.isEmpty {
      try visitor.visitSingularStringField(value: self.contentType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UploadImageRequest, rhs: Rankquantity_Voyager_Api_UploadImageRequest) -> Bool {
    if lhs.imageData != rhs.imageData {return false}
    if lhs.filename != rhs.filename {return false}
    if lhs.contentType != rhs.contentType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UploadImageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UploadImageResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UploadImageResponse, rhs: Rankquantity_Voyager_Api_UploadImageResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UploadImageResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_UploadImageResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}file_id\0\u{1}url\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fileID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fileID.isEmpty {
      try visitor.visitSingularStringField(value: self.fileID, fieldNumber: 1)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UploadImageResponse.DataMessage, rhs: Rankquantity_Voyager_Api_UploadImageResponse.DataMessage) -> Bool {
    if lhs.fileID != rhs.fileID {return false}
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryContributorsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryContributorsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0\u{3}user_id\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 3)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryContributorsRequest, rhs: Rankquantity_Voyager_Api_GetStoryContributorsRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_StoryContributor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StoryContributor"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{1}username\0\u{1}avatar\0\u{1}viplevel\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.avatar) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.viplevel) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 2)
    }
    if !self.avatar.isEmpty {
      try visitor.visitSingularStringField(value: self.avatar, fieldNumber: 3)
    }
    if self.viplevel != 0 {
      try visitor.visitSingularInt64Field(value: self.viplevel, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_StoryContributor, rhs: Rankquantity_Voyager_Api_StoryContributor) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.username != rhs.username {return false}
    if lhs.avatar != rhs.avatar {return false}
    if lhs.viplevel != rhs.viplevel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryContributorsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryContributorsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryContributorsResponse, rhs: Rankquantity_Voyager_Api_GetStoryContributorsResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryContributorsResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_GetStoryContributorsResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}list\0\u{1}total\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 1)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 2)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryContributorsResponse.DataMessage, rhs: Rankquantity_Voyager_Api_GetStoryContributorsResponse.DataMessage) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.total != rhs.total {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetGroupProfileRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetGroupProfileRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_id\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.groupID != 0 {
      try visitor.visitSingularInt64Field(value: self.groupID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetGroupProfileRequest, rhs: Rankquantity_Voyager_Api_GetGroupProfileRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetGroupProfileResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetGroupProfileResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetGroupProfileResponse, rhs: Rankquantity_Voyager_Api_GetGroupProfileResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetGroupProfileResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_GetGroupProfileResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}info\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetGroupProfileResponse.DataMessage, rhs: Rankquantity_Voyager_Api_GetGroupProfileResponse.DataMessage) -> Bool {
    if lhs._info != rhs._info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateGroupProfileRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateGroupProfileRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_id\0\u{1}info\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.groupID != 0 {
      try visitor.visitSingularInt64Field(value: self.groupID, fieldNumber: 1)
    }
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateGroupProfileRequest, rhs: Rankquantity_Voyager_Api_UpdateGroupProfileRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs._info != rhs._info {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateGroupProfileResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateGroupProfileResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateGroupProfileResponse, rhs: Rankquantity_Voyager_Api_UpdateGroupProfileResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryRolePosterListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryRolePosterListRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0\u{3}role_id\0\u{3}user_id\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 2)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 3)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 4)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryRolePosterListRequest, rhs: Rankquantity_Voyager_Api_GetStoryRolePosterListRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.roleID != rhs.roleID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_RolePosterDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RolePosterDetail"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{3}story_id\0\u{3}role_id\0\u{3}poster_url\0\u{1}prompt\0\u{3}like_count\0\u{3}is_liked_by_user\0\u{1}creator\0\u{3}created_at\0\u{3}updated_at\0")

  fileprivate class _StorageClass {
    var _id: Int64 = 0
    var _storyID: Int64 = 0
    var _roleID: Int64 = 0
    var _posterURL: String = String()
    var _prompt: String = String()
    var _likeCount: Int64 = 0
    var _isLikedByUser: Bool = false
    var _creator: Rankquantity_Voyager_Api_UserInfo? = nil
    var _createdAt: Int64 = 0
    var _updatedAt: Int64 = 0

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _storyID = source._storyID
      _roleID = source._roleID
      _posterURL = source._posterURL
      _prompt = source._prompt
      _likeCount = source._likeCount
      _isLikedByUser = source._isLikedByUser
      _creator = source._creator
      _createdAt = source._createdAt
      _updatedAt = source._updatedAt
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularInt64Field(value: &_storage._storyID) }()
        case 3: try { try decoder.decodeSingularInt64Field(value: &_storage._roleID) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._posterURL) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._prompt) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._likeCount) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._isLikedByUser) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._creator) }()
        case 9: try { try decoder.decodeSingularInt64Field(value: &_storage._createdAt) }()
        case 10: try { try decoder.decodeSingularInt64Field(value: &_storage._updatedAt) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._id != 0 {
        try visitor.visitSingularInt64Field(value: _storage._id, fieldNumber: 1)
      }
      if _storage._storyID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._storyID, fieldNumber: 2)
      }
      if _storage._roleID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._roleID, fieldNumber: 3)
      }
      if !_storage._posterURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._posterURL, fieldNumber: 4)
      }
      if !_storage._prompt.isEmpty {
        try visitor.visitSingularStringField(value: _storage._prompt, fieldNumber: 5)
      }
      if _storage._likeCount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._likeCount, fieldNumber: 6)
      }
      if _storage._isLikedByUser != false {
        try visitor.visitSingularBoolField(value: _storage._isLikedByUser, fieldNumber: 7)
      }
      try { if let v = _storage._creator {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if _storage._createdAt != 0 {
        try visitor.visitSingularInt64Field(value: _storage._createdAt, fieldNumber: 9)
      }
      if _storage._updatedAt != 0 {
        try visitor.visitSingularInt64Field(value: _storage._updatedAt, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_RolePosterDetail, rhs: Rankquantity_Voyager_Api_RolePosterDetail) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._storyID != rhs_storage._storyID {return false}
        if _storage._roleID != rhs_storage._roleID {return false}
        if _storage._posterURL != rhs_storage._posterURL {return false}
        if _storage._prompt != rhs_storage._prompt {return false}
        if _storage._likeCount != rhs_storage._likeCount {return false}
        if _storage._isLikedByUser != rhs_storage._isLikedByUser {return false}
        if _storage._creator != rhs_storage._creator {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._updatedAt != rhs_storage._updatedAt {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryRolePosterListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryRolePosterListResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}posters\0\u{1}total\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.posters) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.posters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.posters, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 4)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryRolePosterListResponse, rhs: Rankquantity_Voyager_Api_GetStoryRolePosterListResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.posters != rhs.posters {return false}
    if lhs.total != rhs.total {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_LikeStoryRolePosterRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LikeStoryRolePosterRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0\u{3}role_id\0\u{3}user_id\0\u{3}poster_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.posterID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 2)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 3)
    }
    if self.posterID != 0 {
      try visitor.visitSingularInt64Field(value: self.posterID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_LikeStoryRolePosterRequest, rhs: Rankquantity_Voyager_Api_LikeStoryRolePosterRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.roleID != rhs.roleID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.posterID != rhs.posterID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_LikeStoryRolePosterResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LikeStoryRolePosterResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{3}current_like_count\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.currentLikeCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if self.currentLikeCount != 0 {
      try visitor.visitSingularInt64Field(value: self.currentLikeCount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_LikeStoryRolePosterResponse, rhs: Rankquantity_Voyager_Api_LikeStoryRolePosterResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.currentLikeCount != rhs.currentLikeCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UnLikeStoryRolePosterRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnLikeStoryRolePosterRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0\u{3}role_id\0\u{3}user_id\0\u{3}poster_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.posterID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 2)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 3)
    }
    if self.posterID != 0 {
      try visitor.visitSingularInt64Field(value: self.posterID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UnLikeStoryRolePosterRequest, rhs: Rankquantity_Voyager_Api_UnLikeStoryRolePosterRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.roleID != rhs.roleID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.posterID != rhs.posterID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UnLikeStoryRolePosterResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnLikeStoryRolePosterResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{3}current_like_count\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.currentLikeCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if self.currentLikeCount != 0 {
      try visitor.visitSingularInt64Field(value: self.currentLikeCount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UnLikeStoryRolePosterResponse, rhs: Rankquantity_Voyager_Api_UnLikeStoryRolePosterResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.currentLikeCount != rhs.currentLikeCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_FetchUserGenTaskStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FetchUserGenTaskStatusRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{3}task_id\0\u{1}timestamp\0\u{3}page_num\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.taskID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.pageNum) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if !self.taskID.isEmpty {
      try visitor.visitSingularStringField(value: self.taskID, fieldNumber: 2)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 3)
    }
    if self.pageNum != 0 {
      try visitor.visitSingularInt64Field(value: self.pageNum, fieldNumber: 4)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_FetchUserGenTaskStatusRequest, rhs: Rankquantity_Voyager_Api_FetchUserGenTaskStatusRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.taskID != rhs.taskID {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.pageNum != rhs.pageNum {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_StoryGentaskDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StoryGentaskDetail"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0\u{3}board_id\0\u{3}storyboard_desc\0\u{3}sence_id\0\u{3}sence_desc\0\u{1}prompt\0\u{3}task_type\0\u{3}task_stage\0\u{3}start_image_url\0\u{3}end_image_url\0\u{3}video_url\0\u{3}reg_image_url\0\u{1}style\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.boardID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.storyboardDesc) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.senceID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.senceDesc) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.prompt) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.taskType) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.taskStage) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.startImageURL) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.endImageURL) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.videoURL) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.regImageURL) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.style) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.boardID != 0 {
      try visitor.visitSingularInt64Field(value: self.boardID, fieldNumber: 2)
    }
    if !self.storyboardDesc.isEmpty {
      try visitor.visitSingularStringField(value: self.storyboardDesc, fieldNumber: 3)
    }
    if self.senceID != 0 {
      try visitor.visitSingularInt64Field(value: self.senceID, fieldNumber: 4)
    }
    if !self.senceDesc.isEmpty {
      try visitor.visitSingularStringField(value: self.senceDesc, fieldNumber: 5)
    }
    if !self.prompt.isEmpty {
      try visitor.visitSingularStringField(value: self.prompt, fieldNumber: 6)
    }
    if self.taskType != 0 {
      try visitor.visitSingularInt64Field(value: self.taskType, fieldNumber: 7)
    }
    if self.taskStage != 0 {
      try visitor.visitSingularInt64Field(value: self.taskStage, fieldNumber: 8)
    }
    if !self.startImageURL.isEmpty {
      try visitor.visitSingularStringField(value: self.startImageURL, fieldNumber: 9)
    }
    if !self.endImageURL.isEmpty {
      try visitor.visitSingularStringField(value: self.endImageURL, fieldNumber: 10)
    }
    if !self.videoURL.isEmpty {
      try visitor.visitSingularStringField(value: self.videoURL, fieldNumber: 11)
    }
    if !self.regImageURL.isEmpty {
      try visitor.visitSingularStringField(value: self.regImageURL, fieldNumber: 12)
    }
    if !self.style.isEmpty {
      try visitor.visitSingularStringField(value: self.style, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_StoryGentaskDetail, rhs: Rankquantity_Voyager_Api_StoryGentaskDetail) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.boardID != rhs.boardID {return false}
    if lhs.storyboardDesc != rhs.storyboardDesc {return false}
    if lhs.senceID != rhs.senceID {return false}
    if lhs.senceDesc != rhs.senceDesc {return false}
    if lhs.prompt != rhs.prompt {return false}
    if lhs.taskType != rhs.taskType {return false}
    if lhs.taskStage != rhs.taskStage {return false}
    if lhs.startImageURL != rhs.startImageURL {return false}
    if lhs.endImageURL != rhs.endImageURL {return false}
    if lhs.videoURL != rhs.videoURL {return false}
    if lhs.regImageURL != rhs.regImageURL {return false}
    if lhs.style != rhs.style {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UserGenTaskStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserGenTaskStatus"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}task_id\0\u{3}user_id\0\u{1}status\0\u{1}detail\0\u{3}create_time\0\u{3}update_time\0")

  fileprivate class _StorageClass {
    var _taskID: String = String()
    var _userID: Int64 = 0
    var _status: String = String()
    var _detail: Rankquantity_Voyager_Api_StoryGentaskDetail? = nil
    var _createTime: Int64 = 0
    var _updateTime: Int64 = 0

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _taskID = source._taskID
      _userID = source._userID
      _status = source._status
      _detail = source._detail
      _createTime = source._createTime
      _updateTime = source._updateTime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._taskID) }()
        case 2: try { try decoder.decodeSingularInt64Field(value: &_storage._userID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._status) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._detail) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._createTime) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._updateTime) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._taskID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._taskID, fieldNumber: 1)
      }
      if _storage._userID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._userID, fieldNumber: 2)
      }
      if !_storage._status.isEmpty {
        try visitor.visitSingularStringField(value: _storage._status, fieldNumber: 3)
      }
      try { if let v = _storage._detail {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._createTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._createTime, fieldNumber: 5)
      }
      if _storage._updateTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._updateTime, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UserGenTaskStatus, rhs: Rankquantity_Voyager_Api_UserGenTaskStatus) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._taskID != rhs_storage._taskID {return false}
        if _storage._userID != rhs_storage._userID {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._detail != rhs_storage._detail {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._updateTime != rhs_storage._updateTime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_FetchUserGenTaskStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FetchUserGenTaskStatusResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}tasks\0\u{1}total\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.tasks) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.tasks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tasks, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 4)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_FetchUserGenTaskStatusResponse, rhs: Rankquantity_Voyager_Api_FetchUserGenTaskStatusResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.tasks != rhs.tasks {return false}
    if lhs.total != rhs.total {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GenerateRoleAvatarRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateRoleAvatarRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}role_id\0\u{3}user_id\0\u{3}ref_avatar_url\0\u{1}description\0\u{1}style\0\u{3}image_ratios\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.refAvatarURL) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.style) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.imageRatios) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if !self.refAvatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.refAvatarURL, fieldNumber: 3)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 4)
    }
    if !self.style.isEmpty {
      try visitor.visitSingularStringField(value: self.style, fieldNumber: 5)
    }
    if self.imageRatios != .ratio11 {
      try visitor.visitSingularEnumField(value: self.imageRatios, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GenerateRoleAvatarRequest, rhs: Rankquantity_Voyager_Api_GenerateRoleAvatarRequest) -> Bool {
    if lhs.roleID != rhs.roleID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.refAvatarURL != rhs.refAvatarURL {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.style != rhs.style {return false}
    if lhs.imageRatios != rhs.imageRatios {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GenerateRoleAvatarResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateRoleAvatarResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{3}avatar_url\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GenerateRoleAvatarResponse, rhs: Rankquantity_Voyager_Api_GenerateRoleAvatarResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GenerateStorySceneVideoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateStorySceneVideoRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0\u{3}board_id\0\u{3}sence_id\0\u{3}user_id\0\u{3}token_source\0\u{1}prompt\0\u{3}negative_prompt\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.boardID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.senceID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.tokenSource) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.prompt) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.negativePrompt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.boardID != 0 {
      try visitor.visitSingularInt64Field(value: self.boardID, fieldNumber: 2)
    }
    if self.senceID != 0 {
      try visitor.visitSingularInt64Field(value: self.senceID, fieldNumber: 3)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 4)
    }
    if self.tokenSource != .userSelf {
      try visitor.visitSingularEnumField(value: self.tokenSource, fieldNumber: 5)
    }
    if !self.prompt.isEmpty {
      try visitor.visitSingularStringField(value: self.prompt, fieldNumber: 6)
    }
    if !self.negativePrompt.isEmpty {
      try visitor.visitSingularStringField(value: self.negativePrompt, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GenerateStorySceneVideoRequest, rhs: Rankquantity_Voyager_Api_GenerateStorySceneVideoRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.boardID != rhs.boardID {return false}
    if lhs.senceID != rhs.senceID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.tokenSource != rhs.tokenSource {return false}
    if lhs.prompt != rhs.prompt {return false}
    if lhs.negativePrompt != rhs.negativePrompt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GenerateStorySceneVideoTaskDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateStorySceneVideoTaskDetail"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}task_id\0\u{3}task_status\0\u{3}video_url\0\u{3}video_thumbnail_url\0\u{1}duration\0\u{1}resolution\0\u{3}video_format\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.taskID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.taskStatus) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.videoURL) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.videoThumbnailURL) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.duration) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.resolution) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.videoFormat) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.taskID.isEmpty {
      try visitor.visitSingularStringField(value: self.taskID, fieldNumber: 1)
    }
    if self.taskStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.taskStatus, fieldNumber: 2)
    }
    if !self.videoURL.isEmpty {
      try visitor.visitSingularStringField(value: self.videoURL, fieldNumber: 3)
    }
    if !self.videoThumbnailURL.isEmpty {
      try visitor.visitSingularStringField(value: self.videoThumbnailURL, fieldNumber: 4)
    }
    if self.duration != 0 {
      try visitor.visitSingularInt64Field(value: self.duration, fieldNumber: 5)
    }
    if !self.resolution.isEmpty {
      try visitor.visitSingularStringField(value: self.resolution, fieldNumber: 6)
    }
    if !self.videoFormat.isEmpty {
      try visitor.visitSingularStringField(value: self.videoFormat, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GenerateStorySceneVideoTaskDetail, rhs: Rankquantity_Voyager_Api_GenerateStorySceneVideoTaskDetail) -> Bool {
    if lhs.taskID != rhs.taskID {return false}
    if lhs.taskStatus != rhs.taskStatus {return false}
    if lhs.videoURL != rhs.videoURL {return false}
    if lhs.videoThumbnailURL != rhs.videoThumbnailURL {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.resolution != rhs.resolution {return false}
    if lhs.videoFormat != rhs.videoFormat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GenerateStorySceneVideoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateStorySceneVideoResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}detail\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._detail) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._detail {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GenerateStorySceneVideoResponse, rhs: Rankquantity_Voyager_Api_GenerateStorySceneVideoResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._detail != rhs._detail {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GenerateStoryRoleVideoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateStoryRoleVideoRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0\u{3}role_id\0\u{3}user_id\0\u{3}poster_id\0\u{3}ref_background_url\0\u{3}ref_avatar_url\0\u{3}text_prompt\0\u{3}image_ratios\0\u{1}style\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.posterID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.refBackgroundURL) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.refAvatarURL) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.textPrompt) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.imageRatios) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.style) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 2)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 3)
    }
    if self.posterID != 0 {
      try visitor.visitSingularInt64Field(value: self.posterID, fieldNumber: 4)
    }
    if !self.refBackgroundURL.isEmpty {
      try visitor.visitSingularStringField(value: self.refBackgroundURL, fieldNumber: 5)
    }
    if !self.refAvatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.refAvatarURL, fieldNumber: 6)
    }
    if !self.textPrompt.isEmpty {
      try visitor.visitSingularStringField(value: self.textPrompt, fieldNumber: 7)
    }
    if self.imageRatios != .ratio11 {
      try visitor.visitSingularEnumField(value: self.imageRatios, fieldNumber: 8)
    }
    if !self.style.isEmpty {
      try visitor.visitSingularStringField(value: self.style, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GenerateStoryRoleVideoRequest, rhs: Rankquantity_Voyager_Api_GenerateStoryRoleVideoRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.roleID != rhs.roleID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.posterID != rhs.posterID {return false}
    if lhs.refBackgroundURL != rhs.refBackgroundURL {return false}
    if lhs.refAvatarURL != rhs.refAvatarURL {return false}
    if lhs.textPrompt != rhs.textPrompt {return false}
    if lhs.imageRatios != rhs.imageRatios {return false}
    if lhs.style != rhs.style {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GenerateStoryRoleVideoTaskDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateStoryRoleVideoTaskDetail"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}task_id\0\u{3}task_status\0\u{3}video_url\0\u{3}video_thumbnail_url\0\u{1}duration\0\u{1}resolution\0\u{3}video_format\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.taskID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.taskStatus) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.videoURL) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.videoThumbnailURL) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.duration) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.resolution) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.videoFormat) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.taskID.isEmpty {
      try visitor.visitSingularStringField(value: self.taskID, fieldNumber: 1)
    }
    if self.taskStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.taskStatus, fieldNumber: 2)
    }
    if !self.videoURL.isEmpty {
      try visitor.visitSingularStringField(value: self.videoURL, fieldNumber: 3)
    }
    if !self.videoThumbnailURL.isEmpty {
      try visitor.visitSingularStringField(value: self.videoThumbnailURL, fieldNumber: 4)
    }
    if self.duration != 0 {
      try visitor.visitSingularInt64Field(value: self.duration, fieldNumber: 5)
    }
    if !self.resolution.isEmpty {
      try visitor.visitSingularStringField(value: self.resolution, fieldNumber: 6)
    }
    if !self.videoFormat.isEmpty {
      try visitor.visitSingularStringField(value: self.videoFormat, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GenerateStoryRoleVideoTaskDetail, rhs: Rankquantity_Voyager_Api_GenerateStoryRoleVideoTaskDetail) -> Bool {
    if lhs.taskID != rhs.taskID {return false}
    if lhs.taskStatus != rhs.taskStatus {return false}
    if lhs.videoURL != rhs.videoURL {return false}
    if lhs.videoThumbnailURL != rhs.videoThumbnailURL {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.resolution != rhs.resolution {return false}
    if lhs.videoFormat != rhs.videoFormat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GenerateStoryRoleVideoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateStoryRoleVideoResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}detail\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._detail) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._detail {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GenerateStoryRoleVideoResponse, rhs: Rankquantity_Voyager_Api_GenerateStoryRoleVideoResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._detail != rhs._detail {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryParticipantsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryParticipantsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryParticipantsRequest, rhs: Rankquantity_Voyager_Api_GetStoryParticipantsRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryParticipantsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryParticipantsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}participants\0\u{1}total\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.participants) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.participants.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.participants, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 4)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryParticipantsResponse, rhs: Rankquantity_Voyager_Api_GetStoryParticipantsResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.participants != rhs.participants {return false}
    if lhs.total != rhs.total {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateStoryAvatarRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateStoryAvatarRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0\u{3}user_id\0\u{3}avatar_url\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateStoryAvatarRequest, rhs: Rankquantity_Voyager_Api_UpdateStoryAvatarRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateStoryAvatarResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateStoryAvatarResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateStoryAvatarResponse, rhs: Rankquantity_Voyager_Api_UpdateStoryAvatarResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateStoryCoverRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateStoryCoverRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0\u{3}user_id\0\u{3}cover_url\0\u{3}use_ai_cover\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.coverURL) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.useAiCover) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if !self.coverURL.isEmpty {
      try visitor.visitSingularStringField(value: self.coverURL, fieldNumber: 3)
    }
    if self.useAiCover != false {
      try visitor.visitSingularBoolField(value: self.useAiCover, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateStoryCoverRequest, rhs: Rankquantity_Voyager_Api_UpdateStoryCoverRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.coverURL != rhs.coverURL {return false}
    if lhs.useAiCover != rhs.useAiCover {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateStoryCoverResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateStoryCoverResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateStoryCoverResponse, rhs: Rankquantity_Voyager_Api_UpdateStoryCoverResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryImageStyleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryImageStyleRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryImageStyleRequest, rhs: Rankquantity_Voyager_Api_GetStoryImageStyleRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_StoryStyleDesc: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StoryStyleDesc"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}style\0\u{1}description\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.style) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.style.isEmpty {
      try visitor.visitSingularStringField(value: self.style, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_StoryStyleDesc, rhs: Rankquantity_Voyager_Api_StoryStyleDesc) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.style != rhs.style {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryImageStyleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryImageStyleResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}style\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.style) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.style.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.style, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryImageStyleResponse, rhs: Rankquantity_Voyager_Api_GetStoryImageStyleResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.style != rhs.style {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateStoryImageStyleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateStoryImageStyleRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0\u{3}style_id\0\u{1}style\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.styleID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.style) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.styleID != 0 {
      try visitor.visitSingularInt64Field(value: self.styleID, fieldNumber: 2)
    }
    if !self.style.isEmpty {
      try visitor.visitSingularStringField(value: self.style, fieldNumber: 3)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateStoryImageStyleRequest, rhs: Rankquantity_Voyager_Api_UpdateStoryImageStyleRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.styleID != rhs.styleID {return false}
    if lhs.style != rhs.style {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateStoryImageStyleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateStoryImageStyleResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateStoryImageStyleResponse, rhs: Rankquantity_Voyager_Api_UpdateStoryImageStyleResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateStorySenceMaxNumberRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateStorySenceMaxNumberRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0\u{3}max_number\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.maxNumber) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.maxNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.maxNumber, fieldNumber: 2)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateStorySenceMaxNumberRequest, rhs: Rankquantity_Voyager_Api_UpdateStorySenceMaxNumberRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.maxNumber != rhs.maxNumber {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateStorySenceMaxNumberResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateStorySenceMaxNumberResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateStorySenceMaxNumberResponse, rhs: Rankquantity_Voyager_Api_UpdateStorySenceMaxNumberResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateStoryRolePromptRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateStoryRolePromptRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0\u{3}role_id\0\u{3}user_id\0\u{1}prompt\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.prompt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 2)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 3)
    }
    if !self.prompt.isEmpty {
      try visitor.visitSingularStringField(value: self.prompt, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateStoryRolePromptRequest, rhs: Rankquantity_Voyager_Api_UpdateStoryRolePromptRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.roleID != rhs.roleID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.prompt != rhs.prompt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateStoryRolePromptResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateStoryRolePromptResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateStoryRolePromptResponse, rhs: Rankquantity_Voyager_Api_UpdateStoryRolePromptResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateStoryRoleDescriptionDetailRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateStoryRoleDescriptionDetailRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0\u{3}role_id\0\u{3}user_id\0\u{3}character_detail\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._characterDetail) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 2)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 3)
    }
    try { if let v = self._characterDetail {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateStoryRoleDescriptionDetailRequest, rhs: Rankquantity_Voyager_Api_UpdateStoryRoleDescriptionDetailRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.roleID != rhs.roleID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs._characterDetail != rhs._characterDetail {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateStoryRoleDescriptionDetailResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateStoryRoleDescriptionDetailResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateStoryRoleDescriptionDetailResponse, rhs: Rankquantity_Voyager_Api_UpdateStoryRoleDescriptionDetailResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GenerateStoryRoleParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateStoryRoleParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}origin_image_url\0\u{3}additional_image_urls\0\u{3}text_prompt\0\u{3}negative_prompt\0\u{1}style\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.originImageURL) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.additionalImageUrls) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.textPrompt) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.negativePrompt) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.style) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.originImageURL.isEmpty {
      try visitor.visitSingularStringField(value: self.originImageURL, fieldNumber: 1)
    }
    if !self.additionalImageUrls.isEmpty {
      try visitor.visitRepeatedStringField(value: self.additionalImageUrls, fieldNumber: 2)
    }
    if !self.textPrompt.isEmpty {
      try visitor.visitSingularStringField(value: self.textPrompt, fieldNumber: 3)
    }
    if !self.negativePrompt.isEmpty {
      try visitor.visitSingularStringField(value: self.negativePrompt, fieldNumber: 4)
    }
    if !self.style.isEmpty {
      try visitor.visitSingularStringField(value: self.style, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GenerateStoryRoleParams, rhs: Rankquantity_Voyager_Api_GenerateStoryRoleParams) -> Bool {
    if lhs.originImageURL != rhs.originImageURL {return false}
    if lhs.additionalImageUrls != rhs.additionalImageUrls {return false}
    if lhs.textPrompt != rhs.textPrompt {return false}
    if lhs.negativePrompt != rhs.negativePrompt {return false}
    if lhs.style != rhs.style {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GenerateStoryRolePosterRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateStoryRolePosterRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0\u{3}role_id\0\u{3}user_id\0\u{1}params\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._params) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 2)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 3)
    }
    try { if let v = self._params {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GenerateStoryRolePosterRequest, rhs: Rankquantity_Voyager_Api_GenerateStoryRolePosterRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.roleID != rhs.roleID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs._params != rhs._params {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GenerateStoryRolePosterResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateStoryRolePosterResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{3}image_url\0\u{3}poster_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.imageURL) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.posterID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.imageURL.isEmpty {
      try visitor.visitSingularStringField(value: self.imageURL, fieldNumber: 3)
    }
    if self.posterID != 0 {
      try visitor.visitSingularInt64Field(value: self.posterID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GenerateStoryRolePosterResponse, rhs: Rankquantity_Voyager_Api_GenerateStoryRolePosterResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.imageURL != rhs.imageURL {return false}
    if lhs.posterID != rhs.posterID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateStoryRolePosterRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateStoryRolePosterRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0\u{3}role_id\0\u{3}user_id\0\u{3}poster_id\0\u{3}image_url\0\u{3}is_public\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.posterID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.imageURL) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isPublic) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 2)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 3)
    }
    if self.posterID != 0 {
      try visitor.visitSingularInt64Field(value: self.posterID, fieldNumber: 4)
    }
    if !self.imageURL.isEmpty {
      try visitor.visitSingularStringField(value: self.imageURL, fieldNumber: 5)
    }
    if self.isPublic != false {
      try visitor.visitSingularBoolField(value: self.isPublic, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateStoryRolePosterRequest, rhs: Rankquantity_Voyager_Api_UpdateStoryRolePosterRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.roleID != rhs.roleID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.posterID != rhs.posterID {return false}
    if lhs.imageURL != rhs.imageURL {return false}
    if lhs.isPublic != rhs.isPublic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateStoryRolePosterResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateStoryRolePosterResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{3}poster_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.posterID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if self.posterID != 0 {
      try visitor.visitSingularInt64Field(value: self.posterID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateStoryRolePosterResponse, rhs: Rankquantity_Voyager_Api_UpdateStoryRolePosterResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.posterID != rhs.posterID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetFollowListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetFollowListRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetFollowListRequest, rhs: Rankquantity_Voyager_Api_GetFollowListRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetFollowListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetFollowListResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}followers\0\u{1}total\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.followers) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.followers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.followers, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 4)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetFollowListResponse, rhs: Rankquantity_Voyager_Api_GetFollowListResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.followers != rhs.followers {return false}
    if lhs.total != rhs.total {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetFollowerListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetFollowerListRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetFollowerListRequest, rhs: Rankquantity_Voyager_Api_GetFollowerListRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetFollowerListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetFollowerListResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}followers\0\u{1}total\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.followers) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.followers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.followers, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 4)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetFollowerListResponse, rhs: Rankquantity_Voyager_Api_GetFollowerListResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.followers != rhs.followers {return false}
    if lhs.total != rhs.total {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_FollowUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FollowUserRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{3}follower_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.followerID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.followerID != 0 {
      try visitor.visitSingularInt64Field(value: self.followerID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_FollowUserRequest, rhs: Rankquantity_Voyager_Api_FollowUserRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.followerID != rhs.followerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_FollowUserResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FollowUserResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_FollowUserResponse, rhs: Rankquantity_Voyager_Api_FollowUserResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UnfollowUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnfollowUserRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{3}follower_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.followerID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.followerID != 0 {
      try visitor.visitSingularInt64Field(value: self.followerID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UnfollowUserRequest, rhs: Rankquantity_Voyager_Api_UnfollowUserRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.followerID != rhs.followerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UnfollowUserResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnfollowUserResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UnfollowUserResponse, rhs: Rankquantity_Voyager_Api_UnfollowUserResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_TrendingStoryRoleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TrendingStoryRoleRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}start\0\u{1}end\0\u{3}page_size\0\u{3}page_number\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.start) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.end) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.pageNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.start != 0 {
      try visitor.visitSingularInt64Field(value: self.start, fieldNumber: 1)
    }
    if self.end != 0 {
      try visitor.visitSingularInt64Field(value: self.end, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 3)
    }
    if self.pageNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.pageNumber, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_TrendingStoryRoleRequest, rhs: Rankquantity_Voyager_Api_TrendingStoryRoleRequest) -> Bool {
    if lhs.start != rhs.start {return false}
    if lhs.end != rhs.end {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageNumber != rhs.pageNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_TrendingStoryRoleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TrendingStoryRoleResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_TrendingStoryRoleResponse, rhs: Rankquantity_Voyager_Api_TrendingStoryRoleResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_TrendingStoryRoleResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_TrendingStoryRoleResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}list\0\u{3}page_size\0\u{3}page_number\0\u{1}total\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.pageNumber) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 2)
    }
    if self.pageNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.pageNumber, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 4)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_TrendingStoryRoleResponse.DataMessage, rhs: Rankquantity_Voyager_Api_TrendingStoryRoleResponse.DataMessage) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageNumber != rhs.pageNumber {return false}
    if lhs.total != rhs.total {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_TrendingStoryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TrendingStoryRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}start\0\u{1}end\0\u{3}page_size\0\u{3}page_number\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.start) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.end) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.pageNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.start != 0 {
      try visitor.visitSingularInt64Field(value: self.start, fieldNumber: 1)
    }
    if self.end != 0 {
      try visitor.visitSingularInt64Field(value: self.end, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 3)
    }
    if self.pageNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.pageNumber, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_TrendingStoryRequest, rhs: Rankquantity_Voyager_Api_TrendingStoryRequest) -> Bool {
    if lhs.start != rhs.start {return false}
    if lhs.end != rhs.end {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageNumber != rhs.pageNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_TrendingStoryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TrendingStoryResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_TrendingStoryResponse, rhs: Rankquantity_Voyager_Api_TrendingStoryResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_TrendingStoryResponse.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rankquantity_Voyager_Api_TrendingStoryResponse.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}list\0\u{3}page_size\0\u{3}page_number\0\u{1}total\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.pageNumber) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 2)
    }
    if self.pageNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.pageNumber, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 4)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_TrendingStoryResponse.DataMessage, rhs: Rankquantity_Voyager_Api_TrendingStoryResponse.DataMessage) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageNumber != rhs.pageNumber {return false}
    if lhs.total != rhs.total {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryRoleListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryRoleListRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0\u{3}user_id\0\u{3}board_id\0\u{3}search_key\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.boardID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.searchKey) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if self.boardID != 0 {
      try visitor.visitSingularInt64Field(value: self.boardID, fieldNumber: 3)
    }
    if !self.searchKey.isEmpty {
      try visitor.visitSingularStringField(value: self.searchKey, fieldNumber: 4)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 5)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryRoleListRequest, rhs: Rankquantity_Voyager_Api_GetStoryRoleListRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.boardID != rhs.boardID {return false}
    if lhs.searchKey != rhs.searchKey {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryRoleListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryRoleListResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}roles\0\u{1}total\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.roles) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.roles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.roles, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 4)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryRoleListResponse, rhs: Rankquantity_Voyager_Api_GetStoryRoleListResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.roles != rhs.roles {return false}
    if lhs.total != rhs.total {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_ArchiveStoryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ArchiveStoryRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_ArchiveStoryRequest, rhs: Rankquantity_Voyager_Api_ArchiveStoryRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_ArchiveStoryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ArchiveStoryResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_ArchiveStoryResponse, rhs: Rankquantity_Voyager_Api_ArchiveStoryResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_CreateStoryCommentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateStoryCommentRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0\u{3}user_id\0\u{1}content\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.content) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_CreateStoryCommentRequest, rhs: Rankquantity_Voyager_Api_CreateStoryCommentRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_CreateStoryCommentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateStoryCommentResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}comment\0")

  fileprivate class _StorageClass {
    var _code: Rankquantity_Voyager_Api_ResponseCode = .ok
    var _message: String = String()
    var _comment: Rankquantity_Voyager_Api_CommentInfo? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _message = source._message
      _comment = source._comment
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._code) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._message) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._comment) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if !_storage._message.isEmpty {
        try visitor.visitSingularStringField(value: _storage._message, fieldNumber: 2)
      }
      try { if let v = _storage._comment {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_CreateStoryCommentResponse, rhs: Rankquantity_Voyager_Api_CreateStoryCommentResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._message != rhs_storage._message {return false}
        if _storage._comment != rhs_storage._comment {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryCommentsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryCommentsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0\u{3}user_id\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 3)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryCommentsRequest, rhs: Rankquantity_Voyager_Api_GetStoryCommentsRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_StoryComment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StoryComment"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}comment_id\0\u{3}story_id\0\u{3}board_id\0\u{3}role_id\0\u{3}prev_id\0\u{3}root_comment_id\0\u{3}user_id\0\u{1}content\0\u{3}created_at\0\u{3}updated_at\0\u{3}like_count\0\u{3}reply_count\0\u{3}is_liked\0\u{1}creator\0\u{3}created_at_timestamp\0")

  fileprivate class _StorageClass {
    var _commentID: Int64 = 0
    var _storyID: Int64 = 0
    var _boardID: Int64 = 0
    var _roleID: Int64 = 0
    var _prevID: Int64 = 0
    var _rootCommentID: Int64 = 0
    var _userID: Int64 = 0
    var _content: String = String()
    var _createdAt: Int64 = 0
    var _updatedAt: Int64 = 0
    var _likeCount: Int64 = 0
    var _replyCount: Int64 = 0
    var _isLiked: Int64 = 0
    var _creator: Rankquantity_Voyager_Api_UserInfo? = nil
    var _createdAtTimestamp: Int64 = 0

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _commentID = source._commentID
      _storyID = source._storyID
      _boardID = source._boardID
      _roleID = source._roleID
      _prevID = source._prevID
      _rootCommentID = source._rootCommentID
      _userID = source._userID
      _content = source._content
      _createdAt = source._createdAt
      _updatedAt = source._updatedAt
      _likeCount = source._likeCount
      _replyCount = source._replyCount
      _isLiked = source._isLiked
      _creator = source._creator
      _createdAtTimestamp = source._createdAtTimestamp
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._commentID) }()
        case 2: try { try decoder.decodeSingularInt64Field(value: &_storage._storyID) }()
        case 3: try { try decoder.decodeSingularInt64Field(value: &_storage._boardID) }()
        case 4: try { try decoder.decodeSingularInt64Field(value: &_storage._roleID) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._prevID) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._rootCommentID) }()
        case 7: try { try decoder.decodeSingularInt64Field(value: &_storage._userID) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._content) }()
        case 9: try { try decoder.decodeSingularInt64Field(value: &_storage._createdAt) }()
        case 10: try { try decoder.decodeSingularInt64Field(value: &_storage._updatedAt) }()
        case 11: try { try decoder.decodeSingularInt64Field(value: &_storage._likeCount) }()
        case 12: try { try decoder.decodeSingularInt64Field(value: &_storage._replyCount) }()
        case 13: try { try decoder.decodeSingularInt64Field(value: &_storage._isLiked) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._creator) }()
        case 15: try { try decoder.decodeSingularInt64Field(value: &_storage._createdAtTimestamp) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._commentID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._commentID, fieldNumber: 1)
      }
      if _storage._storyID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._storyID, fieldNumber: 2)
      }
      if _storage._boardID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._boardID, fieldNumber: 3)
      }
      if _storage._roleID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._roleID, fieldNumber: 4)
      }
      if _storage._prevID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._prevID, fieldNumber: 5)
      }
      if _storage._rootCommentID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._rootCommentID, fieldNumber: 6)
      }
      if _storage._userID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._userID, fieldNumber: 7)
      }
      if !_storage._content.isEmpty {
        try visitor.visitSingularStringField(value: _storage._content, fieldNumber: 8)
      }
      if _storage._createdAt != 0 {
        try visitor.visitSingularInt64Field(value: _storage._createdAt, fieldNumber: 9)
      }
      if _storage._updatedAt != 0 {
        try visitor.visitSingularInt64Field(value: _storage._updatedAt, fieldNumber: 10)
      }
      if _storage._likeCount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._likeCount, fieldNumber: 11)
      }
      if _storage._replyCount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._replyCount, fieldNumber: 12)
      }
      if _storage._isLiked != 0 {
        try visitor.visitSingularInt64Field(value: _storage._isLiked, fieldNumber: 13)
      }
      try { if let v = _storage._creator {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      if _storage._createdAtTimestamp != 0 {
        try visitor.visitSingularInt64Field(value: _storage._createdAtTimestamp, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_StoryComment, rhs: Rankquantity_Voyager_Api_StoryComment) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._commentID != rhs_storage._commentID {return false}
        if _storage._storyID != rhs_storage._storyID {return false}
        if _storage._boardID != rhs_storage._boardID {return false}
        if _storage._roleID != rhs_storage._roleID {return false}
        if _storage._prevID != rhs_storage._prevID {return false}
        if _storage._rootCommentID != rhs_storage._rootCommentID {return false}
        if _storage._userID != rhs_storage._userID {return false}
        if _storage._content != rhs_storage._content {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._updatedAt != rhs_storage._updatedAt {return false}
        if _storage._likeCount != rhs_storage._likeCount {return false}
        if _storage._replyCount != rhs_storage._replyCount {return false}
        if _storage._isLiked != rhs_storage._isLiked {return false}
        if _storage._creator != rhs_storage._creator {return false}
        if _storage._createdAtTimestamp != rhs_storage._createdAtTimestamp {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryCommentsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryCommentsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}comments\0\u{1}total\0\u{1}offset\0\u{3}page_size\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.comments) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.comments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.comments, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 4)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 5)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 6)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryCommentsResponse, rhs: Rankquantity_Voyager_Api_GetStoryCommentsResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.comments != rhs.comments {return false}
    if lhs.total != rhs.total {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_DeleteStoryCommentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteStoryCommentRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}comment_id\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.commentID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.commentID != 0 {
      try visitor.visitSingularInt64Field(value: self.commentID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_DeleteStoryCommentRequest, rhs: Rankquantity_Voyager_Api_DeleteStoryCommentRequest) -> Bool {
    if lhs.commentID != rhs.commentID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_DeleteStoryCommentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteStoryCommentResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_DeleteStoryCommentResponse, rhs: Rankquantity_Voyager_Api_DeleteStoryCommentResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryCommentRepliesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryCommentRepliesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}comment_id\0\u{3}user_id\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.commentID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.commentID != 0 {
      try visitor.visitSingularInt64Field(value: self.commentID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 3)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryCommentRepliesRequest, rhs: Rankquantity_Voyager_Api_GetStoryCommentRepliesRequest) -> Bool {
    if lhs.commentID != rhs.commentID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryCommentRepliesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryCommentRepliesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}replies\0\u{1}total\0\u{1}offset\0\u{3}page_size\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.replies) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.replies.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.replies, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 4)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 5)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 6)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryCommentRepliesResponse, rhs: Rankquantity_Voyager_Api_GetStoryCommentRepliesResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.replies != rhs.replies {return false}
    if lhs.total != rhs.total {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_CreateStoryCommentReplyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateStoryCommentReplyRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}comment_id\0\u{3}user_id\0\u{1}content\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.commentID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.content) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.commentID != 0 {
      try visitor.visitSingularInt64Field(value: self.commentID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_CreateStoryCommentReplyRequest, rhs: Rankquantity_Voyager_Api_CreateStoryCommentReplyRequest) -> Bool {
    if lhs.commentID != rhs.commentID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_CreateStoryCommentReplyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateStoryCommentReplyResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}comment\0")

  fileprivate class _StorageClass {
    var _code: Rankquantity_Voyager_Api_ResponseCode = .ok
    var _message: String = String()
    var _comment: Rankquantity_Voyager_Api_CommentInfo? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _message = source._message
      _comment = source._comment
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._code) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._message) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._comment) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if !_storage._message.isEmpty {
        try visitor.visitSingularStringField(value: _storage._message, fieldNumber: 2)
      }
      try { if let v = _storage._comment {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_CreateStoryCommentReplyResponse, rhs: Rankquantity_Voyager_Api_CreateStoryCommentReplyResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._message != rhs_storage._message {return false}
        if _storage._comment != rhs_storage._comment {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_DeleteStoryCommentReplyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteStoryCommentReplyRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}reply_id\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.replyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.replyID != 0 {
      try visitor.visitSingularInt64Field(value: self.replyID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_DeleteStoryCommentReplyRequest, rhs: Rankquantity_Voyager_Api_DeleteStoryCommentReplyRequest) -> Bool {
    if lhs.replyID != rhs.replyID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_DeleteStoryCommentReplyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteStoryCommentReplyResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_DeleteStoryCommentReplyResponse, rhs: Rankquantity_Voyager_Api_DeleteStoryCommentReplyResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryBoardCommentsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryBoardCommentsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}board_id\0\u{3}user_id\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.boardID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.boardID != 0 {
      try visitor.visitSingularInt64Field(value: self.boardID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 3)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryBoardCommentsRequest, rhs: Rankquantity_Voyager_Api_GetStoryBoardCommentsRequest) -> Bool {
    if lhs.boardID != rhs.boardID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryBoardCommentsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryBoardCommentsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}comments\0\u{1}total\0\u{1}offset\0\u{3}page_size\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.comments) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.comments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.comments, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 4)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 5)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 6)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryBoardCommentsResponse, rhs: Rankquantity_Voyager_Api_GetStoryBoardCommentsResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.comments != rhs.comments {return false}
    if lhs.total != rhs.total {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_CreateStoryBoardCommentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateStoryBoardCommentRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}board_id\0\u{3}user_id\0\u{1}content\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.boardID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.content) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.boardID != 0 {
      try visitor.visitSingularInt64Field(value: self.boardID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_CreateStoryBoardCommentRequest, rhs: Rankquantity_Voyager_Api_CreateStoryBoardCommentRequest) -> Bool {
    if lhs.boardID != rhs.boardID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_CreateStoryBoardCommentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateStoryBoardCommentResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}comment\0")

  fileprivate class _StorageClass {
    var _code: Rankquantity_Voyager_Api_ResponseCode = .ok
    var _message: String = String()
    var _comment: Rankquantity_Voyager_Api_CommentInfo? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _message = source._message
      _comment = source._comment
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._code) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._message) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._comment) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if !_storage._message.isEmpty {
        try visitor.visitSingularStringField(value: _storage._message, fieldNumber: 2)
      }
      try { if let v = _storage._comment {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_CreateStoryBoardCommentResponse, rhs: Rankquantity_Voyager_Api_CreateStoryBoardCommentResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._message != rhs_storage._message {return false}
        if _storage._comment != rhs_storage._comment {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_DeleteStoryBoardCommentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteStoryBoardCommentRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}board_id\0\u{3}comment_id\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.boardID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.commentID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.boardID != 0 {
      try visitor.visitSingularInt64Field(value: self.boardID, fieldNumber: 1)
    }
    if self.commentID != 0 {
      try visitor.visitSingularInt64Field(value: self.commentID, fieldNumber: 2)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_DeleteStoryBoardCommentRequest, rhs: Rankquantity_Voyager_Api_DeleteStoryBoardCommentRequest) -> Bool {
    if lhs.boardID != rhs.boardID {return false}
    if lhs.commentID != rhs.commentID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_DeleteStoryBoardCommentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteStoryBoardCommentResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_DeleteStoryBoardCommentResponse, rhs: Rankquantity_Voyager_Api_DeleteStoryBoardCommentResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryBoardCommentRepliesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryBoardCommentRepliesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}comment_id\0\u{3}user_id\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.commentID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.commentID != 0 {
      try visitor.visitSingularInt64Field(value: self.commentID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 3)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryBoardCommentRepliesRequest, rhs: Rankquantity_Voyager_Api_GetStoryBoardCommentRepliesRequest) -> Bool {
    if lhs.commentID != rhs.commentID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryBoardCommentRepliesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryBoardCommentRepliesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}replies\0\u{1}total\0\u{1}offset\0\u{3}page_size\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.replies) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.replies.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.replies, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 4)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 5)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 6)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryBoardCommentRepliesResponse, rhs: Rankquantity_Voyager_Api_GetStoryBoardCommentRepliesResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.replies != rhs.replies {return false}
    if lhs.total != rhs.total {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_LikeCommentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LikeCommentRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}comment_id\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.commentID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.commentID != 0 {
      try visitor.visitSingularInt64Field(value: self.commentID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_LikeCommentRequest, rhs: Rankquantity_Voyager_Api_LikeCommentRequest) -> Bool {
    if lhs.commentID != rhs.commentID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_LikeCommentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LikeCommentResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_LikeCommentResponse, rhs: Rankquantity_Voyager_Api_LikeCommentResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_DislikeCommentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DislikeCommentRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}comment_id\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.commentID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.commentID != 0 {
      try visitor.visitSingularInt64Field(value: self.commentID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_DislikeCommentRequest, rhs: Rankquantity_Voyager_Api_DislikeCommentRequest) -> Bool {
    if lhs.commentID != rhs.commentID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_DislikeCommentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DislikeCommentResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_DislikeCommentResponse, rhs: Rankquantity_Voyager_Api_DislikeCommentResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateRolePromptRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateRolePromptRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{3}role_id\0\u{1}prompt\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.prompt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 2)
    }
    if !self.prompt.isEmpty {
      try visitor.visitSingularStringField(value: self.prompt, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateRolePromptRequest, rhs: Rankquantity_Voyager_Api_UpdateRolePromptRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.roleID != rhs.roleID {return false}
    if lhs.prompt != rhs.prompt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateRolePromptResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateRolePromptResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateRolePromptResponse, rhs: Rankquantity_Voyager_Api_UpdateRolePromptResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GenerateRolePromptRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateRolePromptRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0\u{3}user_id\0\u{3}role_id\0\u{1}prompt\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.prompt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 3)
    }
    if !self.prompt.isEmpty {
      try visitor.visitSingularStringField(value: self.prompt, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GenerateRolePromptRequest, rhs: Rankquantity_Voyager_Api_GenerateRolePromptRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.roleID != rhs.roleID {return false}
    if lhs.prompt != rhs.prompt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GenerateRolePromptResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateRolePromptResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}prompt\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.prompt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.prompt.isEmpty {
      try visitor.visitSingularStringField(value: self.prompt, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GenerateRolePromptResponse, rhs: Rankquantity_Voyager_Api_GenerateRolePromptResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.prompt != rhs.prompt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateRoleDescriptionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateRoleDescriptionRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{3}role_id\0\u{1}description\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateRoleDescriptionRequest, rhs: Rankquantity_Voyager_Api_UpdateRoleDescriptionRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.roleID != rhs.roleID {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateRoleDescriptionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateRoleDescriptionResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateRoleDescriptionResponse, rhs: Rankquantity_Voyager_Api_UpdateRoleDescriptionResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GenerateRoleDescriptionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateRoleDescriptionRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0\u{3}user_id\0\u{3}role_id\0\u{1}description\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 3)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GenerateRoleDescriptionRequest, rhs: Rankquantity_Voyager_Api_GenerateRoleDescriptionRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.roleID != rhs.roleID {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GenerateRoleDescriptionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateRoleDescriptionResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{3}character_detail\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._characterDetail) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._characterDetail {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GenerateRoleDescriptionResponse, rhs: Rankquantity_Voyager_Api_GenerateRoleDescriptionResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._characterDetail != rhs._characterDetail {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetUnPublishStoryboardRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUnPublishStoryboardRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetUnPublishStoryboardRequest, rhs: Rankquantity_Voyager_Api_GetUnPublishStoryboardRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetUnPublishStoryboardResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUnPublishStoryboardResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}storyboardactives\0\u{1}total\0\u{1}offset\0\u{3}page_size\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.storyboardactives) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.storyboardactives.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.storyboardactives, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 4)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 5)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 6)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetUnPublishStoryboardResponse, rhs: Rankquantity_Voyager_Api_GetUnPublishStoryboardResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.storyboardactives != rhs.storyboardactives {return false}
    if lhs.total != rhs.total {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetUserWatchRoleActiveStoryBoardsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserWatchRoleActiveStoryBoardsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{3}role_id\0\u{1}offset\0\u{3}page_size\0\u{1}filter\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 2)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 3)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 4)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetUserWatchRoleActiveStoryBoardsRequest, rhs: Rankquantity_Voyager_Api_GetUserWatchRoleActiveStoryBoardsRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.roleID != rhs.roleID {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetUserWatchRoleActiveStoryBoardsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserWatchRoleActiveStoryBoardsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}storyboards\0\u{1}total\0\u{1}offset\0\u{3}page_size\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.storyboards) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.storyboards.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.storyboards, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 4)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 5)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 6)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetUserWatchRoleActiveStoryBoardsResponse, rhs: Rankquantity_Voyager_Api_GetUserWatchRoleActiveStoryBoardsResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.storyboards != rhs.storyboards {return false}
    if lhs.total != rhs.total {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetUserWatchStoryActiveStoryBoardsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserWatchStoryActiveStoryBoardsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{3}story_id\0\u{1}offset\0\u{3}page_size\0\u{1}filter\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 2)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 3)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 4)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetUserWatchStoryActiveStoryBoardsRequest, rhs: Rankquantity_Voyager_Api_GetUserWatchStoryActiveStoryBoardsRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.storyID != rhs.storyID {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetUserWatchStoryActiveStoryBoardsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserWatchStoryActiveStoryBoardsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}storyboards\0\u{1}total\0\u{1}offset\0\u{3}page_size\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.storyboards) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.storyboards.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.storyboards, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 4)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 5)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 6)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetUserWatchStoryActiveStoryBoardsResponse, rhs: Rankquantity_Voyager_Api_GetUserWatchStoryActiveStoryBoardsResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.storyboards != rhs.storyboards {return false}
    if lhs.total != rhs.total {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_SaveStoryboardCraftRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SaveStoryboardCraftRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}storyboard_id\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyboardID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyboardID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyboardID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_SaveStoryboardCraftRequest, rhs: Rankquantity_Voyager_Api_SaveStoryboardCraftRequest) -> Bool {
    if lhs.storyboardID != rhs.storyboardID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_SaveStoryboardCraftResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SaveStoryboardCraftResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_SaveStoryboardCraftResponse, rhs: Rankquantity_Voyager_Api_SaveStoryboardCraftResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_PublishStoryboardRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PublishStoryboardRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}storyboard_id\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyboardID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyboardID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyboardID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_PublishStoryboardRequest, rhs: Rankquantity_Voyager_Api_PublishStoryboardRequest) -> Bool {
    if lhs.storyboardID != rhs.storyboardID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_PublishStoryboardResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PublishStoryboardResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_PublishStoryboardResponse, rhs: Rankquantity_Voyager_Api_PublishStoryboardResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_CancelStoryboardRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CancelStoryboardRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}storyboard_id\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyboardID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyboardID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyboardID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_CancelStoryboardRequest, rhs: Rankquantity_Voyager_Api_CancelStoryboardRequest) -> Bool {
    if lhs.storyboardID != rhs.storyboardID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_CancelStoryboardResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CancelStoryboardResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_CancelStoryboardResponse, rhs: Rankquantity_Voyager_Api_CancelStoryboardResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_RenderStoryRoleContinuouslyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RenderStoryRoleContinuouslyRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}role_id\0\u{3}user_id\0\u{3}story_id\0\u{1}prompt\0\u{3}reference_image\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.prompt) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.referenceImage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 3)
    }
    if !self.prompt.isEmpty {
      try visitor.visitSingularStringField(value: self.prompt, fieldNumber: 4)
    }
    if !self.referenceImage.isEmpty {
      try visitor.visitSingularStringField(value: self.referenceImage, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_RenderStoryRoleContinuouslyRequest, rhs: Rankquantity_Voyager_Api_RenderStoryRoleContinuouslyRequest) -> Bool {
    if lhs.roleID != rhs.roleID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.storyID != rhs.storyID {return false}
    if lhs.prompt != rhs.prompt {return false}
    if lhs.referenceImage != rhs.referenceImage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_RenderStoryRoleContinuouslyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RenderStoryRoleContinuouslyResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}detail\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._detail) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._detail {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_RenderStoryRoleContinuouslyResponse, rhs: Rankquantity_Voyager_Api_RenderStoryRoleContinuouslyResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._detail != rhs._detail {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetNextStoryboardRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetNextStoryboardRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}storyboard_id\0\u{3}user_id\0\u{3}story_id\0\u{3}is_multi_branch\0\u{1}offset\0\u{3}page_size\0\u{1}total\0\u{3}order_by\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyboardID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isMultiBranch) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.orderBy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyboardID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyboardID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 3)
    }
    if self.isMultiBranch != false {
      try visitor.visitSingularBoolField(value: self.isMultiBranch, fieldNumber: 4)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 5)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 6)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 7)
    }
    if self.orderBy != .unspecified {
      try visitor.visitSingularEnumField(value: self.orderBy, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetNextStoryboardRequest, rhs: Rankquantity_Voyager_Api_GetNextStoryboardRequest) -> Bool {
    if lhs.storyboardID != rhs.storyboardID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.storyID != rhs.storyID {return false}
    if lhs.isMultiBranch != rhs.isMultiBranch {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.total != rhs.total {return false}
    if lhs.orderBy != rhs.orderBy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetNextStoryboardResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetNextStoryboardResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}storyboards\0\u{3}is_multi_branch\0\u{1}total\0\u{1}offset\0\u{3}page_size\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.storyboards) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isMultiBranch) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.storyboards.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.storyboards, fieldNumber: 3)
    }
    if self.isMultiBranch != false {
      try visitor.visitSingularBoolField(value: self.isMultiBranch, fieldNumber: 4)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 5)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 6)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 7)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetNextStoryboardResponse, rhs: Rankquantity_Voyager_Api_GetNextStoryboardResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.storyboards != rhs.storyboards {return false}
    if lhs.isMultiBranch != rhs.isMultiBranch {return false}
    if lhs.total != rhs.total {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetUserChatMessagesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserChatMessagesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{3}chat_id\0\u{3}role_id\0\u{1}timestamp\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.chatID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.chatID != 0 {
      try visitor.visitSingularInt64Field(value: self.chatID, fieldNumber: 2)
    }
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 3)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetUserChatMessagesRequest, rhs: Rankquantity_Voyager_Api_GetUserChatMessagesRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.chatID != rhs.chatID {return false}
    if lhs.roleID != rhs.roleID {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetUserChatMessagesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserChatMessagesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}messages\0\u{1}timestamp\0\u{1}total\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 3)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 4)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 5)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetUserChatMessagesResponse, rhs: Rankquantity_Voyager_Api_GetUserChatMessagesResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.messages != rhs.messages {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.total != rhs.total {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetUserChatWithRoleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserChatWithRoleRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}role_id\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetUserChatWithRoleRequest, rhs: Rankquantity_Voyager_Api_GetUserChatWithRoleRequest) -> Bool {
    if lhs.roleID != rhs.roleID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetUserChatWithRoleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserChatWithRoleResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}messages\0\u{3}chat_context\0\u{1}total\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._chatContext) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 3)
    }
    try { if let v = self._chatContext {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 5)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetUserChatWithRoleResponse, rhs: Rankquantity_Voyager_Api_GetUserChatWithRoleResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.messages != rhs.messages {return false}
    if lhs._chatContext != rhs._chatContext {return false}
    if lhs.total != rhs.total {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryRoleStoryboardsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryRoleStoryboardsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}role_id\0\u{3}user_id\0\u{3}story_id\0\u{1}filter\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 3)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 4)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 5)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryRoleStoryboardsRequest, rhs: Rankquantity_Voyager_Api_GetStoryRoleStoryboardsRequest) -> Bool {
    if lhs.roleID != rhs.roleID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.storyID != rhs.storyID {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryRoleStoryboardsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryRoleStoryboardsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}storyboardactives\0\u{1}total\0\u{1}offset\0\u{3}page_size\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.storyboardactives) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.storyboardactives.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.storyboardactives, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 4)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 5)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 6)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryRoleStoryboardsResponse, rhs: Rankquantity_Voyager_Api_GetStoryRoleStoryboardsResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.storyboardactives != rhs.storyboardactives {return false}
    if lhs.total != rhs.total {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryRoleStoriesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryRoleStoriesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}role_id\0\u{3}user_id\0\u{1}filter\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 3)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 4)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryRoleStoriesRequest, rhs: Rankquantity_Voyager_Api_GetStoryRoleStoriesRequest) -> Bool {
    if lhs.roleID != rhs.roleID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryRoleStoriesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryRoleStoriesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}stories\0\u{1}total\0\u{1}offset\0\u{3}page_size\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.stories) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.stories.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.stories, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 4)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 5)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 6)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryRoleStoriesResponse, rhs: Rankquantity_Voyager_Api_GetStoryRoleStoriesResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.stories != rhs.stories {return false}
    if lhs.total != rhs.total {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_CreateStoryRoleChatRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateStoryRoleChatRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}role_id\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_CreateStoryRoleChatRequest, rhs: Rankquantity_Voyager_Api_CreateStoryRoleChatRequest) -> Bool {
    if lhs.roleID != rhs.roleID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_ChatContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatContext"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}chat_id\0\u{3}role_id\0\u{3}user_id\0\u{1}timestamp\0\u{3}last_update_time\0\u{3}total_tokens\0\u{3}total_messages\0\u{3}last_message\0\u{1}user\0\u{1}role\0")

  fileprivate class _StorageClass {
    var _chatID: Int64 = 0
    var _roleID: Int64 = 0
    var _userID: Int64 = 0
    var _timestamp: Int64 = 0
    var _lastUpdateTime: Int64 = 0
    var _totalTokens: Int64 = 0
    var _totalMessages: Int64 = 0
    var _lastMessage: Rankquantity_Voyager_Api_ChatMessage? = nil
    var _user: Rankquantity_Voyager_Api_UserInfo? = nil
    var _role: Rankquantity_Voyager_Api_StoryRole? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _chatID = source._chatID
      _roleID = source._roleID
      _userID = source._userID
      _timestamp = source._timestamp
      _lastUpdateTime = source._lastUpdateTime
      _totalTokens = source._totalTokens
      _totalMessages = source._totalMessages
      _lastMessage = source._lastMessage
      _user = source._user
      _role = source._role
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._chatID) }()
        case 2: try { try decoder.decodeSingularInt64Field(value: &_storage._roleID) }()
        case 3: try { try decoder.decodeSingularInt64Field(value: &_storage._userID) }()
        case 4: try { try decoder.decodeSingularInt64Field(value: &_storage._timestamp) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._lastUpdateTime) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._totalTokens) }()
        case 7: try { try decoder.decodeSingularInt64Field(value: &_storage._totalMessages) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._lastMessage) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._role) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._chatID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._chatID, fieldNumber: 1)
      }
      if _storage._roleID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._roleID, fieldNumber: 2)
      }
      if _storage._userID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._userID, fieldNumber: 3)
      }
      if _storage._timestamp != 0 {
        try visitor.visitSingularInt64Field(value: _storage._timestamp, fieldNumber: 4)
      }
      if _storage._lastUpdateTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._lastUpdateTime, fieldNumber: 5)
      }
      if _storage._totalTokens != 0 {
        try visitor.visitSingularInt64Field(value: _storage._totalTokens, fieldNumber: 6)
      }
      if _storage._totalMessages != 0 {
        try visitor.visitSingularInt64Field(value: _storage._totalMessages, fieldNumber: 7)
      }
      try { if let v = _storage._lastMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._role {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_ChatContext, rhs: Rankquantity_Voyager_Api_ChatContext) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._chatID != rhs_storage._chatID {return false}
        if _storage._roleID != rhs_storage._roleID {return false}
        if _storage._userID != rhs_storage._userID {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._lastUpdateTime != rhs_storage._lastUpdateTime {return false}
        if _storage._totalTokens != rhs_storage._totalTokens {return false}
        if _storage._totalMessages != rhs_storage._totalMessages {return false}
        if _storage._lastMessage != rhs_storage._lastMessage {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._role != rhs_storage._role {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_CreateStoryRoleChatResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateStoryRoleChatResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{3}chat_context\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._chatContext) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._chatContext {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_CreateStoryRoleChatResponse, rhs: Rankquantity_Voyager_Api_CreateStoryRoleChatResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._chatContext != rhs._chatContext {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_ChatWithStoryRoleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatWithStoryRoleRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}role_id\0\u{3}user_id\0\u{1}messages\0\u{1}total\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 4)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_ChatWithStoryRoleRequest, rhs: Rankquantity_Voyager_Api_ChatWithStoryRoleRequest) -> Bool {
    if lhs.roleID != rhs.roleID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.messages != rhs.messages {return false}
    if lhs.total != rhs.total {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_ChatWithStoryRoleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatWithStoryRoleResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{3}reply_messages\0\u{1}total\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.replyMessages) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.replyMessages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.replyMessages, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 4)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_ChatWithStoryRoleResponse, rhs: Rankquantity_Voyager_Api_ChatWithStoryRoleResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.replyMessages != rhs.replyMessages {return false}
    if lhs.total != rhs.total {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateStoryRoleDetailRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateStoryRoleDetailRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}role_id\0\u{1}role\0\u{3}user_id\0\u{3}need_regen\0\u{3}background_image\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._role) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.needRegen) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.backgroundImage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 1)
    }
    try { if let v = self._role {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 3)
    }
    if self.needRegen != false {
      try visitor.visitSingularBoolField(value: self.needRegen, fieldNumber: 4)
    }
    if !self.backgroundImage.isEmpty {
      try visitor.visitSingularStringField(value: self.backgroundImage, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateStoryRoleDetailRequest, rhs: Rankquantity_Voyager_Api_UpdateStoryRoleDetailRequest) -> Bool {
    if lhs.roleID != rhs.roleID {return false}
    if lhs._role != rhs._role {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.needRegen != rhs.needRegen {return false}
    if lhs.backgroundImage != rhs.backgroundImage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateStoryRoleDetailResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateStoryRoleDetailResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateStoryRoleDetailResponse, rhs: Rankquantity_Voyager_Api_UpdateStoryRoleDetailResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateStoryRoleAvatorRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateStoryRoleAvatorRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}role_id\0\u{1}avator\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.avator) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 1)
    }
    if !self.avator.isEmpty {
      try visitor.visitSingularStringField(value: self.avator, fieldNumber: 2)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateStoryRoleAvatorRequest, rhs: Rankquantity_Voyager_Api_UpdateStoryRoleAvatorRequest) -> Bool {
    if lhs.roleID != rhs.roleID {return false}
    if lhs.avator != rhs.avator {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateStoryRoleAvatorResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateStoryRoleAvatorResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateStoryRoleAvatorResponse, rhs: Rankquantity_Voyager_Api_UpdateStoryRoleAvatorResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetUserWithRoleChatListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserWithRoleChatListRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{3}story_id\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 2)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 3)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetUserWithRoleChatListRequest, rhs: Rankquantity_Voyager_Api_GetUserWithRoleChatListRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.storyID != rhs.storyID {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetUserWithRoleChatListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserWithRoleChatListResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}chats\0\u{1}total\0\u{1}offset\0\u{3}page_size\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.chats) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.chats.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.chats, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 4)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 5)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 6)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetUserWithRoleChatListResponse, rhs: Rankquantity_Voyager_Api_GetUserWithRoleChatListResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.chats != rhs.chats {return false}
    if lhs.total != rhs.total {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetUserCreatedStoryboardsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserCreatedStoryboardsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{3}story_id\0\u{1}stage\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.storyID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.stage) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.storyID != 0 {
      try visitor.visitSingularInt32Field(value: self.storyID, fieldNumber: 2)
    }
    if self.stage != 0 {
      try visitor.visitSingularInt32Field(value: self.stage, fieldNumber: 3)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 4)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetUserCreatedStoryboardsRequest, rhs: Rankquantity_Voyager_Api_GetUserCreatedStoryboardsRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.storyID != rhs.storyID {return false}
    if lhs.stage != rhs.stage {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetUserCreatedStoryboardsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserCreatedStoryboardsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}storyboards\0\u{1}total\0\u{3}have_more\0\u{1}offset\0\u{4}\u{2}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.storyboards) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.storyboards.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.storyboards, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 4)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 5)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 6)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetUserCreatedStoryboardsResponse, rhs: Rankquantity_Voyager_Api_GetUserCreatedStoryboardsResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.storyboards != rhs.storyboards {return false}
    if lhs.total != rhs.total {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetUserCreatedRolesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserCreatedRolesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{3}story_id\0\u{1}stage\0\u{1}offset\0\u{3}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.storyID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.stage) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.storyID != 0 {
      try visitor.visitSingularInt32Field(value: self.storyID, fieldNumber: 2)
    }
    if self.stage != 0 {
      try visitor.visitSingularInt32Field(value: self.stage, fieldNumber: 3)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 4)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetUserCreatedRolesRequest, rhs: Rankquantity_Voyager_Api_GetUserCreatedRolesRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.storyID != rhs.storyID {return false}
    if lhs.stage != rhs.stage {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetUserCreatedRolesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserCreatedRolesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}roles\0\u{1}total\0\u{3}have_more\0\u{1}offset\0\u{4}\u{2}page_size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.roles) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.roles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.roles, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 4)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 5)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 6)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetUserCreatedRolesResponse, rhs: Rankquantity_Voyager_Api_GetUserCreatedRolesResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.roles != rhs.roles {return false}
    if lhs.total != rhs.total {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_LikeStoryRoleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LikeStoryRoleRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}role_id\0\u{3}user_id\0\u{3}story_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_LikeStoryRoleRequest, rhs: Rankquantity_Voyager_Api_LikeStoryRoleRequest) -> Bool {
    if lhs.roleID != rhs.roleID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.storyID != rhs.storyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_LikeStoryRoleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LikeStoryRoleResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_LikeStoryRoleResponse, rhs: Rankquantity_Voyager_Api_LikeStoryRoleResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UnLikeStoryRoleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnLikeStoryRoleRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}role_id\0\u{3}user_id\0\u{3}story_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UnLikeStoryRoleRequest, rhs: Rankquantity_Voyager_Api_UnLikeStoryRoleRequest) -> Bool {
    if lhs.roleID != rhs.roleID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.storyID != rhs.storyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UnLikeStoryRoleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnLikeStoryRoleResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UnLikeStoryRoleResponse, rhs: Rankquantity_Voyager_Api_UnLikeStoryRoleResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_FollowStoryRoleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FollowStoryRoleRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}role_id\0\u{3}user_id\0\u{3}story_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_FollowStoryRoleRequest, rhs: Rankquantity_Voyager_Api_FollowStoryRoleRequest) -> Bool {
    if lhs.roleID != rhs.roleID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.storyID != rhs.storyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_FollowStoryRoleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FollowStoryRoleResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_FollowStoryRoleResponse, rhs: Rankquantity_Voyager_Api_FollowStoryRoleResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UnFollowStoryRoleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnFollowStoryRoleRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}role_id\0\u{3}user_id\0\u{3}story_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UnFollowStoryRoleRequest, rhs: Rankquantity_Voyager_Api_UnFollowStoryRoleRequest) -> Bool {
    if lhs.roleID != rhs.roleID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.storyID != rhs.storyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UnFollowStoryRoleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnFollowStoryRoleResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UnFollowStoryRoleResponse, rhs: Rankquantity_Voyager_Api_UnFollowStoryRoleResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_SearchStoriesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchStoriesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{1}keyword\0\u{1}offset\0\u{3}page_size\0\u{1}scope\0\u{4}\u{2}group_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.keyword) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.scope) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.groupID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if !self.keyword.isEmpty {
      try visitor.visitSingularStringField(value: self.keyword, fieldNumber: 2)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 3)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 4)
    }
    if self.scope != .protectScope {
      try visitor.visitSingularEnumField(value: self.scope, fieldNumber: 5)
    }
    if self.groupID != 0 {
      try visitor.visitSingularInt64Field(value: self.groupID, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_SearchStoriesRequest, rhs: Rankquantity_Voyager_Api_SearchStoriesRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.keyword != rhs.keyword {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.scope != rhs.scope {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_SearchStoriesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchStoriesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}stories\0\u{1}total\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.stories) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.stories.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.stories, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 4)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_SearchStoriesResponse, rhs: Rankquantity_Voyager_Api_SearchStoriesResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.stories != rhs.stories {return false}
    if lhs.total != rhs.total {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_SearchRolesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchRolesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{1}keyword\0\u{1}offset\0\u{3}page_size\0\u{1}scope\0\u{3}story_id\0\u{3}group_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.keyword) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.scope) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.groupID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if !self.keyword.isEmpty {
      try visitor.visitSingularStringField(value: self.keyword, fieldNumber: 2)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 3)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 4)
    }
    if self.scope != .protectScope {
      try visitor.visitSingularEnumField(value: self.scope, fieldNumber: 5)
    }
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 6)
    }
    if self.groupID != 0 {
      try visitor.visitSingularInt64Field(value: self.groupID, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_SearchRolesRequest, rhs: Rankquantity_Voyager_Api_SearchRolesRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.keyword != rhs.keyword {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.scope != rhs.scope {return false}
    if lhs.storyID != rhs.storyID {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_SearchRolesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchRolesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}roles\0\u{1}total\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.roles) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.roles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.roles, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 4)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_SearchRolesResponse, rhs: Rankquantity_Voyager_Api_SearchRolesResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.roles != rhs.roles {return false}
    if lhs.total != rhs.total {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_RestoreStoryboardRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RestoreStoryboardRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}storyboard_id\0\u{3}user_id\0\u{3}story_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyboardID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyboardID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyboardID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_RestoreStoryboardRequest, rhs: Rankquantity_Voyager_Api_RestoreStoryboardRequest) -> Bool {
    if lhs.storyboardID != rhs.storyboardID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.storyID != rhs.storyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_RestoreStoryboardResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RestoreStoryboardResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}store\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._store) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._store {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_RestoreStoryboardResponse, rhs: Rankquantity_Voyager_Api_RestoreStoryboardResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._store != rhs._store {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_StoryboardStageStore: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StoryboardStageStore"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}storyboard\0\u{1}sences\0\u{1}stage\0\u{3}last_update_time\0\u{1}version\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._storyboard) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._sences) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.stage) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.lastUpdateTime) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.version) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._storyboard {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._sences {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.stage != .unspecified {
      try visitor.visitSingularEnumField(value: self.stage, fieldNumber: 3)
    }
    if self.lastUpdateTime != 0 {
      try visitor.visitSingularInt64Field(value: self.lastUpdateTime, fieldNumber: 4)
    }
    if self.version != 0 {
      try visitor.visitSingularInt64Field(value: self.version, fieldNumber: 5)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_StoryboardStageStore, rhs: Rankquantity_Voyager_Api_StoryboardStageStore) -> Bool {
    if lhs._storyboard != rhs._storyboard {return false}
    if lhs._sences != rhs._sences {return false}
    if lhs.stage != rhs.stage {return false}
    if lhs.lastUpdateTime != rhs.lastUpdateTime {return false}
    if lhs.version != rhs.version {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetUserProfileRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserProfileRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetUserProfileRequest, rhs: Rankquantity_Voyager_Api_GetUserProfileRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetUserProfileResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserProfileResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}info\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetUserProfileResponse, rhs: Rankquantity_Voyager_Api_GetUserProfileResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._info != rhs._info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateUserProfileRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateUserProfileRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{3}background_image\0\u{1}avatar\0\u{1}name\0\u{1}description\0\u{1}location\0\u{1}email\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.backgroundImage) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.avatar) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.location) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.email) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if !self.backgroundImage.isEmpty {
      try visitor.visitSingularStringField(value: self.backgroundImage, fieldNumber: 2)
    }
    if !self.avatar.isEmpty {
      try visitor.visitSingularStringField(value: self.avatar, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 5)
    }
    if !self.location.isEmpty {
      try visitor.visitSingularStringField(value: self.location, fieldNumber: 6)
    }
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateUserProfileRequest, rhs: Rankquantity_Voyager_Api_UpdateUserProfileRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.backgroundImage != rhs.backgroundImage {return false}
    if lhs.avatar != rhs.avatar {return false}
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.location != rhs.location {return false}
    if lhs.email != rhs.email {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateUserProfileResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateUserProfileResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateUserProfileResponse, rhs: Rankquantity_Voyager_Api_UpdateUserProfileResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateUserBackgroundImageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateUserBackgroundImageRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{3}background_image\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.backgroundImage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if !self.backgroundImage.isEmpty {
      try visitor.visitSingularStringField(value: self.backgroundImage, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateUserBackgroundImageRequest, rhs: Rankquantity_Voyager_Api_UpdateUserBackgroundImageRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.backgroundImage != rhs.backgroundImage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateUserBackgroundImageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateUserBackgroundImageResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateUserBackgroundImageResponse, rhs: Rankquantity_Voyager_Api_UpdateUserBackgroundImageResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_CreateStoryRoleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateStoryRoleRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{1}role\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._role) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    try { if let v = self._role {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_CreateStoryRoleRequest, rhs: Rankquantity_Voyager_Api_CreateStoryRoleRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs._role != rhs._role {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_CreateStoryRoleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateStoryRoleResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_CreateStoryRoleResponse, rhs: Rankquantity_Voyager_Api_CreateStoryRoleResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryRoleDetailRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryRoleDetailRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}role_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryRoleDetailRequest, rhs: Rankquantity_Voyager_Api_GetStoryRoleDetailRequest) -> Bool {
    if lhs.roleID != rhs.roleID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryRoleDetailResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryRoleDetailResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}info\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryRoleDetailResponse, rhs: Rankquantity_Voyager_Api_GetStoryRoleDetailResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._info != rhs._info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_RenderStoryRoleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RenderStoryRoleRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}role_id\0\u{1}prompt\0\u{3}ref_images\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.prompt) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.refImages) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 1)
    }
    if !self.prompt.isEmpty {
      try visitor.visitSingularStringField(value: self.prompt, fieldNumber: 2)
    }
    if !self.refImages.isEmpty {
      try visitor.visitRepeatedStringField(value: self.refImages, fieldNumber: 3)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_RenderStoryRoleRequest, rhs: Rankquantity_Voyager_Api_RenderStoryRoleRequest) -> Bool {
    if lhs.roleID != rhs.roleID {return false}
    if lhs.prompt != rhs.prompt {return false}
    if lhs.refImages != rhs.refImages {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_RenderStoryRoleDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RenderStoryRoleDetail"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}role_id\0\u{3}gen_id\0\u{3}is_finished\0\u{3}role_description\0\u{3}role_character\0\u{3}role_behavior\0\u{3}role_goal\0\u{3}background_image\0\u{3}avatar_image\0\u{1}background\0\u{1}appearance\0\u{1}personality\0\u{3}ability_features\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.roleID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.genID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isFinished) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.roleDescription) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.roleCharacter) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.roleBehavior) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.roleGoal) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.backgroundImage) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.avatarImage) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.background) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.appearance) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.personality) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.abilityFeatures) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.roleID != 0 {
      try visitor.visitSingularInt64Field(value: self.roleID, fieldNumber: 1)
    }
    if self.genID != 0 {
      try visitor.visitSingularInt64Field(value: self.genID, fieldNumber: 2)
    }
    if self.isFinished != false {
      try visitor.visitSingularBoolField(value: self.isFinished, fieldNumber: 3)
    }
    if !self.roleDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.roleDescription, fieldNumber: 4)
    }
    if !self.roleCharacter.isEmpty {
      try visitor.visitSingularStringField(value: self.roleCharacter, fieldNumber: 5)
    }
    if !self.roleBehavior.isEmpty {
      try visitor.visitSingularStringField(value: self.roleBehavior, fieldNumber: 6)
    }
    if !self.roleGoal.isEmpty {
      try visitor.visitSingularStringField(value: self.roleGoal, fieldNumber: 7)
    }
    if !self.backgroundImage.isEmpty {
      try visitor.visitSingularStringField(value: self.backgroundImage, fieldNumber: 8)
    }
    if !self.avatarImage.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarImage, fieldNumber: 9)
    }
    if !self.background.isEmpty {
      try visitor.visitSingularStringField(value: self.background, fieldNumber: 10)
    }
    if !self.appearance.isEmpty {
      try visitor.visitSingularStringField(value: self.appearance, fieldNumber: 11)
    }
    if !self.personality.isEmpty {
      try visitor.visitSingularStringField(value: self.personality, fieldNumber: 12)
    }
    if !self.abilityFeatures.isEmpty {
      try visitor.visitSingularStringField(value: self.abilityFeatures, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_RenderStoryRoleDetail, rhs: Rankquantity_Voyager_Api_RenderStoryRoleDetail) -> Bool {
    if lhs.roleID != rhs.roleID {return false}
    if lhs.genID != rhs.genID {return false}
    if lhs.isFinished != rhs.isFinished {return false}
    if lhs.roleDescription != rhs.roleDescription {return false}
    if lhs.roleCharacter != rhs.roleCharacter {return false}
    if lhs.roleBehavior != rhs.roleBehavior {return false}
    if lhs.roleGoal != rhs.roleGoal {return false}
    if lhs.backgroundImage != rhs.backgroundImage {return false}
    if lhs.avatarImage != rhs.avatarImage {return false}
    if lhs.background != rhs.background {return false}
    if lhs.appearance != rhs.appearance {return false}
    if lhs.personality != rhs.personality {return false}
    if lhs.abilityFeatures != rhs.abilityFeatures {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_RenderStoryRoleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RenderStoryRoleResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}detail\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._detail) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._detail {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_RenderStoryRoleResponse, rhs: Rankquantity_Voyager_Api_RenderStoryRoleResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._detail != rhs._detail {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_LikeStoryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LikeStoryRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_LikeStoryRequest, rhs: Rankquantity_Voyager_Api_LikeStoryRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_LikeStoryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LikeStoryResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_LikeStoryResponse, rhs: Rankquantity_Voyager_Api_LikeStoryResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UnLikeStoryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnLikeStoryRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UnLikeStoryRequest, rhs: Rankquantity_Voyager_Api_UnLikeStoryRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UnLikeStoryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnLikeStoryResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UnLikeStoryResponse, rhs: Rankquantity_Voyager_Api_UnLikeStoryResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_DeleteUserStoryboardDraftRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteUserStoryboardDraftRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{3}draft_id\0\u{3}story_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.draftID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.draftID != 0 {
      try visitor.visitSingularInt64Field(value: self.draftID, fieldNumber: 2)
    }
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_DeleteUserStoryboardDraftRequest, rhs: Rankquantity_Voyager_Api_DeleteUserStoryboardDraftRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.draftID != rhs.draftID {return false}
    if lhs.storyID != rhs.storyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_DeleteUserStoryboardDraftResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteUserStoryboardDraftResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_DeleteUserStoryboardDraftResponse, rhs: Rankquantity_Voyager_Api_DeleteUserStoryboardDraftResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_HeatmapDataItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HeatmapDataItem"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}date\0\u{1}count\0\u{1}level\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.date) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.count) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.level) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.date.isEmpty {
      try visitor.visitSingularStringField(value: self.date, fieldNumber: 1)
    }
    if self.count != 0 {
      try visitor.visitSingularInt64Field(value: self.count, fieldNumber: 2)
    }
    if self.level != 0 {
      try visitor.visitSingularInt64Field(value: self.level, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_HeatmapDataItem, rhs: Rankquantity_Voyager_Api_HeatmapDataItem) -> Bool {
    if lhs.date != rhs.date {return false}
    if lhs.count != rhs.count {return false}
    if lhs.level != rhs.level {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UserActiveHeamapRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserActiveHeamapRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{3}start_time\0\u{3}end_time\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.startTime) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.endTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.startTime != 0 {
      try visitor.visitSingularInt64Field(value: self.startTime, fieldNumber: 2)
    }
    if self.endTime != 0 {
      try visitor.visitSingularInt64Field(value: self.endTime, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UserActiveHeamapRequest, rhs: Rankquantity_Voyager_Api_UserActiveHeamapRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.startTime != rhs.startTime {return false}
    if lhs.endTime != rhs.endTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UserActiveHeamapResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserActiveHeamapResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0\u{3}total_count\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.data) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.totalCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 3)
    }
    if self.totalCount != 0 {
      try visitor.visitSingularInt64Field(value: self.totalCount, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UserActiveHeamapResponse, rhs: Rankquantity_Voyager_Api_UserActiveHeamapResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.data != rhs.data {return false}
    if lhs.totalCount != rhs.totalCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GroupActiveHeamapRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupActiveHeamapRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_id\0\u{3}user_id\0\u{3}start_time\0\u{3}end_time\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.startTime) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.endTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.groupID != 0 {
      try visitor.visitSingularInt64Field(value: self.groupID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if self.startTime != 0 {
      try visitor.visitSingularInt64Field(value: self.startTime, fieldNumber: 3)
    }
    if self.endTime != 0 {
      try visitor.visitSingularInt64Field(value: self.endTime, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GroupActiveHeamapRequest, rhs: Rankquantity_Voyager_Api_GroupActiveHeamapRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.startTime != rhs.startTime {return false}
    if lhs.endTime != rhs.endTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GroupActiveHeamapResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupActiveHeamapResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0\u{3}total_count\0\u{3}member_count\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.data) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.totalCount) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.memberCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 3)
    }
    if self.totalCount != 0 {
      try visitor.visitSingularInt64Field(value: self.totalCount, fieldNumber: 4)
    }
    if self.memberCount != 0 {
      try visitor.visitSingularInt64Field(value: self.memberCount, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GroupActiveHeamapResponse, rhs: Rankquantity_Voyager_Api_GroupActiveHeamapResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.data != rhs.data {return false}
    if lhs.totalCount != rhs.totalCount {return false}
    if lhs.memberCount != rhs.memberCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateStoryboardForkAbleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateStoryboardForkAbleRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{3}storyboard_id\0\u{3}fork_able\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.storyboardID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.forkAble) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.storyboardID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyboardID, fieldNumber: 2)
    }
    if self.forkAble != false {
      try visitor.visitSingularBoolField(value: self.forkAble, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateStoryboardForkAbleRequest, rhs: Rankquantity_Voyager_Api_UpdateStoryboardForkAbleRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.storyboardID != rhs.storyboardID {return false}
    if lhs.forkAble != rhs.forkAble {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UpdateStoryboardForkAbleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateStoryboardForkAbleResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UpdateStoryboardForkAbleResponse, rhs: Rankquantity_Voyager_Api_UpdateStoryboardForkAbleResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UserStoryboardDraftlistRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserStoryboardDraftlistRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{1}offset\0\u{3}page_size\0\u{3}story_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt64Field(value: self.pageSize, fieldNumber: 3)
    }
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UserStoryboardDraftlistRequest, rhs: Rankquantity_Voyager_Api_UserStoryboardDraftlistRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.storyID != rhs.storyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UserStoryboardDraftlistResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserStoryboardDraftlistResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}drafts\0\u{1}total\0\u{3}have_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.drafts) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.haveMore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.drafts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.drafts, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 4)
    }
    if self.haveMore != false {
      try visitor.visitSingularBoolField(value: self.haveMore, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UserStoryboardDraftlistResponse, rhs: Rankquantity_Voyager_Api_UserStoryboardDraftlistResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.drafts != rhs.drafts {return false}
    if lhs.total != rhs.total {return false}
    if lhs.haveMore != rhs.haveMore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_StoryboardDraftDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StoryboardDraftDetail"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}draft_id\0\u{3}story_id\0\u{3}storyboard_id\0\u{1}title\0\u{1}content\0\u{1}background\0\u{1}roles\0\u{1}sences\0\u{1}params\0\u{3}created_at\0\u{3}updated_at\0\u{1}stage\0\u{3}user_id\0")

  fileprivate class _StorageClass {
    var _draftID: Int64 = 0
    var _storyID: Int64 = 0
    var _storyboardID: Int64 = 0
    var _title: String = String()
    var _content: String = String()
    var _background: String = String()
    var _roles: [Rankquantity_Voyager_Api_StoryRole] = []
    var _sences: Rankquantity_Voyager_Api_StoryBoardSences? = nil
    var _params: Rankquantity_Voyager_Api_StoryBoardParams? = nil
    var _createdAt: Int64 = 0
    var _updatedAt: Int64 = 0
    var _stage: Rankquantity_Voyager_Api_StoryboardStage = .unspecified
    var _userID: Int64 = 0

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _draftID = source._draftID
      _storyID = source._storyID
      _storyboardID = source._storyboardID
      _title = source._title
      _content = source._content
      _background = source._background
      _roles = source._roles
      _sences = source._sences
      _params = source._params
      _createdAt = source._createdAt
      _updatedAt = source._updatedAt
      _stage = source._stage
      _userID = source._userID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._draftID) }()
        case 2: try { try decoder.decodeSingularInt64Field(value: &_storage._storyID) }()
        case 3: try { try decoder.decodeSingularInt64Field(value: &_storage._storyboardID) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._title) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._content) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._background) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._roles) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._sences) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._params) }()
        case 10: try { try decoder.decodeSingularInt64Field(value: &_storage._createdAt) }()
        case 11: try { try decoder.decodeSingularInt64Field(value: &_storage._updatedAt) }()
        case 12: try { try decoder.decodeSingularEnumField(value: &_storage._stage) }()
        case 13: try { try decoder.decodeSingularInt64Field(value: &_storage._userID) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._draftID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._draftID, fieldNumber: 1)
      }
      if _storage._storyID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._storyID, fieldNumber: 2)
      }
      if _storage._storyboardID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._storyboardID, fieldNumber: 3)
      }
      if !_storage._title.isEmpty {
        try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 4)
      }
      if !_storage._content.isEmpty {
        try visitor.visitSingularStringField(value: _storage._content, fieldNumber: 5)
      }
      if !_storage._background.isEmpty {
        try visitor.visitSingularStringField(value: _storage._background, fieldNumber: 6)
      }
      if !_storage._roles.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._roles, fieldNumber: 7)
      }
      try { if let v = _storage._sences {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._params {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if _storage._createdAt != 0 {
        try visitor.visitSingularInt64Field(value: _storage._createdAt, fieldNumber: 10)
      }
      if _storage._updatedAt != 0 {
        try visitor.visitSingularInt64Field(value: _storage._updatedAt, fieldNumber: 11)
      }
      if _storage._stage != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._stage, fieldNumber: 12)
      }
      if _storage._userID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._userID, fieldNumber: 13)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_StoryboardDraftDetail, rhs: Rankquantity_Voyager_Api_StoryboardDraftDetail) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._draftID != rhs_storage._draftID {return false}
        if _storage._storyID != rhs_storage._storyID {return false}
        if _storage._storyboardID != rhs_storage._storyboardID {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._content != rhs_storage._content {return false}
        if _storage._background != rhs_storage._background {return false}
        if _storage._roles != rhs_storage._roles {return false}
        if _storage._sences != rhs_storage._sences {return false}
        if _storage._params != rhs_storage._params {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._updatedAt != rhs_storage._updatedAt {return false}
        if _storage._stage != rhs_storage._stage {return false}
        if _storage._userID != rhs_storage._userID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UserDraftStoryboardDetailRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserDraftStoryboardDetailRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{3}draft_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.draftID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.draftID != 0 {
      try visitor.visitSingularInt64Field(value: self.draftID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UserDraftStoryboardDetailRequest, rhs: Rankquantity_Voyager_Api_UserDraftStoryboardDetailRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.draftID != rhs.draftID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_UserDraftStoryboardDetailResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserDraftStoryboardDetailResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}detail\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._detail) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._detail {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_UserDraftStoryboardDetailResponse, rhs: Rankquantity_Voyager_Api_UserDraftStoryboardDetailResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._detail != rhs._detail {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_TokenConsumption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TokenConsumption"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}token_count\0\u{3}source_type\0\u{3}source_id\0\u{3}consumed_at\0\u{1}purpose\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.tokenCount) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.sourceType) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.sourceID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.consumedAt) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.purpose) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tokenCount != 0 {
      try visitor.visitSingularInt64Field(value: self.tokenCount, fieldNumber: 1)
    }
    if self.sourceType != .tokenSourceUnspecified {
      try visitor.visitSingularEnumField(value: self.sourceType, fieldNumber: 2)
    }
    if self.sourceID != 0 {
      try visitor.visitSingularInt64Field(value: self.sourceID, fieldNumber: 3)
    }
    if self.consumedAt != 0 {
      try visitor.visitSingularInt64Field(value: self.consumedAt, fieldNumber: 4)
    }
    if !self.purpose.isEmpty {
      try visitor.visitSingularStringField(value: self.purpose, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_TokenConsumption, rhs: Rankquantity_Voyager_Api_TokenConsumption) -> Bool {
    if lhs.tokenCount != rhs.tokenCount {return false}
    if lhs.sourceType != rhs.sourceType {return false}
    if lhs.sourceID != rhs.sourceID {return false}
    if lhs.consumedAt != rhs.consumedAt {return false}
    if lhs.purpose != rhs.purpose {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_AIPolishRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AIPolishRecord"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}original_content\0\u{3}polished_content\0\u{3}polished_at\0\u{3}polish_type\0\u{3}token_consumption\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.originalContent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.polishedContent) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.polishedAt) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.polishType) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._tokenConsumption) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.originalContent.isEmpty {
      try visitor.visitSingularStringField(value: self.originalContent, fieldNumber: 1)
    }
    if !self.polishedContent.isEmpty {
      try visitor.visitSingularStringField(value: self.polishedContent, fieldNumber: 2)
    }
    if self.polishedAt != 0 {
      try visitor.visitSingularInt64Field(value: self.polishedAt, fieldNumber: 3)
    }
    if !self.polishType.isEmpty {
      try visitor.visitSingularStringField(value: self.polishType, fieldNumber: 4)
    }
    try { if let v = self._tokenConsumption {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_AIPolishRecord, rhs: Rankquantity_Voyager_Api_AIPolishRecord) -> Bool {
    if lhs.originalContent != rhs.originalContent {return false}
    if lhs.polishedContent != rhs.polishedContent {return false}
    if lhs.polishedAt != rhs.polishedAt {return false}
    if lhs.polishType != rhs.polishType {return false}
    if lhs._tokenConsumption != rhs._tokenConsumption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_ChapterTranslationRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChapterTranslationRecord"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}chapter_id\0\u{3}chapter_title\0\u{3}original_scene\0\u{3}translated_scene\0\u{3}original_image_desc\0\u{3}translated_image_desc\0\u{3}translated_at\0\u{3}token_consumption\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.chapterID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.chapterTitle) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.originalScene) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.translatedScene) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.originalImageDesc) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.translatedImageDesc) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.translatedAt) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._tokenConsumption) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.chapterID.isEmpty {
      try visitor.visitSingularStringField(value: self.chapterID, fieldNumber: 1)
    }
    if !self.chapterTitle.isEmpty {
      try visitor.visitSingularStringField(value: self.chapterTitle, fieldNumber: 2)
    }
    if !self.originalScene.isEmpty {
      try visitor.visitSingularStringField(value: self.originalScene, fieldNumber: 3)
    }
    if !self.translatedScene.isEmpty {
      try visitor.visitSingularStringField(value: self.translatedScene, fieldNumber: 4)
    }
    if !self.originalImageDesc.isEmpty {
      try visitor.visitSingularStringField(value: self.originalImageDesc, fieldNumber: 5)
    }
    if !self.translatedImageDesc.isEmpty {
      try visitor.visitSingularStringField(value: self.translatedImageDesc, fieldNumber: 6)
    }
    if self.translatedAt != 0 {
      try visitor.visitSingularInt64Field(value: self.translatedAt, fieldNumber: 7)
    }
    try { if let v = self._tokenConsumption {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_ChapterTranslationRecord, rhs: Rankquantity_Voyager_Api_ChapterTranslationRecord) -> Bool {
    if lhs.chapterID != rhs.chapterID {return false}
    if lhs.chapterTitle != rhs.chapterTitle {return false}
    if lhs.originalScene != rhs.originalScene {return false}
    if lhs.translatedScene != rhs.translatedScene {return false}
    if lhs.originalImageDesc != rhs.originalImageDesc {return false}
    if lhs.translatedImageDesc != rhs.translatedImageDesc {return false}
    if lhs.translatedAt != rhs.translatedAt {return false}
    if lhs._tokenConsumption != rhs._tokenConsumption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GenerationPromptRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerationPromptRecord"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}content_type\0\u{3}content_id\0\u{3}image_prompt\0\u{3}video_prompt\0\u{3}generated_images\0\u{3}generated_video\0\u{3}generated_at\0\u{3}token_consumption\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contentType) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.contentID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.imagePrompt) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.videoPrompt) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.generatedImages) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.generatedVideo) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.generatedAt) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._tokenConsumption) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.contentType.isEmpty {
      try visitor.visitSingularStringField(value: self.contentType, fieldNumber: 1)
    }
    if self.contentID != 0 {
      try visitor.visitSingularInt64Field(value: self.contentID, fieldNumber: 2)
    }
    if !self.imagePrompt.isEmpty {
      try visitor.visitSingularStringField(value: self.imagePrompt, fieldNumber: 3)
    }
    if !self.videoPrompt.isEmpty {
      try visitor.visitSingularStringField(value: self.videoPrompt, fieldNumber: 4)
    }
    if !self.generatedImages.isEmpty {
      try visitor.visitRepeatedStringField(value: self.generatedImages, fieldNumber: 5)
    }
    if !self.generatedVideo.isEmpty {
      try visitor.visitSingularStringField(value: self.generatedVideo, fieldNumber: 6)
    }
    if self.generatedAt != 0 {
      try visitor.visitSingularInt64Field(value: self.generatedAt, fieldNumber: 7)
    }
    try { if let v = self._tokenConsumption {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GenerationPromptRecord, rhs: Rankquantity_Voyager_Api_GenerationPromptRecord) -> Bool {
    if lhs.contentType != rhs.contentType {return false}
    if lhs.contentID != rhs.contentID {return false}
    if lhs.imagePrompt != rhs.imagePrompt {return false}
    if lhs.videoPrompt != rhs.videoPrompt {return false}
    if lhs.generatedImages != rhs.generatedImages {return false}
    if lhs.generatedVideo != rhs.generatedVideo {return false}
    if lhs.generatedAt != rhs.generatedAt {return false}
    if lhs._tokenConsumption != rhs._tokenConsumption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_StoryGenerationHistory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StoryGenerationHistory"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_info\0\u{1}roles\0\u{3}polish_records\0\u{3}chapter_info\0\u{3}translation_records\0\u{3}prompt_records\0\u{3}final_content\0\u{1}creator\0\u{3}total_token_consumptions\0\u{3}child_storyboard_count\0\u{3}created_at\0\u{3}updated_at\0")

  fileprivate class _StorageClass {
    var _storyInfo: Rankquantity_Voyager_Api_Story? = nil
    var _roles: [Rankquantity_Voyager_Api_StoryRole] = []
    var _polishRecords: [Rankquantity_Voyager_Api_AIPolishRecord] = []
    var _chapterInfo: Rankquantity_Voyager_Api_StoryInfo? = nil
    var _translationRecords: [Rankquantity_Voyager_Api_ChapterTranslationRecord] = []
    var _promptRecords: [Rankquantity_Voyager_Api_GenerationPromptRecord] = []
    var _finalContent: [Rankquantity_Voyager_Api_StoryBoard] = []
    var _creator: Rankquantity_Voyager_Api_UserInfo? = nil
    var _totalTokenConsumptions: [Rankquantity_Voyager_Api_TokenConsumption] = []
    var _childStoryboardCount: Int64 = 0
    var _createdAt: Int64 = 0
    var _updatedAt: Int64 = 0

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _storyInfo = source._storyInfo
      _roles = source._roles
      _polishRecords = source._polishRecords
      _chapterInfo = source._chapterInfo
      _translationRecords = source._translationRecords
      _promptRecords = source._promptRecords
      _finalContent = source._finalContent
      _creator = source._creator
      _totalTokenConsumptions = source._totalTokenConsumptions
      _childStoryboardCount = source._childStoryboardCount
      _createdAt = source._createdAt
      _updatedAt = source._updatedAt
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._storyInfo) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._roles) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._polishRecords) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._chapterInfo) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._translationRecords) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._promptRecords) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._finalContent) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._creator) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._totalTokenConsumptions) }()
        case 10: try { try decoder.decodeSingularInt64Field(value: &_storage._childStoryboardCount) }()
        case 11: try { try decoder.decodeSingularInt64Field(value: &_storage._createdAt) }()
        case 12: try { try decoder.decodeSingularInt64Field(value: &_storage._updatedAt) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._storyInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._roles.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._roles, fieldNumber: 2)
      }
      if !_storage._polishRecords.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._polishRecords, fieldNumber: 3)
      }
      try { if let v = _storage._chapterInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._translationRecords.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._translationRecords, fieldNumber: 5)
      }
      if !_storage._promptRecords.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._promptRecords, fieldNumber: 6)
      }
      if !_storage._finalContent.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._finalContent, fieldNumber: 7)
      }
      try { if let v = _storage._creator {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._totalTokenConsumptions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._totalTokenConsumptions, fieldNumber: 9)
      }
      if _storage._childStoryboardCount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._childStoryboardCount, fieldNumber: 10)
      }
      if _storage._createdAt != 0 {
        try visitor.visitSingularInt64Field(value: _storage._createdAt, fieldNumber: 11)
      }
      if _storage._updatedAt != 0 {
        try visitor.visitSingularInt64Field(value: _storage._updatedAt, fieldNumber: 12)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_StoryGenerationHistory, rhs: Rankquantity_Voyager_Api_StoryGenerationHistory) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._storyInfo != rhs_storage._storyInfo {return false}
        if _storage._roles != rhs_storage._roles {return false}
        if _storage._polishRecords != rhs_storage._polishRecords {return false}
        if _storage._chapterInfo != rhs_storage._chapterInfo {return false}
        if _storage._translationRecords != rhs_storage._translationRecords {return false}
        if _storage._promptRecords != rhs_storage._promptRecords {return false}
        if _storage._finalContent != rhs_storage._finalContent {return false}
        if _storage._creator != rhs_storage._creator {return false}
        if _storage._totalTokenConsumptions != rhs_storage._totalTokenConsumptions {return false}
        if _storage._childStoryboardCount != rhs_storage._childStoryboardCount {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._updatedAt != rhs_storage._updatedAt {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryGenerationHistoryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryGenerationHistoryRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}story_id\0\u{3}user_id\0\u{3}storyboard_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.storyboardID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storyID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if self.storyboardID != 0 {
      try visitor.visitSingularInt64Field(value: self.storyboardID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryGenerationHistoryRequest, rhs: Rankquantity_Voyager_Api_GetStoryGenerationHistoryRequest) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.storyboardID != rhs.storyboardID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rankquantity_Voyager_Api_GetStoryGenerationHistoryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStoryGenerationHistoryResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rankquantity_Voyager_Api_GetStoryGenerationHistoryResponse, rhs: Rankquantity_Voyager_Api_GetStoryGenerationHistoryResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
